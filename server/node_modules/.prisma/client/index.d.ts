
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Kitchen
 * 
 */
export type Kitchen = $Result.DefaultSelection<Prisma.$KitchenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model EmployeeProfile
 * 
 */
export type EmployeeProfile = $Result.DefaultSelection<Prisma.$EmployeeProfilePayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model KitchenStock
 * 
 */
export type KitchenStock = $Result.DefaultSelection<Prisma.$KitchenStockPayload>
/**
 * Model StockLedger
 * 
 */
export type StockLedger = $Result.DefaultSelection<Prisma.$StockLedgerPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseLine
 * 
 */
export type PurchaseLine = $Result.DefaultSelection<Prisma.$PurchaseLinePayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model TransferLine
 * 
 */
export type TransferLine = $Result.DefaultSelection<Prisma.$TransferLinePayload>
/**
 * Model AttendanceEvent
 * 
 */
export type AttendanceEvent = $Result.DefaultSelection<Prisma.$AttendanceEventPayload>
/**
 * Model ShiftDaySummary
 * 
 */
export type ShiftDaySummary = $Result.DefaultSelection<Prisma.$ShiftDaySummaryPayload>
/**
 * Model PayrollPeriod
 * 
 */
export type PayrollPeriod = $Result.DefaultSelection<Prisma.$PayrollPeriodPayload>
/**
 * Model PayrollEntry
 * 
 */
export type PayrollEntry = $Result.DefaultSelection<Prisma.$PayrollEntryPayload>
/**
 * Model Reminder
 * 
 */
export type Reminder = $Result.DefaultSelection<Prisma.$ReminderPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const KitchenType: {
  KING: 'KING',
  BRANCH: 'BRANCH'
};

export type KitchenType = (typeof KitchenType)[keyof typeof KitchenType]


export const UserRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  STOREKEEPER: 'STOREKEEPER',
  HR: 'HR',
  EMPLOYEE: 'EMPLOYEE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const StockLedgerType: {
  PURCHASE: 'PURCHASE',
  TRANSFER_OUT: 'TRANSFER_OUT',
  TRANSFER_IN: 'TRANSFER_IN',
  ADJUSTMENT: 'ADJUSTMENT',
  WASTAGE: 'WASTAGE',
  CONSUMPTION: 'CONSUMPTION'
};

export type StockLedgerType = (typeof StockLedgerType)[keyof typeof StockLedgerType]


export const TransferStatus: {
  REQUESTED: 'REQUESTED',
  APPROVED: 'APPROVED',
  DISPATCHED: 'DISPATCHED',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const AttendanceType: {
  IN: 'IN',
  OUT: 'OUT'
};

export type AttendanceType = (typeof AttendanceType)[keyof typeof AttendanceType]


export const AttendanceMethod: {
  GEO: 'GEO',
  MANUAL: 'MANUAL'
};

export type AttendanceMethod = (typeof AttendanceMethod)[keyof typeof AttendanceMethod]


export const PayrollPeriodStatus: {
  DRAFT: 'DRAFT',
  FINAL: 'FINAL'
};

export type PayrollPeriodStatus = (typeof PayrollPeriodStatus)[keyof typeof PayrollPeriodStatus]


export const ReminderType: {
  PAYROLL_DUE: 'PAYROLL_DUE',
  LOW_STOCK: 'LOW_STOCK'
};

export type ReminderType = (typeof ReminderType)[keyof typeof ReminderType]


export const ReminderStatus: {
  OPEN: 'OPEN',
  DONE: 'DONE'
};

export type ReminderStatus = (typeof ReminderStatus)[keyof typeof ReminderStatus]

}

export type KitchenType = $Enums.KitchenType

export const KitchenType: typeof $Enums.KitchenType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type StockLedgerType = $Enums.StockLedgerType

export const StockLedgerType: typeof $Enums.StockLedgerType

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type AttendanceType = $Enums.AttendanceType

export const AttendanceType: typeof $Enums.AttendanceType

export type AttendanceMethod = $Enums.AttendanceMethod

export const AttendanceMethod: typeof $Enums.AttendanceMethod

export type PayrollPeriodStatus = $Enums.PayrollPeriodStatus

export const PayrollPeriodStatus: typeof $Enums.PayrollPeriodStatus

export type ReminderType = $Enums.ReminderType

export const ReminderType: typeof $Enums.ReminderType

export type ReminderStatus = $Enums.ReminderStatus

export const ReminderStatus: typeof $Enums.ReminderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Kitchens
 * const kitchens = await prisma.kitchen.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Kitchens
   * const kitchens = await prisma.kitchen.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.kitchen`: Exposes CRUD operations for the **Kitchen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kitchens
    * const kitchens = await prisma.kitchen.findMany()
    * ```
    */
  get kitchen(): Prisma.KitchenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeProfile`: Exposes CRUD operations for the **EmployeeProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeProfiles
    * const employeeProfiles = await prisma.employeeProfile.findMany()
    * ```
    */
  get employeeProfile(): Prisma.EmployeeProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kitchenStock`: Exposes CRUD operations for the **KitchenStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KitchenStocks
    * const kitchenStocks = await prisma.kitchenStock.findMany()
    * ```
    */
  get kitchenStock(): Prisma.KitchenStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockLedger`: Exposes CRUD operations for the **StockLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockLedgers
    * const stockLedgers = await prisma.stockLedger.findMany()
    * ```
    */
  get stockLedger(): Prisma.StockLedgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseLine`: Exposes CRUD operations for the **PurchaseLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseLines
    * const purchaseLines = await prisma.purchaseLine.findMany()
    * ```
    */
  get purchaseLine(): Prisma.PurchaseLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transferLine`: Exposes CRUD operations for the **TransferLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferLines
    * const transferLines = await prisma.transferLine.findMany()
    * ```
    */
  get transferLine(): Prisma.TransferLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceEvent`: Exposes CRUD operations for the **AttendanceEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceEvents
    * const attendanceEvents = await prisma.attendanceEvent.findMany()
    * ```
    */
  get attendanceEvent(): Prisma.AttendanceEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shiftDaySummary`: Exposes CRUD operations for the **ShiftDaySummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftDaySummaries
    * const shiftDaySummaries = await prisma.shiftDaySummary.findMany()
    * ```
    */
  get shiftDaySummary(): Prisma.ShiftDaySummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollPeriod`: Exposes CRUD operations for the **PayrollPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollPeriods
    * const payrollPeriods = await prisma.payrollPeriod.findMany()
    * ```
    */
  get payrollPeriod(): Prisma.PayrollPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollEntry`: Exposes CRUD operations for the **PayrollEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollEntries
    * const payrollEntries = await prisma.payrollEntry.findMany()
    * ```
    */
  get payrollEntry(): Prisma.PayrollEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reminder`: Exposes CRUD operations for the **Reminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reminders
    * const reminders = await prisma.reminder.findMany()
    * ```
    */
  get reminder(): Prisma.ReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Kitchen: 'Kitchen',
    User: 'User',
    EmployeeProfile: 'EmployeeProfile',
    Supplier: 'Supplier',
    Item: 'Item',
    KitchenStock: 'KitchenStock',
    StockLedger: 'StockLedger',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseLine: 'PurchaseLine',
    Transfer: 'Transfer',
    TransferLine: 'TransferLine',
    AttendanceEvent: 'AttendanceEvent',
    ShiftDaySummary: 'ShiftDaySummary',
    PayrollPeriod: 'PayrollPeriod',
    PayrollEntry: 'PayrollEntry',
    Reminder: 'Reminder',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "kitchen" | "user" | "employeeProfile" | "supplier" | "item" | "kitchenStock" | "stockLedger" | "purchaseOrder" | "purchaseLine" | "transfer" | "transferLine" | "attendanceEvent" | "shiftDaySummary" | "payrollPeriod" | "payrollEntry" | "reminder" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Kitchen: {
        payload: Prisma.$KitchenPayload<ExtArgs>
        fields: Prisma.KitchenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KitchenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KitchenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          findFirst: {
            args: Prisma.KitchenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KitchenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          findMany: {
            args: Prisma.KitchenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          create: {
            args: Prisma.KitchenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          createMany: {
            args: Prisma.KitchenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KitchenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          delete: {
            args: Prisma.KitchenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          update: {
            args: Prisma.KitchenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          deleteMany: {
            args: Prisma.KitchenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KitchenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KitchenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          upsert: {
            args: Prisma.KitchenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          aggregate: {
            args: Prisma.KitchenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKitchen>
          }
          groupBy: {
            args: Prisma.KitchenGroupByArgs<ExtArgs>
            result: $Utils.Optional<KitchenGroupByOutputType>[]
          }
          count: {
            args: Prisma.KitchenCountArgs<ExtArgs>
            result: $Utils.Optional<KitchenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      EmployeeProfile: {
        payload: Prisma.$EmployeeProfilePayload<ExtArgs>
        fields: Prisma.EmployeeProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findFirst: {
            args: Prisma.EmployeeProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findMany: {
            args: Prisma.EmployeeProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          create: {
            args: Prisma.EmployeeProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          createMany: {
            args: Prisma.EmployeeProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          delete: {
            args: Prisma.EmployeeProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          update: {
            args: Prisma.EmployeeProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          aggregate: {
            args: Prisma.EmployeeProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeProfile>
          }
          groupBy: {
            args: Prisma.EmployeeProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      KitchenStock: {
        payload: Prisma.$KitchenStockPayload<ExtArgs>
        fields: Prisma.KitchenStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KitchenStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KitchenStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>
          }
          findFirst: {
            args: Prisma.KitchenStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KitchenStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>
          }
          findMany: {
            args: Prisma.KitchenStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>[]
          }
          create: {
            args: Prisma.KitchenStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>
          }
          createMany: {
            args: Prisma.KitchenStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KitchenStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>[]
          }
          delete: {
            args: Prisma.KitchenStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>
          }
          update: {
            args: Prisma.KitchenStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>
          }
          deleteMany: {
            args: Prisma.KitchenStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KitchenStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KitchenStockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>[]
          }
          upsert: {
            args: Prisma.KitchenStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenStockPayload>
          }
          aggregate: {
            args: Prisma.KitchenStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKitchenStock>
          }
          groupBy: {
            args: Prisma.KitchenStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<KitchenStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.KitchenStockCountArgs<ExtArgs>
            result: $Utils.Optional<KitchenStockCountAggregateOutputType> | number
          }
        }
      }
      StockLedger: {
        payload: Prisma.$StockLedgerPayload<ExtArgs>
        fields: Prisma.StockLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          findFirst: {
            args: Prisma.StockLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          findMany: {
            args: Prisma.StockLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>[]
          }
          create: {
            args: Prisma.StockLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          createMany: {
            args: Prisma.StockLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>[]
          }
          delete: {
            args: Prisma.StockLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          update: {
            args: Prisma.StockLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          deleteMany: {
            args: Prisma.StockLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockLedgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>[]
          }
          upsert: {
            args: Prisma.StockLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLedgerPayload>
          }
          aggregate: {
            args: Prisma.StockLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockLedger>
          }
          groupBy: {
            args: Prisma.StockLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<StockLedgerCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseLine: {
        payload: Prisma.$PurchaseLinePayload<ExtArgs>
        fields: Prisma.PurchaseLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          findFirst: {
            args: Prisma.PurchaseLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          findMany: {
            args: Prisma.PurchaseLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>[]
          }
          create: {
            args: Prisma.PurchaseLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          createMany: {
            args: Prisma.PurchaseLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>[]
          }
          delete: {
            args: Prisma.PurchaseLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          update: {
            args: Prisma.PurchaseLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          aggregate: {
            args: Prisma.PurchaseLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseLine>
          }
          groupBy: {
            args: Prisma.PurchaseLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseLineCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseLineCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      TransferLine: {
        payload: Prisma.$TransferLinePayload<ExtArgs>
        fields: Prisma.TransferLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          findFirst: {
            args: Prisma.TransferLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          findMany: {
            args: Prisma.TransferLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>[]
          }
          create: {
            args: Prisma.TransferLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          createMany: {
            args: Prisma.TransferLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>[]
          }
          delete: {
            args: Prisma.TransferLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          update: {
            args: Prisma.TransferLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          deleteMany: {
            args: Prisma.TransferLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>[]
          }
          upsert: {
            args: Prisma.TransferLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferLinePayload>
          }
          aggregate: {
            args: Prisma.TransferLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferLine>
          }
          groupBy: {
            args: Prisma.TransferLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferLineCountArgs<ExtArgs>
            result: $Utils.Optional<TransferLineCountAggregateOutputType> | number
          }
        }
      }
      AttendanceEvent: {
        payload: Prisma.$AttendanceEventPayload<ExtArgs>
        fields: Prisma.AttendanceEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          findFirst: {
            args: Prisma.AttendanceEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          findMany: {
            args: Prisma.AttendanceEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          create: {
            args: Prisma.AttendanceEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          createMany: {
            args: Prisma.AttendanceEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          delete: {
            args: Prisma.AttendanceEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          update: {
            args: Prisma.AttendanceEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceEventPayload>
          }
          aggregate: {
            args: Prisma.AttendanceEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceEvent>
          }
          groupBy: {
            args: Prisma.AttendanceEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceEventCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceEventCountAggregateOutputType> | number
          }
        }
      }
      ShiftDaySummary: {
        payload: Prisma.$ShiftDaySummaryPayload<ExtArgs>
        fields: Prisma.ShiftDaySummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftDaySummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftDaySummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>
          }
          findFirst: {
            args: Prisma.ShiftDaySummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftDaySummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>
          }
          findMany: {
            args: Prisma.ShiftDaySummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>[]
          }
          create: {
            args: Prisma.ShiftDaySummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>
          }
          createMany: {
            args: Prisma.ShiftDaySummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftDaySummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>[]
          }
          delete: {
            args: Prisma.ShiftDaySummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>
          }
          update: {
            args: Prisma.ShiftDaySummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDaySummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftDaySummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftDaySummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>[]
          }
          upsert: {
            args: Prisma.ShiftDaySummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftDaySummaryPayload>
          }
          aggregate: {
            args: Prisma.ShiftDaySummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftDaySummary>
          }
          groupBy: {
            args: Prisma.ShiftDaySummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftDaySummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftDaySummaryCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftDaySummaryCountAggregateOutputType> | number
          }
        }
      }
      PayrollPeriod: {
        payload: Prisma.$PayrollPeriodPayload<ExtArgs>
        fields: Prisma.PayrollPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          findFirst: {
            args: Prisma.PayrollPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          findMany: {
            args: Prisma.PayrollPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          create: {
            args: Prisma.PayrollPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          createMany: {
            args: Prisma.PayrollPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          delete: {
            args: Prisma.PayrollPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          update: {
            args: Prisma.PayrollPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          deleteMany: {
            args: Prisma.PayrollPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>[]
          }
          upsert: {
            args: Prisma.PayrollPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPeriodPayload>
          }
          aggregate: {
            args: Prisma.PayrollPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollPeriod>
          }
          groupBy: {
            args: Prisma.PayrollPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollPeriodCountAggregateOutputType> | number
          }
        }
      }
      PayrollEntry: {
        payload: Prisma.$PayrollEntryPayload<ExtArgs>
        fields: Prisma.PayrollEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          findFirst: {
            args: Prisma.PayrollEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          findMany: {
            args: Prisma.PayrollEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          create: {
            args: Prisma.PayrollEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          createMany: {
            args: Prisma.PayrollEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          delete: {
            args: Prisma.PayrollEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          update: {
            args: Prisma.PayrollEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          deleteMany: {
            args: Prisma.PayrollEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          upsert: {
            args: Prisma.PayrollEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          aggregate: {
            args: Prisma.PayrollEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollEntry>
          }
          groupBy: {
            args: Prisma.PayrollEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollEntryCountAggregateOutputType> | number
          }
        }
      }
      Reminder: {
        payload: Prisma.$ReminderPayload<ExtArgs>
        fields: Prisma.ReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          findFirst: {
            args: Prisma.ReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          findMany: {
            args: Prisma.ReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          create: {
            args: Prisma.ReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          createMany: {
            args: Prisma.ReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          delete: {
            args: Prisma.ReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          update: {
            args: Prisma.ReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          deleteMany: {
            args: Prisma.ReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>[]
          }
          upsert: {
            args: Prisma.ReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderPayload>
          }
          aggregate: {
            args: Prisma.ReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReminder>
          }
          groupBy: {
            args: Prisma.ReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReminderCountArgs<ExtArgs>
            result: $Utils.Optional<ReminderCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    kitchen?: KitchenOmit
    user?: UserOmit
    employeeProfile?: EmployeeProfileOmit
    supplier?: SupplierOmit
    item?: ItemOmit
    kitchenStock?: KitchenStockOmit
    stockLedger?: StockLedgerOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseLine?: PurchaseLineOmit
    transfer?: TransferOmit
    transferLine?: TransferLineOmit
    attendanceEvent?: AttendanceEventOmit
    shiftDaySummary?: ShiftDaySummaryOmit
    payrollPeriod?: PayrollPeriodOmit
    payrollEntry?: PayrollEntryOmit
    reminder?: ReminderOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type KitchenCountOutputType
   */

  export type KitchenCountOutputType = {
    users: number
    stocks: number
    ledger: number
    purchases: number
    transfersFrom: number
    transfersTo: number
    attendanceEvents: number
    shiftSummaries: number
  }

  export type KitchenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | KitchenCountOutputTypeCountUsersArgs
    stocks?: boolean | KitchenCountOutputTypeCountStocksArgs
    ledger?: boolean | KitchenCountOutputTypeCountLedgerArgs
    purchases?: boolean | KitchenCountOutputTypeCountPurchasesArgs
    transfersFrom?: boolean | KitchenCountOutputTypeCountTransfersFromArgs
    transfersTo?: boolean | KitchenCountOutputTypeCountTransfersToArgs
    attendanceEvents?: boolean | KitchenCountOutputTypeCountAttendanceEventsArgs
    shiftSummaries?: boolean | KitchenCountOutputTypeCountShiftSummariesArgs
  }

  // Custom InputTypes
  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenCountOutputType
     */
    select?: KitchenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenStockWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountAttendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountShiftSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftDaySummaryWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdLedgerEntries: number
    requestedTransfers: number
    approvedTransfers: number
    dispatchedTransfers: number
    receivedTransfers: number
    attendanceEvents: number
    shiftSummaries: number
    payrollEntries: number
    remindersCreated: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdLedgerEntries?: boolean | UserCountOutputTypeCountCreatedLedgerEntriesArgs
    requestedTransfers?: boolean | UserCountOutputTypeCountRequestedTransfersArgs
    approvedTransfers?: boolean | UserCountOutputTypeCountApprovedTransfersArgs
    dispatchedTransfers?: boolean | UserCountOutputTypeCountDispatchedTransfersArgs
    receivedTransfers?: boolean | UserCountOutputTypeCountReceivedTransfersArgs
    attendanceEvents?: boolean | UserCountOutputTypeCountAttendanceEventsArgs
    shiftSummaries?: boolean | UserCountOutputTypeCountShiftSummariesArgs
    payrollEntries?: boolean | UserCountOutputTypeCountPayrollEntriesArgs
    remindersCreated?: boolean | UserCountOutputTypeCountRemindersCreatedArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDispatchedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftDaySummaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRemindersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchaseOrders: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    stocks: number
    ledger: number
    purchaseLines: number
    transferLines: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | ItemCountOutputTypeCountStocksArgs
    ledger?: boolean | ItemCountOutputTypeCountLedgerArgs
    purchaseLines?: boolean | ItemCountOutputTypeCountPurchaseLinesArgs
    transferLines?: boolean | ItemCountOutputTypeCountTransferLinesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenStockWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPurchaseLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountTransferLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferLineWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    lines: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | PurchaseOrderCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLineWhereInput
  }


  /**
   * Count Type TransferCountOutputType
   */

  export type TransferCountOutputType = {
    lines: number
  }

  export type TransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | TransferCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferCountOutputType
     */
    select?: TransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferLineWhereInput
  }


  /**
   * Count Type PayrollPeriodCountOutputType
   */

  export type PayrollPeriodCountOutputType = {
    entries: number
  }

  export type PayrollPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | PayrollPeriodCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * PayrollPeriodCountOutputType without action
   */
  export type PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriodCountOutputType
     */
    select?: PayrollPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollPeriodCountOutputType without action
   */
  export type PayrollPeriodCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Kitchen
   */

  export type AggregateKitchen = {
    _count: KitchenCountAggregateOutputType | null
    _avg: KitchenAvgAggregateOutputType | null
    _sum: KitchenSumAggregateOutputType | null
    _min: KitchenMinAggregateOutputType | null
    _max: KitchenMaxAggregateOutputType | null
  }

  export type KitchenAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
    geofenceRadiusMeters: number | null
  }

  export type KitchenSumAggregateOutputType = {
    lat: number | null
    lng: number | null
    geofenceRadiusMeters: number | null
  }

  export type KitchenMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.KitchenType | null
    address: string | null
    lat: number | null
    lng: number | null
    geofenceRadiusMeters: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KitchenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.KitchenType | null
    address: string | null
    lat: number | null
    lng: number | null
    geofenceRadiusMeters: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KitchenCountAggregateOutputType = {
    id: number
    name: number
    type: number
    address: number
    lat: number
    lng: number
    geofenceRadiusMeters: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KitchenAvgAggregateInputType = {
    lat?: true
    lng?: true
    geofenceRadiusMeters?: true
  }

  export type KitchenSumAggregateInputType = {
    lat?: true
    lng?: true
    geofenceRadiusMeters?: true
  }

  export type KitchenMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    lat?: true
    lng?: true
    geofenceRadiusMeters?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KitchenMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    lat?: true
    lng?: true
    geofenceRadiusMeters?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KitchenCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    lat?: true
    lng?: true
    geofenceRadiusMeters?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KitchenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kitchen to aggregate.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kitchens
    **/
    _count?: true | KitchenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KitchenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KitchenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KitchenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KitchenMaxAggregateInputType
  }

  export type GetKitchenAggregateType<T extends KitchenAggregateArgs> = {
        [P in keyof T & keyof AggregateKitchen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKitchen[P]>
      : GetScalarType<T[P], AggregateKitchen[P]>
  }




  export type KitchenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenWhereInput
    orderBy?: KitchenOrderByWithAggregationInput | KitchenOrderByWithAggregationInput[]
    by: KitchenScalarFieldEnum[] | KitchenScalarFieldEnum
    having?: KitchenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KitchenCountAggregateInputType | true
    _avg?: KitchenAvgAggregateInputType
    _sum?: KitchenSumAggregateInputType
    _min?: KitchenMinAggregateInputType
    _max?: KitchenMaxAggregateInputType
  }

  export type KitchenGroupByOutputType = {
    id: string
    name: string
    type: $Enums.KitchenType
    address: string | null
    lat: number | null
    lng: number | null
    geofenceRadiusMeters: number
    createdAt: Date
    updatedAt: Date
    _count: KitchenCountAggregateOutputType | null
    _avg: KitchenAvgAggregateOutputType | null
    _sum: KitchenSumAggregateOutputType | null
    _min: KitchenMinAggregateOutputType | null
    _max: KitchenMaxAggregateOutputType | null
  }

  type GetKitchenGroupByPayload<T extends KitchenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KitchenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KitchenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KitchenGroupByOutputType[P]>
            : GetScalarType<T[P], KitchenGroupByOutputType[P]>
        }
      >
    >


  export type KitchenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    lat?: boolean
    lng?: boolean
    geofenceRadiusMeters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Kitchen$usersArgs<ExtArgs>
    stocks?: boolean | Kitchen$stocksArgs<ExtArgs>
    ledger?: boolean | Kitchen$ledgerArgs<ExtArgs>
    purchases?: boolean | Kitchen$purchasesArgs<ExtArgs>
    transfersFrom?: boolean | Kitchen$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Kitchen$transfersToArgs<ExtArgs>
    attendanceEvents?: boolean | Kitchen$attendanceEventsArgs<ExtArgs>
    shiftSummaries?: boolean | Kitchen$shiftSummariesArgs<ExtArgs>
    _count?: boolean | KitchenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    lat?: boolean
    lng?: boolean
    geofenceRadiusMeters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    lat?: boolean
    lng?: boolean
    geofenceRadiusMeters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    lat?: boolean
    lng?: boolean
    geofenceRadiusMeters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KitchenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "address" | "lat" | "lng" | "geofenceRadiusMeters" | "createdAt" | "updatedAt", ExtArgs["result"]["kitchen"]>
  export type KitchenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Kitchen$usersArgs<ExtArgs>
    stocks?: boolean | Kitchen$stocksArgs<ExtArgs>
    ledger?: boolean | Kitchen$ledgerArgs<ExtArgs>
    purchases?: boolean | Kitchen$purchasesArgs<ExtArgs>
    transfersFrom?: boolean | Kitchen$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Kitchen$transfersToArgs<ExtArgs>
    attendanceEvents?: boolean | Kitchen$attendanceEventsArgs<ExtArgs>
    shiftSummaries?: boolean | Kitchen$shiftSummariesArgs<ExtArgs>
    _count?: boolean | KitchenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KitchenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KitchenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KitchenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kitchen"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      stocks: Prisma.$KitchenStockPayload<ExtArgs>[]
      ledger: Prisma.$StockLedgerPayload<ExtArgs>[]
      purchases: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      transfersFrom: Prisma.$TransferPayload<ExtArgs>[]
      transfersTo: Prisma.$TransferPayload<ExtArgs>[]
      attendanceEvents: Prisma.$AttendanceEventPayload<ExtArgs>[]
      shiftSummaries: Prisma.$ShiftDaySummaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.KitchenType
      address: string | null
      lat: number | null
      lng: number | null
      geofenceRadiusMeters: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kitchen"]>
    composites: {}
  }

  type KitchenGetPayload<S extends boolean | null | undefined | KitchenDefaultArgs> = $Result.GetResult<Prisma.$KitchenPayload, S>

  type KitchenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KitchenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KitchenCountAggregateInputType | true
    }

  export interface KitchenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kitchen'], meta: { name: 'Kitchen' } }
    /**
     * Find zero or one Kitchen that matches the filter.
     * @param {KitchenFindUniqueArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KitchenFindUniqueArgs>(args: SelectSubset<T, KitchenFindUniqueArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kitchen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KitchenFindUniqueOrThrowArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KitchenFindUniqueOrThrowArgs>(args: SelectSubset<T, KitchenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kitchen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindFirstArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KitchenFindFirstArgs>(args?: SelectSubset<T, KitchenFindFirstArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kitchen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindFirstOrThrowArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KitchenFindFirstOrThrowArgs>(args?: SelectSubset<T, KitchenFindFirstOrThrowArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kitchens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kitchens
     * const kitchens = await prisma.kitchen.findMany()
     * 
     * // Get first 10 Kitchens
     * const kitchens = await prisma.kitchen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KitchenFindManyArgs>(args?: SelectSubset<T, KitchenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kitchen.
     * @param {KitchenCreateArgs} args - Arguments to create a Kitchen.
     * @example
     * // Create one Kitchen
     * const Kitchen = await prisma.kitchen.create({
     *   data: {
     *     // ... data to create a Kitchen
     *   }
     * })
     * 
     */
    create<T extends KitchenCreateArgs>(args: SelectSubset<T, KitchenCreateArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kitchens.
     * @param {KitchenCreateManyArgs} args - Arguments to create many Kitchens.
     * @example
     * // Create many Kitchens
     * const kitchen = await prisma.kitchen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KitchenCreateManyArgs>(args?: SelectSubset<T, KitchenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kitchens and returns the data saved in the database.
     * @param {KitchenCreateManyAndReturnArgs} args - Arguments to create many Kitchens.
     * @example
     * // Create many Kitchens
     * const kitchen = await prisma.kitchen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kitchens and only return the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KitchenCreateManyAndReturnArgs>(args?: SelectSubset<T, KitchenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kitchen.
     * @param {KitchenDeleteArgs} args - Arguments to delete one Kitchen.
     * @example
     * // Delete one Kitchen
     * const Kitchen = await prisma.kitchen.delete({
     *   where: {
     *     // ... filter to delete one Kitchen
     *   }
     * })
     * 
     */
    delete<T extends KitchenDeleteArgs>(args: SelectSubset<T, KitchenDeleteArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kitchen.
     * @param {KitchenUpdateArgs} args - Arguments to update one Kitchen.
     * @example
     * // Update one Kitchen
     * const kitchen = await prisma.kitchen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KitchenUpdateArgs>(args: SelectSubset<T, KitchenUpdateArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kitchens.
     * @param {KitchenDeleteManyArgs} args - Arguments to filter Kitchens to delete.
     * @example
     * // Delete a few Kitchens
     * const { count } = await prisma.kitchen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KitchenDeleteManyArgs>(args?: SelectSubset<T, KitchenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kitchens
     * const kitchen = await prisma.kitchen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KitchenUpdateManyArgs>(args: SelectSubset<T, KitchenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kitchens and returns the data updated in the database.
     * @param {KitchenUpdateManyAndReturnArgs} args - Arguments to update many Kitchens.
     * @example
     * // Update many Kitchens
     * const kitchen = await prisma.kitchen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kitchens and only return the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KitchenUpdateManyAndReturnArgs>(args: SelectSubset<T, KitchenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kitchen.
     * @param {KitchenUpsertArgs} args - Arguments to update or create a Kitchen.
     * @example
     * // Update or create a Kitchen
     * const kitchen = await prisma.kitchen.upsert({
     *   create: {
     *     // ... data to create a Kitchen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kitchen we want to update
     *   }
     * })
     */
    upsert<T extends KitchenUpsertArgs>(args: SelectSubset<T, KitchenUpsertArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenCountArgs} args - Arguments to filter Kitchens to count.
     * @example
     * // Count the number of Kitchens
     * const count = await prisma.kitchen.count({
     *   where: {
     *     // ... the filter for the Kitchens we want to count
     *   }
     * })
    **/
    count<T extends KitchenCountArgs>(
      args?: Subset<T, KitchenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitchenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitchenAggregateArgs>(args: Subset<T, KitchenAggregateArgs>): Prisma.PrismaPromise<GetKitchenAggregateType<T>>

    /**
     * Group by Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitchenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitchenGroupByArgs['orderBy'] }
        : { orderBy?: KitchenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitchenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitchenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kitchen model
   */
  readonly fields: KitchenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kitchen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KitchenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Kitchen$usersArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stocks<T extends Kitchen$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ledger<T extends Kitchen$ledgerArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$ledgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends Kitchen$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersFrom<T extends Kitchen$transfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$transfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersTo<T extends Kitchen$transfersToArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$transfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceEvents<T extends Kitchen$attendanceEventsArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$attendanceEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shiftSummaries<T extends Kitchen$shiftSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$shiftSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kitchen model
   */
  interface KitchenFieldRefs {
    readonly id: FieldRef<"Kitchen", 'String'>
    readonly name: FieldRef<"Kitchen", 'String'>
    readonly type: FieldRef<"Kitchen", 'KitchenType'>
    readonly address: FieldRef<"Kitchen", 'String'>
    readonly lat: FieldRef<"Kitchen", 'Float'>
    readonly lng: FieldRef<"Kitchen", 'Float'>
    readonly geofenceRadiusMeters: FieldRef<"Kitchen", 'Int'>
    readonly createdAt: FieldRef<"Kitchen", 'DateTime'>
    readonly updatedAt: FieldRef<"Kitchen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kitchen findUnique
   */
  export type KitchenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen findUniqueOrThrow
   */
  export type KitchenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen findFirst
   */
  export type KitchenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kitchens.
     */
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen findFirstOrThrow
   */
  export type KitchenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kitchens.
     */
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen findMany
   */
  export type KitchenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchens to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen create
   */
  export type KitchenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * The data needed to create a Kitchen.
     */
    data: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
  }

  /**
   * Kitchen createMany
   */
  export type KitchenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kitchens.
     */
    data: KitchenCreateManyInput | KitchenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kitchen createManyAndReturn
   */
  export type KitchenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * The data used to create many Kitchens.
     */
    data: KitchenCreateManyInput | KitchenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kitchen update
   */
  export type KitchenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * The data needed to update a Kitchen.
     */
    data: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
    /**
     * Choose, which Kitchen to update.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen updateMany
   */
  export type KitchenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kitchens.
     */
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyInput>
    /**
     * Filter which Kitchens to update
     */
    where?: KitchenWhereInput
    /**
     * Limit how many Kitchens to update.
     */
    limit?: number
  }

  /**
   * Kitchen updateManyAndReturn
   */
  export type KitchenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * The data used to update Kitchens.
     */
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyInput>
    /**
     * Filter which Kitchens to update
     */
    where?: KitchenWhereInput
    /**
     * Limit how many Kitchens to update.
     */
    limit?: number
  }

  /**
   * Kitchen upsert
   */
  export type KitchenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * The filter to search for the Kitchen to update in case it exists.
     */
    where: KitchenWhereUniqueInput
    /**
     * In case the Kitchen found by the `where` argument doesn't exist, create a new Kitchen with this data.
     */
    create: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
    /**
     * In case the Kitchen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
  }

  /**
   * Kitchen delete
   */
  export type KitchenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter which Kitchen to delete.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen deleteMany
   */
  export type KitchenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kitchens to delete
     */
    where?: KitchenWhereInput
    /**
     * Limit how many Kitchens to delete.
     */
    limit?: number
  }

  /**
   * Kitchen.users
   */
  export type Kitchen$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Kitchen.stocks
   */
  export type Kitchen$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    where?: KitchenStockWhereInput
    orderBy?: KitchenStockOrderByWithRelationInput | KitchenStockOrderByWithRelationInput[]
    cursor?: KitchenStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitchenStockScalarFieldEnum | KitchenStockScalarFieldEnum[]
  }

  /**
   * Kitchen.ledger
   */
  export type Kitchen$ledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * Kitchen.purchases
   */
  export type Kitchen$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Kitchen.transfersFrom
   */
  export type Kitchen$transfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Kitchen.transfersTo
   */
  export type Kitchen$transfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Kitchen.attendanceEvents
   */
  export type Kitchen$attendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * Kitchen.shiftSummaries
   */
  export type Kitchen$shiftSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    where?: ShiftDaySummaryWhereInput
    orderBy?: ShiftDaySummaryOrderByWithRelationInput | ShiftDaySummaryOrderByWithRelationInput[]
    cursor?: ShiftDaySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftDaySummaryScalarFieldEnum | ShiftDaySummaryScalarFieldEnum[]
  }

  /**
   * Kitchen without action
   */
  export type KitchenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    kitchenId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    kitchenId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    passwordHash: number
    role: number
    isActive: number
    kitchenId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    kitchenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    kitchenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    isActive?: true
    kitchenId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    passwordHash: string
    role: $Enums.UserRole
    isActive: boolean
    kitchenId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    kitchenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kitchen?: boolean | User$kitchenArgs<ExtArgs>
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    createdLedgerEntries?: boolean | User$createdLedgerEntriesArgs<ExtArgs>
    requestedTransfers?: boolean | User$requestedTransfersArgs<ExtArgs>
    approvedTransfers?: boolean | User$approvedTransfersArgs<ExtArgs>
    dispatchedTransfers?: boolean | User$dispatchedTransfersArgs<ExtArgs>
    receivedTransfers?: boolean | User$receivedTransfersArgs<ExtArgs>
    attendanceEvents?: boolean | User$attendanceEventsArgs<ExtArgs>
    shiftSummaries?: boolean | User$shiftSummariesArgs<ExtArgs>
    payrollEntries?: boolean | User$payrollEntriesArgs<ExtArgs>
    remindersCreated?: boolean | User$remindersCreatedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    kitchenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kitchen?: boolean | User$kitchenArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    kitchenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kitchen?: boolean | User$kitchenArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    kitchenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "passwordHash" | "role" | "isActive" | "kitchenId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | User$kitchenArgs<ExtArgs>
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    createdLedgerEntries?: boolean | User$createdLedgerEntriesArgs<ExtArgs>
    requestedTransfers?: boolean | User$requestedTransfersArgs<ExtArgs>
    approvedTransfers?: boolean | User$approvedTransfersArgs<ExtArgs>
    dispatchedTransfers?: boolean | User$dispatchedTransfersArgs<ExtArgs>
    receivedTransfers?: boolean | User$receivedTransfersArgs<ExtArgs>
    attendanceEvents?: boolean | User$attendanceEventsArgs<ExtArgs>
    shiftSummaries?: boolean | User$shiftSummariesArgs<ExtArgs>
    payrollEntries?: boolean | User$payrollEntriesArgs<ExtArgs>
    remindersCreated?: boolean | User$remindersCreatedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | User$kitchenArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | User$kitchenArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      kitchen: Prisma.$KitchenPayload<ExtArgs> | null
      employeeProfile: Prisma.$EmployeeProfilePayload<ExtArgs> | null
      createdLedgerEntries: Prisma.$StockLedgerPayload<ExtArgs>[]
      requestedTransfers: Prisma.$TransferPayload<ExtArgs>[]
      approvedTransfers: Prisma.$TransferPayload<ExtArgs>[]
      dispatchedTransfers: Prisma.$TransferPayload<ExtArgs>[]
      receivedTransfers: Prisma.$TransferPayload<ExtArgs>[]
      attendanceEvents: Prisma.$AttendanceEventPayload<ExtArgs>[]
      shiftSummaries: Prisma.$ShiftDaySummaryPayload<ExtArgs>[]
      payrollEntries: Prisma.$PayrollEntryPayload<ExtArgs>[]
      remindersCreated: Prisma.$ReminderPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      passwordHash: string
      role: $Enums.UserRole
      isActive: boolean
      kitchenId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kitchen<T extends User$kitchenArgs<ExtArgs> = {}>(args?: Subset<T, User$kitchenArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employeeProfile<T extends User$employeeProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeProfileArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdLedgerEntries<T extends User$createdLedgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdLedgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestedTransfers<T extends User$requestedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$requestedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedTransfers<T extends User$approvedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispatchedTransfers<T extends User$dispatchedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$dispatchedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedTransfers<T extends User$receivedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceEvents<T extends User$attendanceEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$attendanceEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shiftSummaries<T extends User$shiftSummariesArgs<ExtArgs> = {}>(args?: Subset<T, User$shiftSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollEntries<T extends User$payrollEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    remindersCreated<T extends User$remindersCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$remindersCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly kitchenId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.kitchen
   */
  export type User$kitchenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    where?: KitchenWhereInput
  }

  /**
   * User.employeeProfile
   */
  export type User$employeeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    where?: EmployeeProfileWhereInput
  }

  /**
   * User.createdLedgerEntries
   */
  export type User$createdLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * User.requestedTransfers
   */
  export type User$requestedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.approvedTransfers
   */
  export type User$approvedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.dispatchedTransfers
   */
  export type User$dispatchedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.receivedTransfers
   */
  export type User$receivedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.attendanceEvents
   */
  export type User$attendanceEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    cursor?: AttendanceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * User.shiftSummaries
   */
  export type User$shiftSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    where?: ShiftDaySummaryWhereInput
    orderBy?: ShiftDaySummaryOrderByWithRelationInput | ShiftDaySummaryOrderByWithRelationInput[]
    cursor?: ShiftDaySummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftDaySummaryScalarFieldEnum | ShiftDaySummaryScalarFieldEnum[]
  }

  /**
   * User.payrollEntries
   */
  export type User$payrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    cursor?: PayrollEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * User.remindersCreated
   */
  export type User$remindersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    where?: ReminderWhereInput
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    cursor?: ReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeProfile
   */

  export type AggregateEmployeeProfile = {
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  export type EmployeeProfileAvgAggregateOutputType = {
    baseSalaryMonthly: number | null
    overtimeRatePerHour: number | null
    latePenaltyPerMinute: number | null
  }

  export type EmployeeProfileSumAggregateOutputType = {
    baseSalaryMonthly: number | null
    overtimeRatePerHour: number | null
    latePenaltyPerMinute: number | null
  }

  export type EmployeeProfileMinAggregateOutputType = {
    userId: string | null
    fullName: string | null
    baseSalaryMonthly: number | null
    overtimeRatePerHour: number | null
    latePenaltyPerMinute: number | null
    joinDate: Date | null
  }

  export type EmployeeProfileMaxAggregateOutputType = {
    userId: string | null
    fullName: string | null
    baseSalaryMonthly: number | null
    overtimeRatePerHour: number | null
    latePenaltyPerMinute: number | null
    joinDate: Date | null
  }

  export type EmployeeProfileCountAggregateOutputType = {
    userId: number
    fullName: number
    baseSalaryMonthly: number
    overtimeRatePerHour: number
    latePenaltyPerMinute: number
    joinDate: number
    _all: number
  }


  export type EmployeeProfileAvgAggregateInputType = {
    baseSalaryMonthly?: true
    overtimeRatePerHour?: true
    latePenaltyPerMinute?: true
  }

  export type EmployeeProfileSumAggregateInputType = {
    baseSalaryMonthly?: true
    overtimeRatePerHour?: true
    latePenaltyPerMinute?: true
  }

  export type EmployeeProfileMinAggregateInputType = {
    userId?: true
    fullName?: true
    baseSalaryMonthly?: true
    overtimeRatePerHour?: true
    latePenaltyPerMinute?: true
    joinDate?: true
  }

  export type EmployeeProfileMaxAggregateInputType = {
    userId?: true
    fullName?: true
    baseSalaryMonthly?: true
    overtimeRatePerHour?: true
    latePenaltyPerMinute?: true
    joinDate?: true
  }

  export type EmployeeProfileCountAggregateInputType = {
    userId?: true
    fullName?: true
    baseSalaryMonthly?: true
    overtimeRatePerHour?: true
    latePenaltyPerMinute?: true
    joinDate?: true
    _all?: true
  }

  export type EmployeeProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfile to aggregate.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeProfiles
    **/
    _count?: true | EmployeeProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type GetEmployeeProfileAggregateType<T extends EmployeeProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeProfile[P]>
      : GetScalarType<T[P], AggregateEmployeeProfile[P]>
  }




  export type EmployeeProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeProfileWhereInput
    orderBy?: EmployeeProfileOrderByWithAggregationInput | EmployeeProfileOrderByWithAggregationInput[]
    by: EmployeeProfileScalarFieldEnum[] | EmployeeProfileScalarFieldEnum
    having?: EmployeeProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeProfileCountAggregateInputType | true
    _avg?: EmployeeProfileAvgAggregateInputType
    _sum?: EmployeeProfileSumAggregateInputType
    _min?: EmployeeProfileMinAggregateInputType
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type EmployeeProfileGroupByOutputType = {
    userId: string
    fullName: string
    baseSalaryMonthly: number
    overtimeRatePerHour: number
    latePenaltyPerMinute: number
    joinDate: Date
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  type GetEmployeeProfileGroupByPayload<T extends EmployeeProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fullName?: boolean
    baseSalaryMonthly?: boolean
    overtimeRatePerHour?: boolean
    latePenaltyPerMinute?: boolean
    joinDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>

  export type EmployeeProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fullName?: boolean
    baseSalaryMonthly?: boolean
    overtimeRatePerHour?: boolean
    latePenaltyPerMinute?: boolean
    joinDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>

  export type EmployeeProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fullName?: boolean
    baseSalaryMonthly?: boolean
    overtimeRatePerHour?: boolean
    latePenaltyPerMinute?: boolean
    joinDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>

  export type EmployeeProfileSelectScalar = {
    userId?: boolean
    fullName?: boolean
    baseSalaryMonthly?: boolean
    overtimeRatePerHour?: boolean
    latePenaltyPerMinute?: boolean
    joinDate?: boolean
  }

  export type EmployeeProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "fullName" | "baseSalaryMonthly" | "overtimeRatePerHour" | "latePenaltyPerMinute" | "joinDate", ExtArgs["result"]["employeeProfile"]>
  export type EmployeeProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      fullName: string
      baseSalaryMonthly: number
      overtimeRatePerHour: number
      latePenaltyPerMinute: number
      joinDate: Date
    }, ExtArgs["result"]["employeeProfile"]>
    composites: {}
  }

  type EmployeeProfileGetPayload<S extends boolean | null | undefined | EmployeeProfileDefaultArgs> = $Result.GetResult<Prisma.$EmployeeProfilePayload, S>

  type EmployeeProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeProfileCountAggregateInputType | true
    }

  export interface EmployeeProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeProfile'], meta: { name: 'EmployeeProfile' } }
    /**
     * Find zero or one EmployeeProfile that matches the filter.
     * @param {EmployeeProfileFindUniqueArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeProfileFindUniqueArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeProfileFindUniqueOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeProfileFindFirstArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany()
     * 
     * // Get first 10 EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const employeeProfileWithUserIdOnly = await prisma.employeeProfile.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends EmployeeProfileFindManyArgs>(args?: SelectSubset<T, EmployeeProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeProfile.
     * @param {EmployeeProfileCreateArgs} args - Arguments to create a EmployeeProfile.
     * @example
     * // Create one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.create({
     *   data: {
     *     // ... data to create a EmployeeProfile
     *   }
     * })
     * 
     */
    create<T extends EmployeeProfileCreateArgs>(args: SelectSubset<T, EmployeeProfileCreateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeProfiles.
     * @param {EmployeeProfileCreateManyArgs} args - Arguments to create many EmployeeProfiles.
     * @example
     * // Create many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeProfileCreateManyArgs>(args?: SelectSubset<T, EmployeeProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeProfiles and returns the data saved in the database.
     * @param {EmployeeProfileCreateManyAndReturnArgs} args - Arguments to create many EmployeeProfiles.
     * @example
     * // Create many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeProfiles and only return the `userId`
     * const employeeProfileWithUserIdOnly = await prisma.employeeProfile.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeProfile.
     * @param {EmployeeProfileDeleteArgs} args - Arguments to delete one EmployeeProfile.
     * @example
     * // Delete one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.delete({
     *   where: {
     *     // ... filter to delete one EmployeeProfile
     *   }
     * })
     * 
     */
    delete<T extends EmployeeProfileDeleteArgs>(args: SelectSubset<T, EmployeeProfileDeleteArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeProfile.
     * @param {EmployeeProfileUpdateArgs} args - Arguments to update one EmployeeProfile.
     * @example
     * // Update one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeProfileUpdateArgs>(args: SelectSubset<T, EmployeeProfileUpdateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeProfiles.
     * @param {EmployeeProfileDeleteManyArgs} args - Arguments to filter EmployeeProfiles to delete.
     * @example
     * // Delete a few EmployeeProfiles
     * const { count } = await prisma.employeeProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeProfileDeleteManyArgs>(args?: SelectSubset<T, EmployeeProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeProfileUpdateManyArgs>(args: SelectSubset<T, EmployeeProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeProfiles and returns the data updated in the database.
     * @param {EmployeeProfileUpdateManyAndReturnArgs} args - Arguments to update many EmployeeProfiles.
     * @example
     * // Update many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeProfiles and only return the `userId`
     * const employeeProfileWithUserIdOnly = await prisma.employeeProfile.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeProfile.
     * @param {EmployeeProfileUpsertArgs} args - Arguments to update or create a EmployeeProfile.
     * @example
     * // Update or create a EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.upsert({
     *   create: {
     *     // ... data to create a EmployeeProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeProfile we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeProfileUpsertArgs>(args: SelectSubset<T, EmployeeProfileUpsertArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileCountArgs} args - Arguments to filter EmployeeProfiles to count.
     * @example
     * // Count the number of EmployeeProfiles
     * const count = await prisma.employeeProfile.count({
     *   where: {
     *     // ... the filter for the EmployeeProfiles we want to count
     *   }
     * })
    **/
    count<T extends EmployeeProfileCountArgs>(
      args?: Subset<T, EmployeeProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeProfileAggregateArgs>(args: Subset<T, EmployeeProfileAggregateArgs>): Prisma.PrismaPromise<GetEmployeeProfileAggregateType<T>>

    /**
     * Group by EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeProfileGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeProfile model
   */
  readonly fields: EmployeeProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeProfile model
   */
  interface EmployeeProfileFieldRefs {
    readonly userId: FieldRef<"EmployeeProfile", 'String'>
    readonly fullName: FieldRef<"EmployeeProfile", 'String'>
    readonly baseSalaryMonthly: FieldRef<"EmployeeProfile", 'Int'>
    readonly overtimeRatePerHour: FieldRef<"EmployeeProfile", 'Int'>
    readonly latePenaltyPerMinute: FieldRef<"EmployeeProfile", 'Int'>
    readonly joinDate: FieldRef<"EmployeeProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeProfile findUnique
   */
  export type EmployeeProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findUniqueOrThrow
   */
  export type EmployeeProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findFirst
   */
  export type EmployeeProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findFirstOrThrow
   */
  export type EmployeeProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findMany
   */
  export type EmployeeProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfiles to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile create
   */
  export type EmployeeProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeProfile.
     */
    data: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
  }

  /**
   * EmployeeProfile createMany
   */
  export type EmployeeProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeProfiles.
     */
    data: EmployeeProfileCreateManyInput | EmployeeProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeProfile createManyAndReturn
   */
  export type EmployeeProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeProfiles.
     */
    data: EmployeeProfileCreateManyInput | EmployeeProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeProfile update
   */
  export type EmployeeProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeProfile.
     */
    data: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
    /**
     * Choose, which EmployeeProfile to update.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile updateMany
   */
  export type EmployeeProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeProfiles.
     */
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeProfiles to update
     */
    where?: EmployeeProfileWhereInput
    /**
     * Limit how many EmployeeProfiles to update.
     */
    limit?: number
  }

  /**
   * EmployeeProfile updateManyAndReturn
   */
  export type EmployeeProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeProfiles.
     */
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeProfiles to update
     */
    where?: EmployeeProfileWhereInput
    /**
     * Limit how many EmployeeProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeProfile upsert
   */
  export type EmployeeProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeProfile to update in case it exists.
     */
    where: EmployeeProfileWhereUniqueInput
    /**
     * In case the EmployeeProfile found by the `where` argument doesn't exist, create a new EmployeeProfile with this data.
     */
    create: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
    /**
     * In case the EmployeeProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
  }

  /**
   * EmployeeProfile delete
   */
  export type EmployeeProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter which EmployeeProfile to delete.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile deleteMany
   */
  export type EmployeeProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfiles to delete
     */
    where?: EmployeeProfileWhereInput
    /**
     * Limit how many EmployeeProfiles to delete.
     */
    limit?: number
  }

  /**
   * EmployeeProfile without action
   */
  export type EmployeeProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeProfile
     */
    omit?: EmployeeProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    contact: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contact" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contact: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    reorderPoint: number | null
  }

  export type ItemSumAggregateOutputType = {
    reorderPoint: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    uom: string | null
    reorderPoint: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    uom: string | null
    reorderPoint: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    category: number
    uom: number
    reorderPoint: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    reorderPoint?: true
  }

  export type ItemSumAggregateInputType = {
    reorderPoint?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    uom?: true
    reorderPoint?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    uom?: true
    reorderPoint?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    uom?: true
    reorderPoint?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    category: string | null
    uom: string
    reorderPoint: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    uom?: boolean
    reorderPoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stocks?: boolean | Item$stocksArgs<ExtArgs>
    ledger?: boolean | Item$ledgerArgs<ExtArgs>
    purchaseLines?: boolean | Item$purchaseLinesArgs<ExtArgs>
    transferLines?: boolean | Item$transferLinesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    uom?: boolean
    reorderPoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    uom?: boolean
    reorderPoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    uom?: boolean
    reorderPoint?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "uom" | "reorderPoint" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | Item$stocksArgs<ExtArgs>
    ledger?: boolean | Item$ledgerArgs<ExtArgs>
    purchaseLines?: boolean | Item$purchaseLinesArgs<ExtArgs>
    transferLines?: boolean | Item$transferLinesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      stocks: Prisma.$KitchenStockPayload<ExtArgs>[]
      ledger: Prisma.$StockLedgerPayload<ExtArgs>[]
      purchaseLines: Prisma.$PurchaseLinePayload<ExtArgs>[]
      transferLines: Prisma.$TransferLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      uom: string
      reorderPoint: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stocks<T extends Item$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Item$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ledger<T extends Item$ledgerArgs<ExtArgs> = {}>(args?: Subset<T, Item$ledgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseLines<T extends Item$purchaseLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$purchaseLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transferLines<T extends Item$transferLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$transferLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly category: FieldRef<"Item", 'String'>
    readonly uom: FieldRef<"Item", 'String'>
    readonly reorderPoint: FieldRef<"Item", 'Float'>
    readonly isActive: FieldRef<"Item", 'Boolean'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.stocks
   */
  export type Item$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    where?: KitchenStockWhereInput
    orderBy?: KitchenStockOrderByWithRelationInput | KitchenStockOrderByWithRelationInput[]
    cursor?: KitchenStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitchenStockScalarFieldEnum | KitchenStockScalarFieldEnum[]
  }

  /**
   * Item.ledger
   */
  export type Item$ledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    cursor?: StockLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * Item.purchaseLines
   */
  export type Item$purchaseLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    where?: PurchaseLineWhereInput
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    cursor?: PurchaseLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * Item.transferLines
   */
  export type Item$transferLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    where?: TransferLineWhereInput
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    cursor?: TransferLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model KitchenStock
   */

  export type AggregateKitchenStock = {
    _count: KitchenStockCountAggregateOutputType | null
    _avg: KitchenStockAvgAggregateOutputType | null
    _sum: KitchenStockSumAggregateOutputType | null
    _min: KitchenStockMinAggregateOutputType | null
    _max: KitchenStockMaxAggregateOutputType | null
  }

  export type KitchenStockAvgAggregateOutputType = {
    onHandQty: number | null
    avgCost: number | null
  }

  export type KitchenStockSumAggregateOutputType = {
    onHandQty: number | null
    avgCost: number | null
  }

  export type KitchenStockMinAggregateOutputType = {
    kitchenId: string | null
    itemId: string | null
    onHandQty: number | null
    avgCost: number | null
    updatedAt: Date | null
  }

  export type KitchenStockMaxAggregateOutputType = {
    kitchenId: string | null
    itemId: string | null
    onHandQty: number | null
    avgCost: number | null
    updatedAt: Date | null
  }

  export type KitchenStockCountAggregateOutputType = {
    kitchenId: number
    itemId: number
    onHandQty: number
    avgCost: number
    updatedAt: number
    _all: number
  }


  export type KitchenStockAvgAggregateInputType = {
    onHandQty?: true
    avgCost?: true
  }

  export type KitchenStockSumAggregateInputType = {
    onHandQty?: true
    avgCost?: true
  }

  export type KitchenStockMinAggregateInputType = {
    kitchenId?: true
    itemId?: true
    onHandQty?: true
    avgCost?: true
    updatedAt?: true
  }

  export type KitchenStockMaxAggregateInputType = {
    kitchenId?: true
    itemId?: true
    onHandQty?: true
    avgCost?: true
    updatedAt?: true
  }

  export type KitchenStockCountAggregateInputType = {
    kitchenId?: true
    itemId?: true
    onHandQty?: true
    avgCost?: true
    updatedAt?: true
    _all?: true
  }

  export type KitchenStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KitchenStock to aggregate.
     */
    where?: KitchenStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenStocks to fetch.
     */
    orderBy?: KitchenStockOrderByWithRelationInput | KitchenStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KitchenStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KitchenStocks
    **/
    _count?: true | KitchenStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KitchenStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KitchenStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KitchenStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KitchenStockMaxAggregateInputType
  }

  export type GetKitchenStockAggregateType<T extends KitchenStockAggregateArgs> = {
        [P in keyof T & keyof AggregateKitchenStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKitchenStock[P]>
      : GetScalarType<T[P], AggregateKitchenStock[P]>
  }




  export type KitchenStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenStockWhereInput
    orderBy?: KitchenStockOrderByWithAggregationInput | KitchenStockOrderByWithAggregationInput[]
    by: KitchenStockScalarFieldEnum[] | KitchenStockScalarFieldEnum
    having?: KitchenStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KitchenStockCountAggregateInputType | true
    _avg?: KitchenStockAvgAggregateInputType
    _sum?: KitchenStockSumAggregateInputType
    _min?: KitchenStockMinAggregateInputType
    _max?: KitchenStockMaxAggregateInputType
  }

  export type KitchenStockGroupByOutputType = {
    kitchenId: string
    itemId: string
    onHandQty: number
    avgCost: number
    updatedAt: Date
    _count: KitchenStockCountAggregateOutputType | null
    _avg: KitchenStockAvgAggregateOutputType | null
    _sum: KitchenStockSumAggregateOutputType | null
    _min: KitchenStockMinAggregateOutputType | null
    _max: KitchenStockMaxAggregateOutputType | null
  }

  type GetKitchenStockGroupByPayload<T extends KitchenStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KitchenStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KitchenStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KitchenStockGroupByOutputType[P]>
            : GetScalarType<T[P], KitchenStockGroupByOutputType[P]>
        }
      >
    >


  export type KitchenStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kitchenId?: boolean
    itemId?: boolean
    onHandQty?: boolean
    avgCost?: boolean
    updatedAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchenStock"]>

  export type KitchenStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kitchenId?: boolean
    itemId?: boolean
    onHandQty?: boolean
    avgCost?: boolean
    updatedAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchenStock"]>

  export type KitchenStockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    kitchenId?: boolean
    itemId?: boolean
    onHandQty?: boolean
    avgCost?: boolean
    updatedAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchenStock"]>

  export type KitchenStockSelectScalar = {
    kitchenId?: boolean
    itemId?: boolean
    onHandQty?: boolean
    avgCost?: boolean
    updatedAt?: boolean
  }

  export type KitchenStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"kitchenId" | "itemId" | "onHandQty" | "avgCost" | "updatedAt", ExtArgs["result"]["kitchenStock"]>
  export type KitchenStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type KitchenStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type KitchenStockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $KitchenStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KitchenStock"
    objects: {
      kitchen: Prisma.$KitchenPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      kitchenId: string
      itemId: string
      onHandQty: number
      avgCost: number
      updatedAt: Date
    }, ExtArgs["result"]["kitchenStock"]>
    composites: {}
  }

  type KitchenStockGetPayload<S extends boolean | null | undefined | KitchenStockDefaultArgs> = $Result.GetResult<Prisma.$KitchenStockPayload, S>

  type KitchenStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KitchenStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KitchenStockCountAggregateInputType | true
    }

  export interface KitchenStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KitchenStock'], meta: { name: 'KitchenStock' } }
    /**
     * Find zero or one KitchenStock that matches the filter.
     * @param {KitchenStockFindUniqueArgs} args - Arguments to find a KitchenStock
     * @example
     * // Get one KitchenStock
     * const kitchenStock = await prisma.kitchenStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KitchenStockFindUniqueArgs>(args: SelectSubset<T, KitchenStockFindUniqueArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KitchenStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KitchenStockFindUniqueOrThrowArgs} args - Arguments to find a KitchenStock
     * @example
     * // Get one KitchenStock
     * const kitchenStock = await prisma.kitchenStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KitchenStockFindUniqueOrThrowArgs>(args: SelectSubset<T, KitchenStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KitchenStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenStockFindFirstArgs} args - Arguments to find a KitchenStock
     * @example
     * // Get one KitchenStock
     * const kitchenStock = await prisma.kitchenStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KitchenStockFindFirstArgs>(args?: SelectSubset<T, KitchenStockFindFirstArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KitchenStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenStockFindFirstOrThrowArgs} args - Arguments to find a KitchenStock
     * @example
     * // Get one KitchenStock
     * const kitchenStock = await prisma.kitchenStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KitchenStockFindFirstOrThrowArgs>(args?: SelectSubset<T, KitchenStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KitchenStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KitchenStocks
     * const kitchenStocks = await prisma.kitchenStock.findMany()
     * 
     * // Get first 10 KitchenStocks
     * const kitchenStocks = await prisma.kitchenStock.findMany({ take: 10 })
     * 
     * // Only select the `kitchenId`
     * const kitchenStockWithKitchenIdOnly = await prisma.kitchenStock.findMany({ select: { kitchenId: true } })
     * 
     */
    findMany<T extends KitchenStockFindManyArgs>(args?: SelectSubset<T, KitchenStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KitchenStock.
     * @param {KitchenStockCreateArgs} args - Arguments to create a KitchenStock.
     * @example
     * // Create one KitchenStock
     * const KitchenStock = await prisma.kitchenStock.create({
     *   data: {
     *     // ... data to create a KitchenStock
     *   }
     * })
     * 
     */
    create<T extends KitchenStockCreateArgs>(args: SelectSubset<T, KitchenStockCreateArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KitchenStocks.
     * @param {KitchenStockCreateManyArgs} args - Arguments to create many KitchenStocks.
     * @example
     * // Create many KitchenStocks
     * const kitchenStock = await prisma.kitchenStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KitchenStockCreateManyArgs>(args?: SelectSubset<T, KitchenStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KitchenStocks and returns the data saved in the database.
     * @param {KitchenStockCreateManyAndReturnArgs} args - Arguments to create many KitchenStocks.
     * @example
     * // Create many KitchenStocks
     * const kitchenStock = await prisma.kitchenStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KitchenStocks and only return the `kitchenId`
     * const kitchenStockWithKitchenIdOnly = await prisma.kitchenStock.createManyAndReturn({
     *   select: { kitchenId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KitchenStockCreateManyAndReturnArgs>(args?: SelectSubset<T, KitchenStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KitchenStock.
     * @param {KitchenStockDeleteArgs} args - Arguments to delete one KitchenStock.
     * @example
     * // Delete one KitchenStock
     * const KitchenStock = await prisma.kitchenStock.delete({
     *   where: {
     *     // ... filter to delete one KitchenStock
     *   }
     * })
     * 
     */
    delete<T extends KitchenStockDeleteArgs>(args: SelectSubset<T, KitchenStockDeleteArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KitchenStock.
     * @param {KitchenStockUpdateArgs} args - Arguments to update one KitchenStock.
     * @example
     * // Update one KitchenStock
     * const kitchenStock = await prisma.kitchenStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KitchenStockUpdateArgs>(args: SelectSubset<T, KitchenStockUpdateArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KitchenStocks.
     * @param {KitchenStockDeleteManyArgs} args - Arguments to filter KitchenStocks to delete.
     * @example
     * // Delete a few KitchenStocks
     * const { count } = await prisma.kitchenStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KitchenStockDeleteManyArgs>(args?: SelectSubset<T, KitchenStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KitchenStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KitchenStocks
     * const kitchenStock = await prisma.kitchenStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KitchenStockUpdateManyArgs>(args: SelectSubset<T, KitchenStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KitchenStocks and returns the data updated in the database.
     * @param {KitchenStockUpdateManyAndReturnArgs} args - Arguments to update many KitchenStocks.
     * @example
     * // Update many KitchenStocks
     * const kitchenStock = await prisma.kitchenStock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KitchenStocks and only return the `kitchenId`
     * const kitchenStockWithKitchenIdOnly = await prisma.kitchenStock.updateManyAndReturn({
     *   select: { kitchenId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KitchenStockUpdateManyAndReturnArgs>(args: SelectSubset<T, KitchenStockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KitchenStock.
     * @param {KitchenStockUpsertArgs} args - Arguments to update or create a KitchenStock.
     * @example
     * // Update or create a KitchenStock
     * const kitchenStock = await prisma.kitchenStock.upsert({
     *   create: {
     *     // ... data to create a KitchenStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KitchenStock we want to update
     *   }
     * })
     */
    upsert<T extends KitchenStockUpsertArgs>(args: SelectSubset<T, KitchenStockUpsertArgs<ExtArgs>>): Prisma__KitchenStockClient<$Result.GetResult<Prisma.$KitchenStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KitchenStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenStockCountArgs} args - Arguments to filter KitchenStocks to count.
     * @example
     * // Count the number of KitchenStocks
     * const count = await prisma.kitchenStock.count({
     *   where: {
     *     // ... the filter for the KitchenStocks we want to count
     *   }
     * })
    **/
    count<T extends KitchenStockCountArgs>(
      args?: Subset<T, KitchenStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitchenStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KitchenStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitchenStockAggregateArgs>(args: Subset<T, KitchenStockAggregateArgs>): Prisma.PrismaPromise<GetKitchenStockAggregateType<T>>

    /**
     * Group by KitchenStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitchenStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitchenStockGroupByArgs['orderBy'] }
        : { orderBy?: KitchenStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitchenStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitchenStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KitchenStock model
   */
  readonly fields: KitchenStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KitchenStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KitchenStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kitchen<T extends KitchenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitchenDefaultArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KitchenStock model
   */
  interface KitchenStockFieldRefs {
    readonly kitchenId: FieldRef<"KitchenStock", 'String'>
    readonly itemId: FieldRef<"KitchenStock", 'String'>
    readonly onHandQty: FieldRef<"KitchenStock", 'Float'>
    readonly avgCost: FieldRef<"KitchenStock", 'Float'>
    readonly updatedAt: FieldRef<"KitchenStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KitchenStock findUnique
   */
  export type KitchenStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * Filter, which KitchenStock to fetch.
     */
    where: KitchenStockWhereUniqueInput
  }

  /**
   * KitchenStock findUniqueOrThrow
   */
  export type KitchenStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * Filter, which KitchenStock to fetch.
     */
    where: KitchenStockWhereUniqueInput
  }

  /**
   * KitchenStock findFirst
   */
  export type KitchenStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * Filter, which KitchenStock to fetch.
     */
    where?: KitchenStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenStocks to fetch.
     */
    orderBy?: KitchenStockOrderByWithRelationInput | KitchenStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KitchenStocks.
     */
    cursor?: KitchenStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KitchenStocks.
     */
    distinct?: KitchenStockScalarFieldEnum | KitchenStockScalarFieldEnum[]
  }

  /**
   * KitchenStock findFirstOrThrow
   */
  export type KitchenStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * Filter, which KitchenStock to fetch.
     */
    where?: KitchenStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenStocks to fetch.
     */
    orderBy?: KitchenStockOrderByWithRelationInput | KitchenStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KitchenStocks.
     */
    cursor?: KitchenStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KitchenStocks.
     */
    distinct?: KitchenStockScalarFieldEnum | KitchenStockScalarFieldEnum[]
  }

  /**
   * KitchenStock findMany
   */
  export type KitchenStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * Filter, which KitchenStocks to fetch.
     */
    where?: KitchenStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenStocks to fetch.
     */
    orderBy?: KitchenStockOrderByWithRelationInput | KitchenStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KitchenStocks.
     */
    cursor?: KitchenStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenStocks.
     */
    skip?: number
    distinct?: KitchenStockScalarFieldEnum | KitchenStockScalarFieldEnum[]
  }

  /**
   * KitchenStock create
   */
  export type KitchenStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * The data needed to create a KitchenStock.
     */
    data: XOR<KitchenStockCreateInput, KitchenStockUncheckedCreateInput>
  }

  /**
   * KitchenStock createMany
   */
  export type KitchenStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KitchenStocks.
     */
    data: KitchenStockCreateManyInput | KitchenStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KitchenStock createManyAndReturn
   */
  export type KitchenStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * The data used to create many KitchenStocks.
     */
    data: KitchenStockCreateManyInput | KitchenStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KitchenStock update
   */
  export type KitchenStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * The data needed to update a KitchenStock.
     */
    data: XOR<KitchenStockUpdateInput, KitchenStockUncheckedUpdateInput>
    /**
     * Choose, which KitchenStock to update.
     */
    where: KitchenStockWhereUniqueInput
  }

  /**
   * KitchenStock updateMany
   */
  export type KitchenStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KitchenStocks.
     */
    data: XOR<KitchenStockUpdateManyMutationInput, KitchenStockUncheckedUpdateManyInput>
    /**
     * Filter which KitchenStocks to update
     */
    where?: KitchenStockWhereInput
    /**
     * Limit how many KitchenStocks to update.
     */
    limit?: number
  }

  /**
   * KitchenStock updateManyAndReturn
   */
  export type KitchenStockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * The data used to update KitchenStocks.
     */
    data: XOR<KitchenStockUpdateManyMutationInput, KitchenStockUncheckedUpdateManyInput>
    /**
     * Filter which KitchenStocks to update
     */
    where?: KitchenStockWhereInput
    /**
     * Limit how many KitchenStocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KitchenStock upsert
   */
  export type KitchenStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * The filter to search for the KitchenStock to update in case it exists.
     */
    where: KitchenStockWhereUniqueInput
    /**
     * In case the KitchenStock found by the `where` argument doesn't exist, create a new KitchenStock with this data.
     */
    create: XOR<KitchenStockCreateInput, KitchenStockUncheckedCreateInput>
    /**
     * In case the KitchenStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KitchenStockUpdateInput, KitchenStockUncheckedUpdateInput>
  }

  /**
   * KitchenStock delete
   */
  export type KitchenStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
    /**
     * Filter which KitchenStock to delete.
     */
    where: KitchenStockWhereUniqueInput
  }

  /**
   * KitchenStock deleteMany
   */
  export type KitchenStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KitchenStocks to delete
     */
    where?: KitchenStockWhereInput
    /**
     * Limit how many KitchenStocks to delete.
     */
    limit?: number
  }

  /**
   * KitchenStock without action
   */
  export type KitchenStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenStock
     */
    select?: KitchenStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenStock
     */
    omit?: KitchenStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenStockInclude<ExtArgs> | null
  }


  /**
   * Model StockLedger
   */

  export type AggregateStockLedger = {
    _count: StockLedgerCountAggregateOutputType | null
    _avg: StockLedgerAvgAggregateOutputType | null
    _sum: StockLedgerSumAggregateOutputType | null
    _min: StockLedgerMinAggregateOutputType | null
    _max: StockLedgerMaxAggregateOutputType | null
  }

  export type StockLedgerAvgAggregateOutputType = {
    qtyDelta: number | null
    unitCost: number | null
  }

  export type StockLedgerSumAggregateOutputType = {
    qtyDelta: number | null
    unitCost: number | null
  }

  export type StockLedgerMinAggregateOutputType = {
    id: string | null
    kitchenId: string | null
    itemId: string | null
    type: $Enums.StockLedgerType | null
    qtyDelta: number | null
    unitCost: number | null
    refType: string | null
    refId: string | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type StockLedgerMaxAggregateOutputType = {
    id: string | null
    kitchenId: string | null
    itemId: string | null
    type: $Enums.StockLedgerType | null
    qtyDelta: number | null
    unitCost: number | null
    refType: string | null
    refId: string | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type StockLedgerCountAggregateOutputType = {
    id: number
    kitchenId: number
    itemId: number
    type: number
    qtyDelta: number
    unitCost: number
    refType: number
    refId: number
    createdByUserId: number
    createdAt: number
    _all: number
  }


  export type StockLedgerAvgAggregateInputType = {
    qtyDelta?: true
    unitCost?: true
  }

  export type StockLedgerSumAggregateInputType = {
    qtyDelta?: true
    unitCost?: true
  }

  export type StockLedgerMinAggregateInputType = {
    id?: true
    kitchenId?: true
    itemId?: true
    type?: true
    qtyDelta?: true
    unitCost?: true
    refType?: true
    refId?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type StockLedgerMaxAggregateInputType = {
    id?: true
    kitchenId?: true
    itemId?: true
    type?: true
    qtyDelta?: true
    unitCost?: true
    refType?: true
    refId?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type StockLedgerCountAggregateInputType = {
    id?: true
    kitchenId?: true
    itemId?: true
    type?: true
    qtyDelta?: true
    unitCost?: true
    refType?: true
    refId?: true
    createdByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type StockLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLedger to aggregate.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockLedgers
    **/
    _count?: true | StockLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockLedgerMaxAggregateInputType
  }

  export type GetStockLedgerAggregateType<T extends StockLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateStockLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockLedger[P]>
      : GetScalarType<T[P], AggregateStockLedger[P]>
  }




  export type StockLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLedgerWhereInput
    orderBy?: StockLedgerOrderByWithAggregationInput | StockLedgerOrderByWithAggregationInput[]
    by: StockLedgerScalarFieldEnum[] | StockLedgerScalarFieldEnum
    having?: StockLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockLedgerCountAggregateInputType | true
    _avg?: StockLedgerAvgAggregateInputType
    _sum?: StockLedgerSumAggregateInputType
    _min?: StockLedgerMinAggregateInputType
    _max?: StockLedgerMaxAggregateInputType
  }

  export type StockLedgerGroupByOutputType = {
    id: string
    kitchenId: string
    itemId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost: number | null
    refType: string | null
    refId: string | null
    createdByUserId: string | null
    createdAt: Date
    _count: StockLedgerCountAggregateOutputType | null
    _avg: StockLedgerAvgAggregateOutputType | null
    _sum: StockLedgerSumAggregateOutputType | null
    _min: StockLedgerMinAggregateOutputType | null
    _max: StockLedgerMaxAggregateOutputType | null
  }

  type GetStockLedgerGroupByPayload<T extends StockLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], StockLedgerGroupByOutputType[P]>
        }
      >
    >


  export type StockLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchenId?: boolean
    itemId?: boolean
    type?: boolean
    qtyDelta?: boolean
    unitCost?: boolean
    refType?: boolean
    refId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    createdBy?: boolean | StockLedger$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["stockLedger"]>

  export type StockLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchenId?: boolean
    itemId?: boolean
    type?: boolean
    qtyDelta?: boolean
    unitCost?: boolean
    refType?: boolean
    refId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    createdBy?: boolean | StockLedger$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["stockLedger"]>

  export type StockLedgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchenId?: boolean
    itemId?: boolean
    type?: boolean
    qtyDelta?: boolean
    unitCost?: boolean
    refType?: boolean
    refId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    createdBy?: boolean | StockLedger$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["stockLedger"]>

  export type StockLedgerSelectScalar = {
    id?: boolean
    kitchenId?: boolean
    itemId?: boolean
    type?: boolean
    qtyDelta?: boolean
    unitCost?: boolean
    refType?: boolean
    refId?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
  }

  export type StockLedgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kitchenId" | "itemId" | "type" | "qtyDelta" | "unitCost" | "refType" | "refId" | "createdByUserId" | "createdAt", ExtArgs["result"]["stockLedger"]>
  export type StockLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    createdBy?: boolean | StockLedger$createdByArgs<ExtArgs>
  }
  export type StockLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    createdBy?: boolean | StockLedger$createdByArgs<ExtArgs>
  }
  export type StockLedgerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    createdBy?: boolean | StockLedger$createdByArgs<ExtArgs>
  }

  export type $StockLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockLedger"
    objects: {
      kitchen: Prisma.$KitchenPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kitchenId: string
      itemId: string
      type: $Enums.StockLedgerType
      qtyDelta: number
      unitCost: number | null
      refType: string | null
      refId: string | null
      createdByUserId: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockLedger"]>
    composites: {}
  }

  type StockLedgerGetPayload<S extends boolean | null | undefined | StockLedgerDefaultArgs> = $Result.GetResult<Prisma.$StockLedgerPayload, S>

  type StockLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockLedgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockLedgerCountAggregateInputType | true
    }

  export interface StockLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockLedger'], meta: { name: 'StockLedger' } }
    /**
     * Find zero or one StockLedger that matches the filter.
     * @param {StockLedgerFindUniqueArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockLedgerFindUniqueArgs>(args: SelectSubset<T, StockLedgerFindUniqueArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockLedger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockLedgerFindUniqueOrThrowArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, StockLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerFindFirstArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockLedgerFindFirstArgs>(args?: SelectSubset<T, StockLedgerFindFirstArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerFindFirstOrThrowArgs} args - Arguments to find a StockLedger
     * @example
     * // Get one StockLedger
     * const stockLedger = await prisma.stockLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, StockLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockLedgers
     * const stockLedgers = await prisma.stockLedger.findMany()
     * 
     * // Get first 10 StockLedgers
     * const stockLedgers = await prisma.stockLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockLedgerWithIdOnly = await prisma.stockLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockLedgerFindManyArgs>(args?: SelectSubset<T, StockLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockLedger.
     * @param {StockLedgerCreateArgs} args - Arguments to create a StockLedger.
     * @example
     * // Create one StockLedger
     * const StockLedger = await prisma.stockLedger.create({
     *   data: {
     *     // ... data to create a StockLedger
     *   }
     * })
     * 
     */
    create<T extends StockLedgerCreateArgs>(args: SelectSubset<T, StockLedgerCreateArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockLedgers.
     * @param {StockLedgerCreateManyArgs} args - Arguments to create many StockLedgers.
     * @example
     * // Create many StockLedgers
     * const stockLedger = await prisma.stockLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockLedgerCreateManyArgs>(args?: SelectSubset<T, StockLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockLedgers and returns the data saved in the database.
     * @param {StockLedgerCreateManyAndReturnArgs} args - Arguments to create many StockLedgers.
     * @example
     * // Create many StockLedgers
     * const stockLedger = await prisma.stockLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockLedgers and only return the `id`
     * const stockLedgerWithIdOnly = await prisma.stockLedger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, StockLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockLedger.
     * @param {StockLedgerDeleteArgs} args - Arguments to delete one StockLedger.
     * @example
     * // Delete one StockLedger
     * const StockLedger = await prisma.stockLedger.delete({
     *   where: {
     *     // ... filter to delete one StockLedger
     *   }
     * })
     * 
     */
    delete<T extends StockLedgerDeleteArgs>(args: SelectSubset<T, StockLedgerDeleteArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockLedger.
     * @param {StockLedgerUpdateArgs} args - Arguments to update one StockLedger.
     * @example
     * // Update one StockLedger
     * const stockLedger = await prisma.stockLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockLedgerUpdateArgs>(args: SelectSubset<T, StockLedgerUpdateArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockLedgers.
     * @param {StockLedgerDeleteManyArgs} args - Arguments to filter StockLedgers to delete.
     * @example
     * // Delete a few StockLedgers
     * const { count } = await prisma.stockLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockLedgerDeleteManyArgs>(args?: SelectSubset<T, StockLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockLedgers
     * const stockLedger = await prisma.stockLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockLedgerUpdateManyArgs>(args: SelectSubset<T, StockLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLedgers and returns the data updated in the database.
     * @param {StockLedgerUpdateManyAndReturnArgs} args - Arguments to update many StockLedgers.
     * @example
     * // Update many StockLedgers
     * const stockLedger = await prisma.stockLedger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockLedgers and only return the `id`
     * const stockLedgerWithIdOnly = await prisma.stockLedger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockLedgerUpdateManyAndReturnArgs>(args: SelectSubset<T, StockLedgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockLedger.
     * @param {StockLedgerUpsertArgs} args - Arguments to update or create a StockLedger.
     * @example
     * // Update or create a StockLedger
     * const stockLedger = await prisma.stockLedger.upsert({
     *   create: {
     *     // ... data to create a StockLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockLedger we want to update
     *   }
     * })
     */
    upsert<T extends StockLedgerUpsertArgs>(args: SelectSubset<T, StockLedgerUpsertArgs<ExtArgs>>): Prisma__StockLedgerClient<$Result.GetResult<Prisma.$StockLedgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerCountArgs} args - Arguments to filter StockLedgers to count.
     * @example
     * // Count the number of StockLedgers
     * const count = await prisma.stockLedger.count({
     *   where: {
     *     // ... the filter for the StockLedgers we want to count
     *   }
     * })
    **/
    count<T extends StockLedgerCountArgs>(
      args?: Subset<T, StockLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockLedgerAggregateArgs>(args: Subset<T, StockLedgerAggregateArgs>): Prisma.PrismaPromise<GetStockLedgerAggregateType<T>>

    /**
     * Group by StockLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockLedgerGroupByArgs['orderBy'] }
        : { orderBy?: StockLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockLedger model
   */
  readonly fields: StockLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kitchen<T extends KitchenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitchenDefaultArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends StockLedger$createdByArgs<ExtArgs> = {}>(args?: Subset<T, StockLedger$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockLedger model
   */
  interface StockLedgerFieldRefs {
    readonly id: FieldRef<"StockLedger", 'String'>
    readonly kitchenId: FieldRef<"StockLedger", 'String'>
    readonly itemId: FieldRef<"StockLedger", 'String'>
    readonly type: FieldRef<"StockLedger", 'StockLedgerType'>
    readonly qtyDelta: FieldRef<"StockLedger", 'Float'>
    readonly unitCost: FieldRef<"StockLedger", 'Float'>
    readonly refType: FieldRef<"StockLedger", 'String'>
    readonly refId: FieldRef<"StockLedger", 'String'>
    readonly createdByUserId: FieldRef<"StockLedger", 'String'>
    readonly createdAt: FieldRef<"StockLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockLedger findUnique
   */
  export type StockLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger findUniqueOrThrow
   */
  export type StockLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger findFirst
   */
  export type StockLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLedgers.
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLedgers.
     */
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * StockLedger findFirstOrThrow
   */
  export type StockLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedger to fetch.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLedgers.
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLedgers.
     */
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * StockLedger findMany
   */
  export type StockLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter, which StockLedgers to fetch.
     */
    where?: StockLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLedgers to fetch.
     */
    orderBy?: StockLedgerOrderByWithRelationInput | StockLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockLedgers.
     */
    cursor?: StockLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLedgers.
     */
    skip?: number
    distinct?: StockLedgerScalarFieldEnum | StockLedgerScalarFieldEnum[]
  }

  /**
   * StockLedger create
   */
  export type StockLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a StockLedger.
     */
    data: XOR<StockLedgerCreateInput, StockLedgerUncheckedCreateInput>
  }

  /**
   * StockLedger createMany
   */
  export type StockLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockLedgers.
     */
    data: StockLedgerCreateManyInput | StockLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockLedger createManyAndReturn
   */
  export type StockLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * The data used to create many StockLedgers.
     */
    data: StockLedgerCreateManyInput | StockLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockLedger update
   */
  export type StockLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a StockLedger.
     */
    data: XOR<StockLedgerUpdateInput, StockLedgerUncheckedUpdateInput>
    /**
     * Choose, which StockLedger to update.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger updateMany
   */
  export type StockLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockLedgers.
     */
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyInput>
    /**
     * Filter which StockLedgers to update
     */
    where?: StockLedgerWhereInput
    /**
     * Limit how many StockLedgers to update.
     */
    limit?: number
  }

  /**
   * StockLedger updateManyAndReturn
   */
  export type StockLedgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * The data used to update StockLedgers.
     */
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyInput>
    /**
     * Filter which StockLedgers to update
     */
    where?: StockLedgerWhereInput
    /**
     * Limit how many StockLedgers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockLedger upsert
   */
  export type StockLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the StockLedger to update in case it exists.
     */
    where: StockLedgerWhereUniqueInput
    /**
     * In case the StockLedger found by the `where` argument doesn't exist, create a new StockLedger with this data.
     */
    create: XOR<StockLedgerCreateInput, StockLedgerUncheckedCreateInput>
    /**
     * In case the StockLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockLedgerUpdateInput, StockLedgerUncheckedUpdateInput>
  }

  /**
   * StockLedger delete
   */
  export type StockLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
    /**
     * Filter which StockLedger to delete.
     */
    where: StockLedgerWhereUniqueInput
  }

  /**
   * StockLedger deleteMany
   */
  export type StockLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLedgers to delete
     */
    where?: StockLedgerWhereInput
    /**
     * Limit how many StockLedgers to delete.
     */
    limit?: number
  }

  /**
   * StockLedger.createdBy
   */
  export type StockLedger$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockLedger without action
   */
  export type StockLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLedger
     */
    select?: StockLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLedger
     */
    omit?: StockLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLedgerInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    kitchenId: string | null
    supplierId: string | null
    status: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    kitchenId: string | null
    supplierId: string | null
    status: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    kitchenId: number
    supplierId: number
    status: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    kitchenId?: true
    supplierId?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    kitchenId?: true
    supplierId?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    kitchenId?: true
    supplierId?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    kitchenId: string
    supplierId: string | null
    status: string
    createdByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchenId?: boolean
    supplierId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchenId?: boolean
    supplierId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchenId?: boolean
    supplierId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    kitchenId?: boolean
    supplierId?: boolean
    status?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kitchenId" | "supplierId" | "status" | "createdByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    supplier?: boolean | PurchaseOrder$supplierArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      kitchen: Prisma.$KitchenPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      lines: Prisma.$PurchaseLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kitchenId: string
      supplierId: string | null
      status: string
      createdByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kitchen<T extends KitchenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitchenDefaultArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends PurchaseOrder$supplierArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends PurchaseOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly kitchenId: FieldRef<"PurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'String'>
    readonly status: FieldRef<"PurchaseOrder", 'String'>
    readonly createdByUserId: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.supplier
   */
  export type PurchaseOrder$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * PurchaseOrder.lines
   */
  export type PurchaseOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    where?: PurchaseLineWhereInput
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    cursor?: PurchaseLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseLine
   */

  export type AggregatePurchaseLine = {
    _count: PurchaseLineCountAggregateOutputType | null
    _avg: PurchaseLineAvgAggregateOutputType | null
    _sum: PurchaseLineSumAggregateOutputType | null
    _min: PurchaseLineMinAggregateOutputType | null
    _max: PurchaseLineMaxAggregateOutputType | null
  }

  export type PurchaseLineAvgAggregateOutputType = {
    qty: number | null
    unitCost: number | null
  }

  export type PurchaseLineSumAggregateOutputType = {
    qty: number | null
    unitCost: number | null
  }

  export type PurchaseLineMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    itemId: string | null
    qty: number | null
    unitCost: number | null
  }

  export type PurchaseLineMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    itemId: string | null
    qty: number | null
    unitCost: number | null
  }

  export type PurchaseLineCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    itemId: number
    qty: number
    unitCost: number
    _all: number
  }


  export type PurchaseLineAvgAggregateInputType = {
    qty?: true
    unitCost?: true
  }

  export type PurchaseLineSumAggregateInputType = {
    qty?: true
    unitCost?: true
  }

  export type PurchaseLineMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    itemId?: true
    qty?: true
    unitCost?: true
  }

  export type PurchaseLineMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    itemId?: true
    qty?: true
    unitCost?: true
  }

  export type PurchaseLineCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    itemId?: true
    qty?: true
    unitCost?: true
    _all?: true
  }

  export type PurchaseLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseLine to aggregate.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseLines
    **/
    _count?: true | PurchaseLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseLineMaxAggregateInputType
  }

  export type GetPurchaseLineAggregateType<T extends PurchaseLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseLine[P]>
      : GetScalarType<T[P], AggregatePurchaseLine[P]>
  }




  export type PurchaseLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLineWhereInput
    orderBy?: PurchaseLineOrderByWithAggregationInput | PurchaseLineOrderByWithAggregationInput[]
    by: PurchaseLineScalarFieldEnum[] | PurchaseLineScalarFieldEnum
    having?: PurchaseLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseLineCountAggregateInputType | true
    _avg?: PurchaseLineAvgAggregateInputType
    _sum?: PurchaseLineSumAggregateInputType
    _min?: PurchaseLineMinAggregateInputType
    _max?: PurchaseLineMaxAggregateInputType
  }

  export type PurchaseLineGroupByOutputType = {
    id: string
    purchaseOrderId: string
    itemId: string
    qty: number
    unitCost: number
    _count: PurchaseLineCountAggregateOutputType | null
    _avg: PurchaseLineAvgAggregateOutputType | null
    _sum: PurchaseLineSumAggregateOutputType | null
    _min: PurchaseLineMinAggregateOutputType | null
    _max: PurchaseLineMaxAggregateOutputType | null
  }

  type GetPurchaseLineGroupByPayload<T extends PurchaseLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseLineGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseLineGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitCost?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLine"]>

  export type PurchaseLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitCost?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLine"]>

  export type PurchaseLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitCost?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLine"]>

  export type PurchaseLineSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitCost?: boolean
  }

  export type PurchaseLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseOrderId" | "itemId" | "qty" | "unitCost", ExtArgs["result"]["purchaseLine"]>
  export type PurchaseLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PurchaseLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PurchaseLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $PurchaseLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseLine"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      itemId: string
      qty: number
      unitCost: number
    }, ExtArgs["result"]["purchaseLine"]>
    composites: {}
  }

  type PurchaseLineGetPayload<S extends boolean | null | undefined | PurchaseLineDefaultArgs> = $Result.GetResult<Prisma.$PurchaseLinePayload, S>

  type PurchaseLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseLineCountAggregateInputType | true
    }

  export interface PurchaseLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseLine'], meta: { name: 'PurchaseLine' } }
    /**
     * Find zero or one PurchaseLine that matches the filter.
     * @param {PurchaseLineFindUniqueArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseLineFindUniqueArgs>(args: SelectSubset<T, PurchaseLineFindUniqueArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseLineFindUniqueOrThrowArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineFindFirstArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseLineFindFirstArgs>(args?: SelectSubset<T, PurchaseLineFindFirstArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineFindFirstOrThrowArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseLines
     * const purchaseLines = await prisma.purchaseLine.findMany()
     * 
     * // Get first 10 PurchaseLines
     * const purchaseLines = await prisma.purchaseLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseLineWithIdOnly = await prisma.purchaseLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseLineFindManyArgs>(args?: SelectSubset<T, PurchaseLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseLine.
     * @param {PurchaseLineCreateArgs} args - Arguments to create a PurchaseLine.
     * @example
     * // Create one PurchaseLine
     * const PurchaseLine = await prisma.purchaseLine.create({
     *   data: {
     *     // ... data to create a PurchaseLine
     *   }
     * })
     * 
     */
    create<T extends PurchaseLineCreateArgs>(args: SelectSubset<T, PurchaseLineCreateArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseLines.
     * @param {PurchaseLineCreateManyArgs} args - Arguments to create many PurchaseLines.
     * @example
     * // Create many PurchaseLines
     * const purchaseLine = await prisma.purchaseLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseLineCreateManyArgs>(args?: SelectSubset<T, PurchaseLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseLines and returns the data saved in the database.
     * @param {PurchaseLineCreateManyAndReturnArgs} args - Arguments to create many PurchaseLines.
     * @example
     * // Create many PurchaseLines
     * const purchaseLine = await prisma.purchaseLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseLines and only return the `id`
     * const purchaseLineWithIdOnly = await prisma.purchaseLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseLine.
     * @param {PurchaseLineDeleteArgs} args - Arguments to delete one PurchaseLine.
     * @example
     * // Delete one PurchaseLine
     * const PurchaseLine = await prisma.purchaseLine.delete({
     *   where: {
     *     // ... filter to delete one PurchaseLine
     *   }
     * })
     * 
     */
    delete<T extends PurchaseLineDeleteArgs>(args: SelectSubset<T, PurchaseLineDeleteArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseLine.
     * @param {PurchaseLineUpdateArgs} args - Arguments to update one PurchaseLine.
     * @example
     * // Update one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseLineUpdateArgs>(args: SelectSubset<T, PurchaseLineUpdateArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseLines.
     * @param {PurchaseLineDeleteManyArgs} args - Arguments to filter PurchaseLines to delete.
     * @example
     * // Delete a few PurchaseLines
     * const { count } = await prisma.purchaseLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseLineDeleteManyArgs>(args?: SelectSubset<T, PurchaseLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseLines
     * const purchaseLine = await prisma.purchaseLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseLineUpdateManyArgs>(args: SelectSubset<T, PurchaseLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseLines and returns the data updated in the database.
     * @param {PurchaseLineUpdateManyAndReturnArgs} args - Arguments to update many PurchaseLines.
     * @example
     * // Update many PurchaseLines
     * const purchaseLine = await prisma.purchaseLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseLines and only return the `id`
     * const purchaseLineWithIdOnly = await prisma.purchaseLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseLineUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseLine.
     * @param {PurchaseLineUpsertArgs} args - Arguments to update or create a PurchaseLine.
     * @example
     * // Update or create a PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.upsert({
     *   create: {
     *     // ... data to create a PurchaseLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseLine we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseLineUpsertArgs>(args: SelectSubset<T, PurchaseLineUpsertArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineCountArgs} args - Arguments to filter PurchaseLines to count.
     * @example
     * // Count the number of PurchaseLines
     * const count = await prisma.purchaseLine.count({
     *   where: {
     *     // ... the filter for the PurchaseLines we want to count
     *   }
     * })
    **/
    count<T extends PurchaseLineCountArgs>(
      args?: Subset<T, PurchaseLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseLineAggregateArgs>(args: Subset<T, PurchaseLineAggregateArgs>): Prisma.PrismaPromise<GetPurchaseLineAggregateType<T>>

    /**
     * Group by PurchaseLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseLineGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseLine model
   */
  readonly fields: PurchaseLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseLine model
   */
  interface PurchaseLineFieldRefs {
    readonly id: FieldRef<"PurchaseLine", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseLine", 'String'>
    readonly itemId: FieldRef<"PurchaseLine", 'String'>
    readonly qty: FieldRef<"PurchaseLine", 'Float'>
    readonly unitCost: FieldRef<"PurchaseLine", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseLine findUnique
   */
  export type PurchaseLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine findUniqueOrThrow
   */
  export type PurchaseLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine findFirst
   */
  export type PurchaseLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseLines.
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseLines.
     */
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * PurchaseLine findFirstOrThrow
   */
  export type PurchaseLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseLines.
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseLines.
     */
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * PurchaseLine findMany
   */
  export type PurchaseLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLines to fetch.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseLines.
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * PurchaseLine create
   */
  export type PurchaseLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseLine.
     */
    data: XOR<PurchaseLineCreateInput, PurchaseLineUncheckedCreateInput>
  }

  /**
   * PurchaseLine createMany
   */
  export type PurchaseLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseLines.
     */
    data: PurchaseLineCreateManyInput | PurchaseLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseLine createManyAndReturn
   */
  export type PurchaseLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseLines.
     */
    data: PurchaseLineCreateManyInput | PurchaseLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseLine update
   */
  export type PurchaseLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseLine.
     */
    data: XOR<PurchaseLineUpdateInput, PurchaseLineUncheckedUpdateInput>
    /**
     * Choose, which PurchaseLine to update.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine updateMany
   */
  export type PurchaseLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseLines.
     */
    data: XOR<PurchaseLineUpdateManyMutationInput, PurchaseLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseLines to update
     */
    where?: PurchaseLineWhereInput
    /**
     * Limit how many PurchaseLines to update.
     */
    limit?: number
  }

  /**
   * PurchaseLine updateManyAndReturn
   */
  export type PurchaseLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseLines.
     */
    data: XOR<PurchaseLineUpdateManyMutationInput, PurchaseLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseLines to update
     */
    where?: PurchaseLineWhereInput
    /**
     * Limit how many PurchaseLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseLine upsert
   */
  export type PurchaseLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseLine to update in case it exists.
     */
    where: PurchaseLineWhereUniqueInput
    /**
     * In case the PurchaseLine found by the `where` argument doesn't exist, create a new PurchaseLine with this data.
     */
    create: XOR<PurchaseLineCreateInput, PurchaseLineUncheckedCreateInput>
    /**
     * In case the PurchaseLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseLineUpdateInput, PurchaseLineUncheckedUpdateInput>
  }

  /**
   * PurchaseLine delete
   */
  export type PurchaseLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter which PurchaseLine to delete.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine deleteMany
   */
  export type PurchaseLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseLines to delete
     */
    where?: PurchaseLineWhereInput
    /**
     * Limit how many PurchaseLines to delete.
     */
    limit?: number
  }

  /**
   * PurchaseLine without action
   */
  export type PurchaseLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseLine
     */
    omit?: PurchaseLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    fromKitchenId: string | null
    toKitchenId: string | null
    status: $Enums.TransferStatus | null
    requestedByUserId: string | null
    approvedByUserId: string | null
    dispatchedByUserId: string | null
    receivedByUserId: string | null
    requestedAt: Date | null
    approvedAt: Date | null
    dispatchedAt: Date | null
    receivedAt: Date | null
    cancelledAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    fromKitchenId: string | null
    toKitchenId: string | null
    status: $Enums.TransferStatus | null
    requestedByUserId: string | null
    approvedByUserId: string | null
    dispatchedByUserId: string | null
    receivedByUserId: string | null
    requestedAt: Date | null
    approvedAt: Date | null
    dispatchedAt: Date | null
    receivedAt: Date | null
    cancelledAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    fromKitchenId: number
    toKitchenId: number
    status: number
    requestedByUserId: number
    approvedByUserId: number
    dispatchedByUserId: number
    receivedByUserId: number
    requestedAt: number
    approvedAt: number
    dispatchedAt: number
    receivedAt: number
    cancelledAt: number
    _all: number
  }


  export type TransferMinAggregateInputType = {
    id?: true
    fromKitchenId?: true
    toKitchenId?: true
    status?: true
    requestedByUserId?: true
    approvedByUserId?: true
    dispatchedByUserId?: true
    receivedByUserId?: true
    requestedAt?: true
    approvedAt?: true
    dispatchedAt?: true
    receivedAt?: true
    cancelledAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    fromKitchenId?: true
    toKitchenId?: true
    status?: true
    requestedByUserId?: true
    approvedByUserId?: true
    dispatchedByUserId?: true
    receivedByUserId?: true
    requestedAt?: true
    approvedAt?: true
    dispatchedAt?: true
    receivedAt?: true
    cancelledAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    fromKitchenId?: true
    toKitchenId?: true
    status?: true
    requestedByUserId?: true
    approvedByUserId?: true
    dispatchedByUserId?: true
    receivedByUserId?: true
    requestedAt?: true
    approvedAt?: true
    dispatchedAt?: true
    receivedAt?: true
    cancelledAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    fromKitchenId: string
    toKitchenId: string
    status: $Enums.TransferStatus
    requestedByUserId: string | null
    approvedByUserId: string | null
    dispatchedByUserId: string | null
    receivedByUserId: string | null
    requestedAt: Date
    approvedAt: Date | null
    dispatchedAt: Date | null
    receivedAt: Date | null
    cancelledAt: Date | null
    _count: TransferCountAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromKitchenId?: boolean
    toKitchenId?: boolean
    status?: boolean
    requestedByUserId?: boolean
    approvedByUserId?: boolean
    dispatchedByUserId?: boolean
    receivedByUserId?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    dispatchedAt?: boolean
    receivedAt?: boolean
    cancelledAt?: boolean
    fromKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    toKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    lines?: boolean | Transfer$linesArgs<ExtArgs>
    requestedBy?: boolean | Transfer$requestedByArgs<ExtArgs>
    approvedBy?: boolean | Transfer$approvedByArgs<ExtArgs>
    dispatchedBy?: boolean | Transfer$dispatchedByArgs<ExtArgs>
    receivedBy?: boolean | Transfer$receivedByArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromKitchenId?: boolean
    toKitchenId?: boolean
    status?: boolean
    requestedByUserId?: boolean
    approvedByUserId?: boolean
    dispatchedByUserId?: boolean
    receivedByUserId?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    dispatchedAt?: boolean
    receivedAt?: boolean
    cancelledAt?: boolean
    fromKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    toKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    requestedBy?: boolean | Transfer$requestedByArgs<ExtArgs>
    approvedBy?: boolean | Transfer$approvedByArgs<ExtArgs>
    dispatchedBy?: boolean | Transfer$dispatchedByArgs<ExtArgs>
    receivedBy?: boolean | Transfer$receivedByArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromKitchenId?: boolean
    toKitchenId?: boolean
    status?: boolean
    requestedByUserId?: boolean
    approvedByUserId?: boolean
    dispatchedByUserId?: boolean
    receivedByUserId?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    dispatchedAt?: boolean
    receivedAt?: boolean
    cancelledAt?: boolean
    fromKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    toKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    requestedBy?: boolean | Transfer$requestedByArgs<ExtArgs>
    approvedBy?: boolean | Transfer$approvedByArgs<ExtArgs>
    dispatchedBy?: boolean | Transfer$dispatchedByArgs<ExtArgs>
    receivedBy?: boolean | Transfer$receivedByArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    fromKitchenId?: boolean
    toKitchenId?: boolean
    status?: boolean
    requestedByUserId?: boolean
    approvedByUserId?: boolean
    dispatchedByUserId?: boolean
    receivedByUserId?: boolean
    requestedAt?: boolean
    approvedAt?: boolean
    dispatchedAt?: boolean
    receivedAt?: boolean
    cancelledAt?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromKitchenId" | "toKitchenId" | "status" | "requestedByUserId" | "approvedByUserId" | "dispatchedByUserId" | "receivedByUserId" | "requestedAt" | "approvedAt" | "dispatchedAt" | "receivedAt" | "cancelledAt", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    toKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    lines?: boolean | Transfer$linesArgs<ExtArgs>
    requestedBy?: boolean | Transfer$requestedByArgs<ExtArgs>
    approvedBy?: boolean | Transfer$approvedByArgs<ExtArgs>
    dispatchedBy?: boolean | Transfer$dispatchedByArgs<ExtArgs>
    receivedBy?: boolean | Transfer$receivedByArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    toKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    requestedBy?: boolean | Transfer$requestedByArgs<ExtArgs>
    approvedBy?: boolean | Transfer$approvedByArgs<ExtArgs>
    dispatchedBy?: boolean | Transfer$dispatchedByArgs<ExtArgs>
    receivedBy?: boolean | Transfer$receivedByArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    toKitchen?: boolean | KitchenDefaultArgs<ExtArgs>
    requestedBy?: boolean | Transfer$requestedByArgs<ExtArgs>
    approvedBy?: boolean | Transfer$approvedByArgs<ExtArgs>
    dispatchedBy?: boolean | Transfer$dispatchedByArgs<ExtArgs>
    receivedBy?: boolean | Transfer$receivedByArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      fromKitchen: Prisma.$KitchenPayload<ExtArgs>
      toKitchen: Prisma.$KitchenPayload<ExtArgs>
      lines: Prisma.$TransferLinePayload<ExtArgs>[]
      requestedBy: Prisma.$UserPayload<ExtArgs> | null
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      dispatchedBy: Prisma.$UserPayload<ExtArgs> | null
      receivedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromKitchenId: string
      toKitchenId: string
      status: $Enums.TransferStatus
      requestedByUserId: string | null
      approvedByUserId: string | null
      dispatchedByUserId: string | null
      receivedByUserId: string | null
      requestedAt: Date
      approvedAt: Date | null
      dispatchedAt: Date | null
      receivedAt: Date | null
      cancelledAt: Date | null
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromKitchen<T extends KitchenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitchenDefaultArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toKitchen<T extends KitchenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitchenDefaultArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends Transfer$linesArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requestedBy<T extends Transfer$requestedByArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$requestedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Transfer$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dispatchedBy<T extends Transfer$dispatchedByArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$dispatchedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receivedBy<T extends Transfer$receivedByArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$receivedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly fromKitchenId: FieldRef<"Transfer", 'String'>
    readonly toKitchenId: FieldRef<"Transfer", 'String'>
    readonly status: FieldRef<"Transfer", 'TransferStatus'>
    readonly requestedByUserId: FieldRef<"Transfer", 'String'>
    readonly approvedByUserId: FieldRef<"Transfer", 'String'>
    readonly dispatchedByUserId: FieldRef<"Transfer", 'String'>
    readonly receivedByUserId: FieldRef<"Transfer", 'String'>
    readonly requestedAt: FieldRef<"Transfer", 'DateTime'>
    readonly approvedAt: FieldRef<"Transfer", 'DateTime'>
    readonly dispatchedAt: FieldRef<"Transfer", 'DateTime'>
    readonly receivedAt: FieldRef<"Transfer", 'DateTime'>
    readonly cancelledAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer.lines
   */
  export type Transfer$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    where?: TransferLineWhereInput
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    cursor?: TransferLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * Transfer.requestedBy
   */
  export type Transfer$requestedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.approvedBy
   */
  export type Transfer$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.dispatchedBy
   */
  export type Transfer$dispatchedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.receivedBy
   */
  export type Transfer$receivedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model TransferLine
   */

  export type AggregateTransferLine = {
    _count: TransferLineCountAggregateOutputType | null
    _avg: TransferLineAvgAggregateOutputType | null
    _sum: TransferLineSumAggregateOutputType | null
    _min: TransferLineMinAggregateOutputType | null
    _max: TransferLineMaxAggregateOutputType | null
  }

  export type TransferLineAvgAggregateOutputType = {
    qty: number | null
  }

  export type TransferLineSumAggregateOutputType = {
    qty: number | null
  }

  export type TransferLineMinAggregateOutputType = {
    id: string | null
    transferId: string | null
    itemId: string | null
    qty: number | null
  }

  export type TransferLineMaxAggregateOutputType = {
    id: string | null
    transferId: string | null
    itemId: string | null
    qty: number | null
  }

  export type TransferLineCountAggregateOutputType = {
    id: number
    transferId: number
    itemId: number
    qty: number
    _all: number
  }


  export type TransferLineAvgAggregateInputType = {
    qty?: true
  }

  export type TransferLineSumAggregateInputType = {
    qty?: true
  }

  export type TransferLineMinAggregateInputType = {
    id?: true
    transferId?: true
    itemId?: true
    qty?: true
  }

  export type TransferLineMaxAggregateInputType = {
    id?: true
    transferId?: true
    itemId?: true
    qty?: true
  }

  export type TransferLineCountAggregateInputType = {
    id?: true
    transferId?: true
    itemId?: true
    qty?: true
    _all?: true
  }

  export type TransferLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferLine to aggregate.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferLines
    **/
    _count?: true | TransferLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferLineMaxAggregateInputType
  }

  export type GetTransferLineAggregateType<T extends TransferLineAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferLine[P]>
      : GetScalarType<T[P], AggregateTransferLine[P]>
  }




  export type TransferLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferLineWhereInput
    orderBy?: TransferLineOrderByWithAggregationInput | TransferLineOrderByWithAggregationInput[]
    by: TransferLineScalarFieldEnum[] | TransferLineScalarFieldEnum
    having?: TransferLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferLineCountAggregateInputType | true
    _avg?: TransferLineAvgAggregateInputType
    _sum?: TransferLineSumAggregateInputType
    _min?: TransferLineMinAggregateInputType
    _max?: TransferLineMaxAggregateInputType
  }

  export type TransferLineGroupByOutputType = {
    id: string
    transferId: string
    itemId: string
    qty: number
    _count: TransferLineCountAggregateOutputType | null
    _avg: TransferLineAvgAggregateOutputType | null
    _sum: TransferLineSumAggregateOutputType | null
    _min: TransferLineMinAggregateOutputType | null
    _max: TransferLineMaxAggregateOutputType | null
  }

  type GetTransferLineGroupByPayload<T extends TransferLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferLineGroupByOutputType[P]>
            : GetScalarType<T[P], TransferLineGroupByOutputType[P]>
        }
      >
    >


  export type TransferLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    itemId?: boolean
    qty?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferLine"]>

  export type TransferLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    itemId?: boolean
    qty?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferLine"]>

  export type TransferLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    itemId?: boolean
    qty?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferLine"]>

  export type TransferLineSelectScalar = {
    id?: boolean
    transferId?: boolean
    itemId?: boolean
    qty?: boolean
  }

  export type TransferLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferId" | "itemId" | "qty", ExtArgs["result"]["transferLine"]>
  export type TransferLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type TransferLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type TransferLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $TransferLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferLine"
    objects: {
      transfer: Prisma.$TransferPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferId: string
      itemId: string
      qty: number
    }, ExtArgs["result"]["transferLine"]>
    composites: {}
  }

  type TransferLineGetPayload<S extends boolean | null | undefined | TransferLineDefaultArgs> = $Result.GetResult<Prisma.$TransferLinePayload, S>

  type TransferLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferLineCountAggregateInputType | true
    }

  export interface TransferLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferLine'], meta: { name: 'TransferLine' } }
    /**
     * Find zero or one TransferLine that matches the filter.
     * @param {TransferLineFindUniqueArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferLineFindUniqueArgs>(args: SelectSubset<T, TransferLineFindUniqueArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransferLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferLineFindUniqueOrThrowArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferLineFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineFindFirstArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferLineFindFirstArgs>(args?: SelectSubset<T, TransferLineFindFirstArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineFindFirstOrThrowArgs} args - Arguments to find a TransferLine
     * @example
     * // Get one TransferLine
     * const transferLine = await prisma.transferLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferLineFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransferLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferLines
     * const transferLines = await prisma.transferLine.findMany()
     * 
     * // Get first 10 TransferLines
     * const transferLines = await prisma.transferLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferLineWithIdOnly = await prisma.transferLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferLineFindManyArgs>(args?: SelectSubset<T, TransferLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransferLine.
     * @param {TransferLineCreateArgs} args - Arguments to create a TransferLine.
     * @example
     * // Create one TransferLine
     * const TransferLine = await prisma.transferLine.create({
     *   data: {
     *     // ... data to create a TransferLine
     *   }
     * })
     * 
     */
    create<T extends TransferLineCreateArgs>(args: SelectSubset<T, TransferLineCreateArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransferLines.
     * @param {TransferLineCreateManyArgs} args - Arguments to create many TransferLines.
     * @example
     * // Create many TransferLines
     * const transferLine = await prisma.transferLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferLineCreateManyArgs>(args?: SelectSubset<T, TransferLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferLines and returns the data saved in the database.
     * @param {TransferLineCreateManyAndReturnArgs} args - Arguments to create many TransferLines.
     * @example
     * // Create many TransferLines
     * const transferLine = await prisma.transferLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferLines and only return the `id`
     * const transferLineWithIdOnly = await prisma.transferLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferLineCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransferLine.
     * @param {TransferLineDeleteArgs} args - Arguments to delete one TransferLine.
     * @example
     * // Delete one TransferLine
     * const TransferLine = await prisma.transferLine.delete({
     *   where: {
     *     // ... filter to delete one TransferLine
     *   }
     * })
     * 
     */
    delete<T extends TransferLineDeleteArgs>(args: SelectSubset<T, TransferLineDeleteArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransferLine.
     * @param {TransferLineUpdateArgs} args - Arguments to update one TransferLine.
     * @example
     * // Update one TransferLine
     * const transferLine = await prisma.transferLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferLineUpdateArgs>(args: SelectSubset<T, TransferLineUpdateArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransferLines.
     * @param {TransferLineDeleteManyArgs} args - Arguments to filter TransferLines to delete.
     * @example
     * // Delete a few TransferLines
     * const { count } = await prisma.transferLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferLineDeleteManyArgs>(args?: SelectSubset<T, TransferLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferLines
     * const transferLine = await prisma.transferLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferLineUpdateManyArgs>(args: SelectSubset<T, TransferLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferLines and returns the data updated in the database.
     * @param {TransferLineUpdateManyAndReturnArgs} args - Arguments to update many TransferLines.
     * @example
     * // Update many TransferLines
     * const transferLine = await prisma.transferLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransferLines and only return the `id`
     * const transferLineWithIdOnly = await prisma.transferLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferLineUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransferLine.
     * @param {TransferLineUpsertArgs} args - Arguments to update or create a TransferLine.
     * @example
     * // Update or create a TransferLine
     * const transferLine = await prisma.transferLine.upsert({
     *   create: {
     *     // ... data to create a TransferLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferLine we want to update
     *   }
     * })
     */
    upsert<T extends TransferLineUpsertArgs>(args: SelectSubset<T, TransferLineUpsertArgs<ExtArgs>>): Prisma__TransferLineClient<$Result.GetResult<Prisma.$TransferLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransferLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineCountArgs} args - Arguments to filter TransferLines to count.
     * @example
     * // Count the number of TransferLines
     * const count = await prisma.transferLine.count({
     *   where: {
     *     // ... the filter for the TransferLines we want to count
     *   }
     * })
    **/
    count<T extends TransferLineCountArgs>(
      args?: Subset<T, TransferLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferLineAggregateArgs>(args: Subset<T, TransferLineAggregateArgs>): Prisma.PrismaPromise<GetTransferLineAggregateType<T>>

    /**
     * Group by TransferLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferLineGroupByArgs['orderBy'] }
        : { orderBy?: TransferLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferLine model
   */
  readonly fields: TransferLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transfer<T extends TransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferDefaultArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferLine model
   */
  interface TransferLineFieldRefs {
    readonly id: FieldRef<"TransferLine", 'String'>
    readonly transferId: FieldRef<"TransferLine", 'String'>
    readonly itemId: FieldRef<"TransferLine", 'String'>
    readonly qty: FieldRef<"TransferLine", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TransferLine findUnique
   */
  export type TransferLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine findUniqueOrThrow
   */
  export type TransferLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine findFirst
   */
  export type TransferLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferLines.
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferLines.
     */
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * TransferLine findFirstOrThrow
   */
  export type TransferLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLine to fetch.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferLines.
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferLines.
     */
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * TransferLine findMany
   */
  export type TransferLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter, which TransferLines to fetch.
     */
    where?: TransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferLines to fetch.
     */
    orderBy?: TransferLineOrderByWithRelationInput | TransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferLines.
     */
    cursor?: TransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferLines.
     */
    skip?: number
    distinct?: TransferLineScalarFieldEnum | TransferLineScalarFieldEnum[]
  }

  /**
   * TransferLine create
   */
  export type TransferLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferLine.
     */
    data: XOR<TransferLineCreateInput, TransferLineUncheckedCreateInput>
  }

  /**
   * TransferLine createMany
   */
  export type TransferLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferLines.
     */
    data: TransferLineCreateManyInput | TransferLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferLine createManyAndReturn
   */
  export type TransferLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * The data used to create many TransferLines.
     */
    data: TransferLineCreateManyInput | TransferLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferLine update
   */
  export type TransferLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferLine.
     */
    data: XOR<TransferLineUpdateInput, TransferLineUncheckedUpdateInput>
    /**
     * Choose, which TransferLine to update.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine updateMany
   */
  export type TransferLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferLines.
     */
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyInput>
    /**
     * Filter which TransferLines to update
     */
    where?: TransferLineWhereInput
    /**
     * Limit how many TransferLines to update.
     */
    limit?: number
  }

  /**
   * TransferLine updateManyAndReturn
   */
  export type TransferLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * The data used to update TransferLines.
     */
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyInput>
    /**
     * Filter which TransferLines to update
     */
    where?: TransferLineWhereInput
    /**
     * Limit how many TransferLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferLine upsert
   */
  export type TransferLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferLine to update in case it exists.
     */
    where: TransferLineWhereUniqueInput
    /**
     * In case the TransferLine found by the `where` argument doesn't exist, create a new TransferLine with this data.
     */
    create: XOR<TransferLineCreateInput, TransferLineUncheckedCreateInput>
    /**
     * In case the TransferLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferLineUpdateInput, TransferLineUncheckedUpdateInput>
  }

  /**
   * TransferLine delete
   */
  export type TransferLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
    /**
     * Filter which TransferLine to delete.
     */
    where: TransferLineWhereUniqueInput
  }

  /**
   * TransferLine deleteMany
   */
  export type TransferLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferLines to delete
     */
    where?: TransferLineWhereInput
    /**
     * Limit how many TransferLines to delete.
     */
    limit?: number
  }

  /**
   * TransferLine without action
   */
  export type TransferLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferLine
     */
    select?: TransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferLine
     */
    omit?: TransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferLineInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceEvent
   */

  export type AggregateAttendanceEvent = {
    _count: AttendanceEventCountAggregateOutputType | null
    _avg: AttendanceEventAvgAggregateOutputType | null
    _sum: AttendanceEventSumAggregateOutputType | null
    _min: AttendanceEventMinAggregateOutputType | null
    _max: AttendanceEventMaxAggregateOutputType | null
  }

  export type AttendanceEventAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
    distanceMeters: number | null
  }

  export type AttendanceEventSumAggregateOutputType = {
    lat: number | null
    lng: number | null
    distanceMeters: number | null
  }

  export type AttendanceEventMinAggregateOutputType = {
    id: string | null
    employeeUserId: string | null
    kitchenId: string | null
    type: $Enums.AttendanceType | null
    method: $Enums.AttendanceMethod | null
    lat: number | null
    lng: number | null
    distanceMeters: number | null
    createdAt: Date | null
  }

  export type AttendanceEventMaxAggregateOutputType = {
    id: string | null
    employeeUserId: string | null
    kitchenId: string | null
    type: $Enums.AttendanceType | null
    method: $Enums.AttendanceMethod | null
    lat: number | null
    lng: number | null
    distanceMeters: number | null
    createdAt: Date | null
  }

  export type AttendanceEventCountAggregateOutputType = {
    id: number
    employeeUserId: number
    kitchenId: number
    type: number
    method: number
    lat: number
    lng: number
    distanceMeters: number
    createdAt: number
    _all: number
  }


  export type AttendanceEventAvgAggregateInputType = {
    lat?: true
    lng?: true
    distanceMeters?: true
  }

  export type AttendanceEventSumAggregateInputType = {
    lat?: true
    lng?: true
    distanceMeters?: true
  }

  export type AttendanceEventMinAggregateInputType = {
    id?: true
    employeeUserId?: true
    kitchenId?: true
    type?: true
    method?: true
    lat?: true
    lng?: true
    distanceMeters?: true
    createdAt?: true
  }

  export type AttendanceEventMaxAggregateInputType = {
    id?: true
    employeeUserId?: true
    kitchenId?: true
    type?: true
    method?: true
    lat?: true
    lng?: true
    distanceMeters?: true
    createdAt?: true
  }

  export type AttendanceEventCountAggregateInputType = {
    id?: true
    employeeUserId?: true
    kitchenId?: true
    type?: true
    method?: true
    lat?: true
    lng?: true
    distanceMeters?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceEvent to aggregate.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceEvents
    **/
    _count?: true | AttendanceEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceEventMaxAggregateInputType
  }

  export type GetAttendanceEventAggregateType<T extends AttendanceEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceEvent[P]>
      : GetScalarType<T[P], AggregateAttendanceEvent[P]>
  }




  export type AttendanceEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceEventWhereInput
    orderBy?: AttendanceEventOrderByWithAggregationInput | AttendanceEventOrderByWithAggregationInput[]
    by: AttendanceEventScalarFieldEnum[] | AttendanceEventScalarFieldEnum
    having?: AttendanceEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceEventCountAggregateInputType | true
    _avg?: AttendanceEventAvgAggregateInputType
    _sum?: AttendanceEventSumAggregateInputType
    _min?: AttendanceEventMinAggregateInputType
    _max?: AttendanceEventMaxAggregateInputType
  }

  export type AttendanceEventGroupByOutputType = {
    id: string
    employeeUserId: string
    kitchenId: string
    type: $Enums.AttendanceType
    method: $Enums.AttendanceMethod
    lat: number | null
    lng: number | null
    distanceMeters: number | null
    createdAt: Date
    _count: AttendanceEventCountAggregateOutputType | null
    _avg: AttendanceEventAvgAggregateOutputType | null
    _sum: AttendanceEventSumAggregateOutputType | null
    _min: AttendanceEventMinAggregateOutputType | null
    _max: AttendanceEventMaxAggregateOutputType | null
  }

  type GetAttendanceEventGroupByPayload<T extends AttendanceEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceEventGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceEventGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    type?: boolean
    method?: boolean
    lat?: boolean
    lng?: boolean
    distanceMeters?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    type?: boolean
    method?: boolean
    lat?: boolean
    lng?: boolean
    distanceMeters?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    type?: boolean
    method?: boolean
    lat?: boolean
    lng?: boolean
    distanceMeters?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceEvent"]>

  export type AttendanceEventSelectScalar = {
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    type?: boolean
    method?: boolean
    lat?: boolean
    lng?: boolean
    distanceMeters?: boolean
    createdAt?: boolean
  }

  export type AttendanceEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeUserId" | "kitchenId" | "type" | "method" | "lat" | "lng" | "distanceMeters" | "createdAt", ExtArgs["result"]["attendanceEvent"]>
  export type AttendanceEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }
  export type AttendanceEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }
  export type AttendanceEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }

  export type $AttendanceEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceEvent"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      kitchen: Prisma.$KitchenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeUserId: string
      kitchenId: string
      type: $Enums.AttendanceType
      method: $Enums.AttendanceMethod
      lat: number | null
      lng: number | null
      distanceMeters: number | null
      createdAt: Date
    }, ExtArgs["result"]["attendanceEvent"]>
    composites: {}
  }

  type AttendanceEventGetPayload<S extends boolean | null | undefined | AttendanceEventDefaultArgs> = $Result.GetResult<Prisma.$AttendanceEventPayload, S>

  type AttendanceEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceEventCountAggregateInputType | true
    }

  export interface AttendanceEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceEvent'], meta: { name: 'AttendanceEvent' } }
    /**
     * Find zero or one AttendanceEvent that matches the filter.
     * @param {AttendanceEventFindUniqueArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceEventFindUniqueArgs>(args: SelectSubset<T, AttendanceEventFindUniqueArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceEventFindUniqueOrThrowArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindFirstArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceEventFindFirstArgs>(args?: SelectSubset<T, AttendanceEventFindFirstArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindFirstOrThrowArgs} args - Arguments to find a AttendanceEvent
     * @example
     * // Get one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceEvents
     * const attendanceEvents = await prisma.attendanceEvent.findMany()
     * 
     * // Get first 10 AttendanceEvents
     * const attendanceEvents = await prisma.attendanceEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceEventFindManyArgs>(args?: SelectSubset<T, AttendanceEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceEvent.
     * @param {AttendanceEventCreateArgs} args - Arguments to create a AttendanceEvent.
     * @example
     * // Create one AttendanceEvent
     * const AttendanceEvent = await prisma.attendanceEvent.create({
     *   data: {
     *     // ... data to create a AttendanceEvent
     *   }
     * })
     * 
     */
    create<T extends AttendanceEventCreateArgs>(args: SelectSubset<T, AttendanceEventCreateArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceEvents.
     * @param {AttendanceEventCreateManyArgs} args - Arguments to create many AttendanceEvents.
     * @example
     * // Create many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceEventCreateManyArgs>(args?: SelectSubset<T, AttendanceEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceEvents and returns the data saved in the database.
     * @param {AttendanceEventCreateManyAndReturnArgs} args - Arguments to create many AttendanceEvents.
     * @example
     * // Create many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceEvents and only return the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceEvent.
     * @param {AttendanceEventDeleteArgs} args - Arguments to delete one AttendanceEvent.
     * @example
     * // Delete one AttendanceEvent
     * const AttendanceEvent = await prisma.attendanceEvent.delete({
     *   where: {
     *     // ... filter to delete one AttendanceEvent
     *   }
     * })
     * 
     */
    delete<T extends AttendanceEventDeleteArgs>(args: SelectSubset<T, AttendanceEventDeleteArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceEvent.
     * @param {AttendanceEventUpdateArgs} args - Arguments to update one AttendanceEvent.
     * @example
     * // Update one AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceEventUpdateArgs>(args: SelectSubset<T, AttendanceEventUpdateArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceEvents.
     * @param {AttendanceEventDeleteManyArgs} args - Arguments to filter AttendanceEvents to delete.
     * @example
     * // Delete a few AttendanceEvents
     * const { count } = await prisma.attendanceEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceEventDeleteManyArgs>(args?: SelectSubset<T, AttendanceEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceEventUpdateManyArgs>(args: SelectSubset<T, AttendanceEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceEvents and returns the data updated in the database.
     * @param {AttendanceEventUpdateManyAndReturnArgs} args - Arguments to update many AttendanceEvents.
     * @example
     * // Update many AttendanceEvents
     * const attendanceEvent = await prisma.attendanceEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceEvents and only return the `id`
     * const attendanceEventWithIdOnly = await prisma.attendanceEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceEvent.
     * @param {AttendanceEventUpsertArgs} args - Arguments to update or create a AttendanceEvent.
     * @example
     * // Update or create a AttendanceEvent
     * const attendanceEvent = await prisma.attendanceEvent.upsert({
     *   create: {
     *     // ... data to create a AttendanceEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceEvent we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceEventUpsertArgs>(args: SelectSubset<T, AttendanceEventUpsertArgs<ExtArgs>>): Prisma__AttendanceEventClient<$Result.GetResult<Prisma.$AttendanceEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventCountArgs} args - Arguments to filter AttendanceEvents to count.
     * @example
     * // Count the number of AttendanceEvents
     * const count = await prisma.attendanceEvent.count({
     *   where: {
     *     // ... the filter for the AttendanceEvents we want to count
     *   }
     * })
    **/
    count<T extends AttendanceEventCountArgs>(
      args?: Subset<T, AttendanceEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceEventAggregateArgs>(args: Subset<T, AttendanceEventAggregateArgs>): Prisma.PrismaPromise<GetAttendanceEventAggregateType<T>>

    /**
     * Group by AttendanceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceEventGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceEvent model
   */
  readonly fields: AttendanceEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kitchen<T extends KitchenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitchenDefaultArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceEvent model
   */
  interface AttendanceEventFieldRefs {
    readonly id: FieldRef<"AttendanceEvent", 'String'>
    readonly employeeUserId: FieldRef<"AttendanceEvent", 'String'>
    readonly kitchenId: FieldRef<"AttendanceEvent", 'String'>
    readonly type: FieldRef<"AttendanceEvent", 'AttendanceType'>
    readonly method: FieldRef<"AttendanceEvent", 'AttendanceMethod'>
    readonly lat: FieldRef<"AttendanceEvent", 'Float'>
    readonly lng: FieldRef<"AttendanceEvent", 'Float'>
    readonly distanceMeters: FieldRef<"AttendanceEvent", 'Float'>
    readonly createdAt: FieldRef<"AttendanceEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceEvent findUnique
   */
  export type AttendanceEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent findUniqueOrThrow
   */
  export type AttendanceEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent findFirst
   */
  export type AttendanceEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceEvents.
     */
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent findFirstOrThrow
   */
  export type AttendanceEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvent to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceEvents.
     */
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent findMany
   */
  export type AttendanceEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceEvents to fetch.
     */
    where?: AttendanceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceEvents to fetch.
     */
    orderBy?: AttendanceEventOrderByWithRelationInput | AttendanceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceEvents.
     */
    cursor?: AttendanceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceEvents.
     */
    skip?: number
    distinct?: AttendanceEventScalarFieldEnum | AttendanceEventScalarFieldEnum[]
  }

  /**
   * AttendanceEvent create
   */
  export type AttendanceEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceEvent.
     */
    data: XOR<AttendanceEventCreateInput, AttendanceEventUncheckedCreateInput>
  }

  /**
   * AttendanceEvent createMany
   */
  export type AttendanceEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceEvents.
     */
    data: AttendanceEventCreateManyInput | AttendanceEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceEvent createManyAndReturn
   */
  export type AttendanceEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceEvents.
     */
    data: AttendanceEventCreateManyInput | AttendanceEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceEvent update
   */
  export type AttendanceEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceEvent.
     */
    data: XOR<AttendanceEventUpdateInput, AttendanceEventUncheckedUpdateInput>
    /**
     * Choose, which AttendanceEvent to update.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent updateMany
   */
  export type AttendanceEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceEvents.
     */
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceEvents to update
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to update.
     */
    limit?: number
  }

  /**
   * AttendanceEvent updateManyAndReturn
   */
  export type AttendanceEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceEvents.
     */
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceEvents to update
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceEvent upsert
   */
  export type AttendanceEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceEvent to update in case it exists.
     */
    where: AttendanceEventWhereUniqueInput
    /**
     * In case the AttendanceEvent found by the `where` argument doesn't exist, create a new AttendanceEvent with this data.
     */
    create: XOR<AttendanceEventCreateInput, AttendanceEventUncheckedCreateInput>
    /**
     * In case the AttendanceEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceEventUpdateInput, AttendanceEventUncheckedUpdateInput>
  }

  /**
   * AttendanceEvent delete
   */
  export type AttendanceEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
    /**
     * Filter which AttendanceEvent to delete.
     */
    where: AttendanceEventWhereUniqueInput
  }

  /**
   * AttendanceEvent deleteMany
   */
  export type AttendanceEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceEvents to delete
     */
    where?: AttendanceEventWhereInput
    /**
     * Limit how many AttendanceEvents to delete.
     */
    limit?: number
  }

  /**
   * AttendanceEvent without action
   */
  export type AttendanceEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceEvent
     */
    select?: AttendanceEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceEvent
     */
    omit?: AttendanceEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceEventInclude<ExtArgs> | null
  }


  /**
   * Model ShiftDaySummary
   */

  export type AggregateShiftDaySummary = {
    _count: ShiftDaySummaryCountAggregateOutputType | null
    _avg: ShiftDaySummaryAvgAggregateOutputType | null
    _sum: ShiftDaySummarySumAggregateOutputType | null
    _min: ShiftDaySummaryMinAggregateOutputType | null
    _max: ShiftDaySummaryMaxAggregateOutputType | null
  }

  export type ShiftDaySummaryAvgAggregateOutputType = {
    minutesWorked: number | null
    minutesLate: number | null
    overtimeMinutes: number | null
  }

  export type ShiftDaySummarySumAggregateOutputType = {
    minutesWorked: number | null
    minutesLate: number | null
    overtimeMinutes: number | null
  }

  export type ShiftDaySummaryMinAggregateOutputType = {
    id: string | null
    employeeUserId: string | null
    kitchenId: string | null
    date: Date | null
    minutesWorked: number | null
    minutesLate: number | null
    overtimeMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftDaySummaryMaxAggregateOutputType = {
    id: string | null
    employeeUserId: string | null
    kitchenId: string | null
    date: Date | null
    minutesWorked: number | null
    minutesLate: number | null
    overtimeMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftDaySummaryCountAggregateOutputType = {
    id: number
    employeeUserId: number
    kitchenId: number
    date: number
    minutesWorked: number
    minutesLate: number
    overtimeMinutes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftDaySummaryAvgAggregateInputType = {
    minutesWorked?: true
    minutesLate?: true
    overtimeMinutes?: true
  }

  export type ShiftDaySummarySumAggregateInputType = {
    minutesWorked?: true
    minutesLate?: true
    overtimeMinutes?: true
  }

  export type ShiftDaySummaryMinAggregateInputType = {
    id?: true
    employeeUserId?: true
    kitchenId?: true
    date?: true
    minutesWorked?: true
    minutesLate?: true
    overtimeMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftDaySummaryMaxAggregateInputType = {
    id?: true
    employeeUserId?: true
    kitchenId?: true
    date?: true
    minutesWorked?: true
    minutesLate?: true
    overtimeMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftDaySummaryCountAggregateInputType = {
    id?: true
    employeeUserId?: true
    kitchenId?: true
    date?: true
    minutesWorked?: true
    minutesLate?: true
    overtimeMinutes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftDaySummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftDaySummary to aggregate.
     */
    where?: ShiftDaySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftDaySummaries to fetch.
     */
    orderBy?: ShiftDaySummaryOrderByWithRelationInput | ShiftDaySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftDaySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftDaySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftDaySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftDaySummaries
    **/
    _count?: true | ShiftDaySummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftDaySummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftDaySummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftDaySummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftDaySummaryMaxAggregateInputType
  }

  export type GetShiftDaySummaryAggregateType<T extends ShiftDaySummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftDaySummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftDaySummary[P]>
      : GetScalarType<T[P], AggregateShiftDaySummary[P]>
  }




  export type ShiftDaySummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftDaySummaryWhereInput
    orderBy?: ShiftDaySummaryOrderByWithAggregationInput | ShiftDaySummaryOrderByWithAggregationInput[]
    by: ShiftDaySummaryScalarFieldEnum[] | ShiftDaySummaryScalarFieldEnum
    having?: ShiftDaySummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftDaySummaryCountAggregateInputType | true
    _avg?: ShiftDaySummaryAvgAggregateInputType
    _sum?: ShiftDaySummarySumAggregateInputType
    _min?: ShiftDaySummaryMinAggregateInputType
    _max?: ShiftDaySummaryMaxAggregateInputType
  }

  export type ShiftDaySummaryGroupByOutputType = {
    id: string
    employeeUserId: string
    kitchenId: string
    date: Date
    minutesWorked: number
    minutesLate: number
    overtimeMinutes: number
    createdAt: Date
    updatedAt: Date
    _count: ShiftDaySummaryCountAggregateOutputType | null
    _avg: ShiftDaySummaryAvgAggregateOutputType | null
    _sum: ShiftDaySummarySumAggregateOutputType | null
    _min: ShiftDaySummaryMinAggregateOutputType | null
    _max: ShiftDaySummaryMaxAggregateOutputType | null
  }

  type GetShiftDaySummaryGroupByPayload<T extends ShiftDaySummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftDaySummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftDaySummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftDaySummaryGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftDaySummaryGroupByOutputType[P]>
        }
      >
    >


  export type ShiftDaySummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    date?: boolean
    minutesWorked?: boolean
    minutesLate?: boolean
    overtimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftDaySummary"]>

  export type ShiftDaySummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    date?: boolean
    minutesWorked?: boolean
    minutesLate?: boolean
    overtimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftDaySummary"]>

  export type ShiftDaySummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    date?: boolean
    minutesWorked?: boolean
    minutesLate?: boolean
    overtimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftDaySummary"]>

  export type ShiftDaySummarySelectScalar = {
    id?: boolean
    employeeUserId?: boolean
    kitchenId?: boolean
    date?: boolean
    minutesWorked?: boolean
    minutesLate?: boolean
    overtimeMinutes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftDaySummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeUserId" | "kitchenId" | "date" | "minutesWorked" | "minutesLate" | "overtimeMinutes" | "createdAt" | "updatedAt", ExtArgs["result"]["shiftDaySummary"]>
  export type ShiftDaySummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }
  export type ShiftDaySummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }
  export type ShiftDaySummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    kitchen?: boolean | KitchenDefaultArgs<ExtArgs>
  }

  export type $ShiftDaySummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftDaySummary"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      kitchen: Prisma.$KitchenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeUserId: string
      kitchenId: string
      date: Date
      minutesWorked: number
      minutesLate: number
      overtimeMinutes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shiftDaySummary"]>
    composites: {}
  }

  type ShiftDaySummaryGetPayload<S extends boolean | null | undefined | ShiftDaySummaryDefaultArgs> = $Result.GetResult<Prisma.$ShiftDaySummaryPayload, S>

  type ShiftDaySummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftDaySummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftDaySummaryCountAggregateInputType | true
    }

  export interface ShiftDaySummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftDaySummary'], meta: { name: 'ShiftDaySummary' } }
    /**
     * Find zero or one ShiftDaySummary that matches the filter.
     * @param {ShiftDaySummaryFindUniqueArgs} args - Arguments to find a ShiftDaySummary
     * @example
     * // Get one ShiftDaySummary
     * const shiftDaySummary = await prisma.shiftDaySummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftDaySummaryFindUniqueArgs>(args: SelectSubset<T, ShiftDaySummaryFindUniqueArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShiftDaySummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftDaySummaryFindUniqueOrThrowArgs} args - Arguments to find a ShiftDaySummary
     * @example
     * // Get one ShiftDaySummary
     * const shiftDaySummary = await prisma.shiftDaySummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftDaySummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftDaySummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftDaySummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftDaySummaryFindFirstArgs} args - Arguments to find a ShiftDaySummary
     * @example
     * // Get one ShiftDaySummary
     * const shiftDaySummary = await prisma.shiftDaySummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftDaySummaryFindFirstArgs>(args?: SelectSubset<T, ShiftDaySummaryFindFirstArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShiftDaySummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftDaySummaryFindFirstOrThrowArgs} args - Arguments to find a ShiftDaySummary
     * @example
     * // Get one ShiftDaySummary
     * const shiftDaySummary = await prisma.shiftDaySummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftDaySummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftDaySummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShiftDaySummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftDaySummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftDaySummaries
     * const shiftDaySummaries = await prisma.shiftDaySummary.findMany()
     * 
     * // Get first 10 ShiftDaySummaries
     * const shiftDaySummaries = await prisma.shiftDaySummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftDaySummaryWithIdOnly = await prisma.shiftDaySummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftDaySummaryFindManyArgs>(args?: SelectSubset<T, ShiftDaySummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShiftDaySummary.
     * @param {ShiftDaySummaryCreateArgs} args - Arguments to create a ShiftDaySummary.
     * @example
     * // Create one ShiftDaySummary
     * const ShiftDaySummary = await prisma.shiftDaySummary.create({
     *   data: {
     *     // ... data to create a ShiftDaySummary
     *   }
     * })
     * 
     */
    create<T extends ShiftDaySummaryCreateArgs>(args: SelectSubset<T, ShiftDaySummaryCreateArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShiftDaySummaries.
     * @param {ShiftDaySummaryCreateManyArgs} args - Arguments to create many ShiftDaySummaries.
     * @example
     * // Create many ShiftDaySummaries
     * const shiftDaySummary = await prisma.shiftDaySummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftDaySummaryCreateManyArgs>(args?: SelectSubset<T, ShiftDaySummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftDaySummaries and returns the data saved in the database.
     * @param {ShiftDaySummaryCreateManyAndReturnArgs} args - Arguments to create many ShiftDaySummaries.
     * @example
     * // Create many ShiftDaySummaries
     * const shiftDaySummary = await prisma.shiftDaySummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftDaySummaries and only return the `id`
     * const shiftDaySummaryWithIdOnly = await prisma.shiftDaySummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftDaySummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftDaySummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShiftDaySummary.
     * @param {ShiftDaySummaryDeleteArgs} args - Arguments to delete one ShiftDaySummary.
     * @example
     * // Delete one ShiftDaySummary
     * const ShiftDaySummary = await prisma.shiftDaySummary.delete({
     *   where: {
     *     // ... filter to delete one ShiftDaySummary
     *   }
     * })
     * 
     */
    delete<T extends ShiftDaySummaryDeleteArgs>(args: SelectSubset<T, ShiftDaySummaryDeleteArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShiftDaySummary.
     * @param {ShiftDaySummaryUpdateArgs} args - Arguments to update one ShiftDaySummary.
     * @example
     * // Update one ShiftDaySummary
     * const shiftDaySummary = await prisma.shiftDaySummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftDaySummaryUpdateArgs>(args: SelectSubset<T, ShiftDaySummaryUpdateArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShiftDaySummaries.
     * @param {ShiftDaySummaryDeleteManyArgs} args - Arguments to filter ShiftDaySummaries to delete.
     * @example
     * // Delete a few ShiftDaySummaries
     * const { count } = await prisma.shiftDaySummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDaySummaryDeleteManyArgs>(args?: SelectSubset<T, ShiftDaySummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftDaySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftDaySummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftDaySummaries
     * const shiftDaySummary = await prisma.shiftDaySummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftDaySummaryUpdateManyArgs>(args: SelectSubset<T, ShiftDaySummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftDaySummaries and returns the data updated in the database.
     * @param {ShiftDaySummaryUpdateManyAndReturnArgs} args - Arguments to update many ShiftDaySummaries.
     * @example
     * // Update many ShiftDaySummaries
     * const shiftDaySummary = await prisma.shiftDaySummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShiftDaySummaries and only return the `id`
     * const shiftDaySummaryWithIdOnly = await prisma.shiftDaySummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftDaySummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftDaySummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShiftDaySummary.
     * @param {ShiftDaySummaryUpsertArgs} args - Arguments to update or create a ShiftDaySummary.
     * @example
     * // Update or create a ShiftDaySummary
     * const shiftDaySummary = await prisma.shiftDaySummary.upsert({
     *   create: {
     *     // ... data to create a ShiftDaySummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftDaySummary we want to update
     *   }
     * })
     */
    upsert<T extends ShiftDaySummaryUpsertArgs>(args: SelectSubset<T, ShiftDaySummaryUpsertArgs<ExtArgs>>): Prisma__ShiftDaySummaryClient<$Result.GetResult<Prisma.$ShiftDaySummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShiftDaySummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftDaySummaryCountArgs} args - Arguments to filter ShiftDaySummaries to count.
     * @example
     * // Count the number of ShiftDaySummaries
     * const count = await prisma.shiftDaySummary.count({
     *   where: {
     *     // ... the filter for the ShiftDaySummaries we want to count
     *   }
     * })
    **/
    count<T extends ShiftDaySummaryCountArgs>(
      args?: Subset<T, ShiftDaySummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftDaySummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftDaySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftDaySummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftDaySummaryAggregateArgs>(args: Subset<T, ShiftDaySummaryAggregateArgs>): Prisma.PrismaPromise<GetShiftDaySummaryAggregateType<T>>

    /**
     * Group by ShiftDaySummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftDaySummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftDaySummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftDaySummaryGroupByArgs['orderBy'] }
        : { orderBy?: ShiftDaySummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftDaySummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftDaySummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftDaySummary model
   */
  readonly fields: ShiftDaySummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftDaySummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftDaySummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kitchen<T extends KitchenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KitchenDefaultArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftDaySummary model
   */
  interface ShiftDaySummaryFieldRefs {
    readonly id: FieldRef<"ShiftDaySummary", 'String'>
    readonly employeeUserId: FieldRef<"ShiftDaySummary", 'String'>
    readonly kitchenId: FieldRef<"ShiftDaySummary", 'String'>
    readonly date: FieldRef<"ShiftDaySummary", 'DateTime'>
    readonly minutesWorked: FieldRef<"ShiftDaySummary", 'Int'>
    readonly minutesLate: FieldRef<"ShiftDaySummary", 'Int'>
    readonly overtimeMinutes: FieldRef<"ShiftDaySummary", 'Int'>
    readonly createdAt: FieldRef<"ShiftDaySummary", 'DateTime'>
    readonly updatedAt: FieldRef<"ShiftDaySummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftDaySummary findUnique
   */
  export type ShiftDaySummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftDaySummary to fetch.
     */
    where: ShiftDaySummaryWhereUniqueInput
  }

  /**
   * ShiftDaySummary findUniqueOrThrow
   */
  export type ShiftDaySummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftDaySummary to fetch.
     */
    where: ShiftDaySummaryWhereUniqueInput
  }

  /**
   * ShiftDaySummary findFirst
   */
  export type ShiftDaySummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftDaySummary to fetch.
     */
    where?: ShiftDaySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftDaySummaries to fetch.
     */
    orderBy?: ShiftDaySummaryOrderByWithRelationInput | ShiftDaySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftDaySummaries.
     */
    cursor?: ShiftDaySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftDaySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftDaySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftDaySummaries.
     */
    distinct?: ShiftDaySummaryScalarFieldEnum | ShiftDaySummaryScalarFieldEnum[]
  }

  /**
   * ShiftDaySummary findFirstOrThrow
   */
  export type ShiftDaySummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftDaySummary to fetch.
     */
    where?: ShiftDaySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftDaySummaries to fetch.
     */
    orderBy?: ShiftDaySummaryOrderByWithRelationInput | ShiftDaySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftDaySummaries.
     */
    cursor?: ShiftDaySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftDaySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftDaySummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftDaySummaries.
     */
    distinct?: ShiftDaySummaryScalarFieldEnum | ShiftDaySummaryScalarFieldEnum[]
  }

  /**
   * ShiftDaySummary findMany
   */
  export type ShiftDaySummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * Filter, which ShiftDaySummaries to fetch.
     */
    where?: ShiftDaySummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftDaySummaries to fetch.
     */
    orderBy?: ShiftDaySummaryOrderByWithRelationInput | ShiftDaySummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftDaySummaries.
     */
    cursor?: ShiftDaySummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftDaySummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftDaySummaries.
     */
    skip?: number
    distinct?: ShiftDaySummaryScalarFieldEnum | ShiftDaySummaryScalarFieldEnum[]
  }

  /**
   * ShiftDaySummary create
   */
  export type ShiftDaySummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftDaySummary.
     */
    data: XOR<ShiftDaySummaryCreateInput, ShiftDaySummaryUncheckedCreateInput>
  }

  /**
   * ShiftDaySummary createMany
   */
  export type ShiftDaySummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftDaySummaries.
     */
    data: ShiftDaySummaryCreateManyInput | ShiftDaySummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftDaySummary createManyAndReturn
   */
  export type ShiftDaySummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * The data used to create many ShiftDaySummaries.
     */
    data: ShiftDaySummaryCreateManyInput | ShiftDaySummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftDaySummary update
   */
  export type ShiftDaySummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftDaySummary.
     */
    data: XOR<ShiftDaySummaryUpdateInput, ShiftDaySummaryUncheckedUpdateInput>
    /**
     * Choose, which ShiftDaySummary to update.
     */
    where: ShiftDaySummaryWhereUniqueInput
  }

  /**
   * ShiftDaySummary updateMany
   */
  export type ShiftDaySummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftDaySummaries.
     */
    data: XOR<ShiftDaySummaryUpdateManyMutationInput, ShiftDaySummaryUncheckedUpdateManyInput>
    /**
     * Filter which ShiftDaySummaries to update
     */
    where?: ShiftDaySummaryWhereInput
    /**
     * Limit how many ShiftDaySummaries to update.
     */
    limit?: number
  }

  /**
   * ShiftDaySummary updateManyAndReturn
   */
  export type ShiftDaySummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * The data used to update ShiftDaySummaries.
     */
    data: XOR<ShiftDaySummaryUpdateManyMutationInput, ShiftDaySummaryUncheckedUpdateManyInput>
    /**
     * Filter which ShiftDaySummaries to update
     */
    where?: ShiftDaySummaryWhereInput
    /**
     * Limit how many ShiftDaySummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftDaySummary upsert
   */
  export type ShiftDaySummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftDaySummary to update in case it exists.
     */
    where: ShiftDaySummaryWhereUniqueInput
    /**
     * In case the ShiftDaySummary found by the `where` argument doesn't exist, create a new ShiftDaySummary with this data.
     */
    create: XOR<ShiftDaySummaryCreateInput, ShiftDaySummaryUncheckedCreateInput>
    /**
     * In case the ShiftDaySummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftDaySummaryUpdateInput, ShiftDaySummaryUncheckedUpdateInput>
  }

  /**
   * ShiftDaySummary delete
   */
  export type ShiftDaySummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
    /**
     * Filter which ShiftDaySummary to delete.
     */
    where: ShiftDaySummaryWhereUniqueInput
  }

  /**
   * ShiftDaySummary deleteMany
   */
  export type ShiftDaySummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftDaySummaries to delete
     */
    where?: ShiftDaySummaryWhereInput
    /**
     * Limit how many ShiftDaySummaries to delete.
     */
    limit?: number
  }

  /**
   * ShiftDaySummary without action
   */
  export type ShiftDaySummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftDaySummary
     */
    select?: ShiftDaySummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShiftDaySummary
     */
    omit?: ShiftDaySummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftDaySummaryInclude<ExtArgs> | null
  }


  /**
   * Model PayrollPeriod
   */

  export type AggregatePayrollPeriod = {
    _count: PayrollPeriodCountAggregateOutputType | null
    _min: PayrollPeriodMinAggregateOutputType | null
    _max: PayrollPeriodMaxAggregateOutputType | null
  }

  export type PayrollPeriodMinAggregateOutputType = {
    id: string | null
    month: string | null
    status: $Enums.PayrollPeriodStatus | null
    generatedAt: Date | null
  }

  export type PayrollPeriodMaxAggregateOutputType = {
    id: string | null
    month: string | null
    status: $Enums.PayrollPeriodStatus | null
    generatedAt: Date | null
  }

  export type PayrollPeriodCountAggregateOutputType = {
    id: number
    month: number
    status: number
    generatedAt: number
    _all: number
  }


  export type PayrollPeriodMinAggregateInputType = {
    id?: true
    month?: true
    status?: true
    generatedAt?: true
  }

  export type PayrollPeriodMaxAggregateInputType = {
    id?: true
    month?: true
    status?: true
    generatedAt?: true
  }

  export type PayrollPeriodCountAggregateInputType = {
    id?: true
    month?: true
    status?: true
    generatedAt?: true
    _all?: true
  }

  export type PayrollPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollPeriod to aggregate.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollPeriods
    **/
    _count?: true | PayrollPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollPeriodMaxAggregateInputType
  }

  export type GetPayrollPeriodAggregateType<T extends PayrollPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollPeriod[P]>
      : GetScalarType<T[P], AggregatePayrollPeriod[P]>
  }




  export type PayrollPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollPeriodWhereInput
    orderBy?: PayrollPeriodOrderByWithAggregationInput | PayrollPeriodOrderByWithAggregationInput[]
    by: PayrollPeriodScalarFieldEnum[] | PayrollPeriodScalarFieldEnum
    having?: PayrollPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollPeriodCountAggregateInputType | true
    _min?: PayrollPeriodMinAggregateInputType
    _max?: PayrollPeriodMaxAggregateInputType
  }

  export type PayrollPeriodGroupByOutputType = {
    id: string
    month: string
    status: $Enums.PayrollPeriodStatus
    generatedAt: Date
    _count: PayrollPeriodCountAggregateOutputType | null
    _min: PayrollPeriodMinAggregateOutputType | null
    _max: PayrollPeriodMaxAggregateOutputType | null
  }

  type GetPayrollPeriodGroupByPayload<T extends PayrollPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollPeriodGroupByOutputType[P]>
        }
      >
    >


  export type PayrollPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    status?: boolean
    generatedAt?: boolean
    entries?: boolean | PayrollPeriod$entriesArgs<ExtArgs>
    _count?: boolean | PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    status?: boolean
    generatedAt?: boolean
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    status?: boolean
    generatedAt?: boolean
  }, ExtArgs["result"]["payrollPeriod"]>

  export type PayrollPeriodSelectScalar = {
    id?: boolean
    month?: boolean
    status?: boolean
    generatedAt?: boolean
  }

  export type PayrollPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "status" | "generatedAt", ExtArgs["result"]["payrollPeriod"]>
  export type PayrollPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | PayrollPeriod$entriesArgs<ExtArgs>
    _count?: boolean | PayrollPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PayrollPeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PayrollPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollPeriod"
    objects: {
      entries: Prisma.$PayrollEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      month: string
      status: $Enums.PayrollPeriodStatus
      generatedAt: Date
    }, ExtArgs["result"]["payrollPeriod"]>
    composites: {}
  }

  type PayrollPeriodGetPayload<S extends boolean | null | undefined | PayrollPeriodDefaultArgs> = $Result.GetResult<Prisma.$PayrollPeriodPayload, S>

  type PayrollPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollPeriodCountAggregateInputType | true
    }

  export interface PayrollPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollPeriod'], meta: { name: 'PayrollPeriod' } }
    /**
     * Find zero or one PayrollPeriod that matches the filter.
     * @param {PayrollPeriodFindUniqueArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollPeriodFindUniqueArgs>(args: SelectSubset<T, PayrollPeriodFindUniqueArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollPeriodFindUniqueOrThrowArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindFirstArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollPeriodFindFirstArgs>(args?: SelectSubset<T, PayrollPeriodFindFirstArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindFirstOrThrowArgs} args - Arguments to find a PayrollPeriod
     * @example
     * // Get one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollPeriods
     * const payrollPeriods = await prisma.payrollPeriod.findMany()
     * 
     * // Get first 10 PayrollPeriods
     * const payrollPeriods = await prisma.payrollPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollPeriodFindManyArgs>(args?: SelectSubset<T, PayrollPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollPeriod.
     * @param {PayrollPeriodCreateArgs} args - Arguments to create a PayrollPeriod.
     * @example
     * // Create one PayrollPeriod
     * const PayrollPeriod = await prisma.payrollPeriod.create({
     *   data: {
     *     // ... data to create a PayrollPeriod
     *   }
     * })
     * 
     */
    create<T extends PayrollPeriodCreateArgs>(args: SelectSubset<T, PayrollPeriodCreateArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollPeriods.
     * @param {PayrollPeriodCreateManyArgs} args - Arguments to create many PayrollPeriods.
     * @example
     * // Create many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollPeriodCreateManyArgs>(args?: SelectSubset<T, PayrollPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollPeriods and returns the data saved in the database.
     * @param {PayrollPeriodCreateManyAndReturnArgs} args - Arguments to create many PayrollPeriods.
     * @example
     * // Create many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollPeriods and only return the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollPeriod.
     * @param {PayrollPeriodDeleteArgs} args - Arguments to delete one PayrollPeriod.
     * @example
     * // Delete one PayrollPeriod
     * const PayrollPeriod = await prisma.payrollPeriod.delete({
     *   where: {
     *     // ... filter to delete one PayrollPeriod
     *   }
     * })
     * 
     */
    delete<T extends PayrollPeriodDeleteArgs>(args: SelectSubset<T, PayrollPeriodDeleteArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollPeriod.
     * @param {PayrollPeriodUpdateArgs} args - Arguments to update one PayrollPeriod.
     * @example
     * // Update one PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollPeriodUpdateArgs>(args: SelectSubset<T, PayrollPeriodUpdateArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollPeriods.
     * @param {PayrollPeriodDeleteManyArgs} args - Arguments to filter PayrollPeriods to delete.
     * @example
     * // Delete a few PayrollPeriods
     * const { count } = await prisma.payrollPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollPeriodDeleteManyArgs>(args?: SelectSubset<T, PayrollPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollPeriodUpdateManyArgs>(args: SelectSubset<T, PayrollPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollPeriods and returns the data updated in the database.
     * @param {PayrollPeriodUpdateManyAndReturnArgs} args - Arguments to update many PayrollPeriods.
     * @example
     * // Update many PayrollPeriods
     * const payrollPeriod = await prisma.payrollPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollPeriods and only return the `id`
     * const payrollPeriodWithIdOnly = await prisma.payrollPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollPeriod.
     * @param {PayrollPeriodUpsertArgs} args - Arguments to update or create a PayrollPeriod.
     * @example
     * // Update or create a PayrollPeriod
     * const payrollPeriod = await prisma.payrollPeriod.upsert({
     *   create: {
     *     // ... data to create a PayrollPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollPeriod we want to update
     *   }
     * })
     */
    upsert<T extends PayrollPeriodUpsertArgs>(args: SelectSubset<T, PayrollPeriodUpsertArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodCountArgs} args - Arguments to filter PayrollPeriods to count.
     * @example
     * // Count the number of PayrollPeriods
     * const count = await prisma.payrollPeriod.count({
     *   where: {
     *     // ... the filter for the PayrollPeriods we want to count
     *   }
     * })
    **/
    count<T extends PayrollPeriodCountArgs>(
      args?: Subset<T, PayrollPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollPeriodAggregateArgs>(args: Subset<T, PayrollPeriodAggregateArgs>): Prisma.PrismaPromise<GetPayrollPeriodAggregateType<T>>

    /**
     * Group by PayrollPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollPeriodGroupByArgs['orderBy'] }
        : { orderBy?: PayrollPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollPeriod model
   */
  readonly fields: PayrollPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends PayrollPeriod$entriesArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriod$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollPeriod model
   */
  interface PayrollPeriodFieldRefs {
    readonly id: FieldRef<"PayrollPeriod", 'String'>
    readonly month: FieldRef<"PayrollPeriod", 'String'>
    readonly status: FieldRef<"PayrollPeriod", 'PayrollPeriodStatus'>
    readonly generatedAt: FieldRef<"PayrollPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollPeriod findUnique
   */
  export type PayrollPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod findUniqueOrThrow
   */
  export type PayrollPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod findFirst
   */
  export type PayrollPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollPeriods.
     */
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod findFirstOrThrow
   */
  export type PayrollPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriod to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollPeriods.
     */
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod findMany
   */
  export type PayrollPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter, which PayrollPeriods to fetch.
     */
    where?: PayrollPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollPeriods to fetch.
     */
    orderBy?: PayrollPeriodOrderByWithRelationInput | PayrollPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollPeriods.
     */
    cursor?: PayrollPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollPeriods.
     */
    skip?: number
    distinct?: PayrollPeriodScalarFieldEnum | PayrollPeriodScalarFieldEnum[]
  }

  /**
   * PayrollPeriod create
   */
  export type PayrollPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollPeriod.
     */
    data: XOR<PayrollPeriodCreateInput, PayrollPeriodUncheckedCreateInput>
  }

  /**
   * PayrollPeriod createMany
   */
  export type PayrollPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollPeriods.
     */
    data: PayrollPeriodCreateManyInput | PayrollPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollPeriod createManyAndReturn
   */
  export type PayrollPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollPeriods.
     */
    data: PayrollPeriodCreateManyInput | PayrollPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollPeriod update
   */
  export type PayrollPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollPeriod.
     */
    data: XOR<PayrollPeriodUpdateInput, PayrollPeriodUncheckedUpdateInput>
    /**
     * Choose, which PayrollPeriod to update.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod updateMany
   */
  export type PayrollPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollPeriods.
     */
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayrollPeriods to update
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to update.
     */
    limit?: number
  }

  /**
   * PayrollPeriod updateManyAndReturn
   */
  export type PayrollPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * The data used to update PayrollPeriods.
     */
    data: XOR<PayrollPeriodUpdateManyMutationInput, PayrollPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayrollPeriods to update
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to update.
     */
    limit?: number
  }

  /**
   * PayrollPeriod upsert
   */
  export type PayrollPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollPeriod to update in case it exists.
     */
    where: PayrollPeriodWhereUniqueInput
    /**
     * In case the PayrollPeriod found by the `where` argument doesn't exist, create a new PayrollPeriod with this data.
     */
    create: XOR<PayrollPeriodCreateInput, PayrollPeriodUncheckedCreateInput>
    /**
     * In case the PayrollPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollPeriodUpdateInput, PayrollPeriodUncheckedUpdateInput>
  }

  /**
   * PayrollPeriod delete
   */
  export type PayrollPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
    /**
     * Filter which PayrollPeriod to delete.
     */
    where: PayrollPeriodWhereUniqueInput
  }

  /**
   * PayrollPeriod deleteMany
   */
  export type PayrollPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollPeriods to delete
     */
    where?: PayrollPeriodWhereInput
    /**
     * Limit how many PayrollPeriods to delete.
     */
    limit?: number
  }

  /**
   * PayrollPeriod.entries
   */
  export type PayrollPeriod$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    cursor?: PayrollEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollPeriod without action
   */
  export type PayrollPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollPeriod
     */
    select?: PayrollPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollPeriod
     */
    omit?: PayrollPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollPeriodInclude<ExtArgs> | null
  }


  /**
   * Model PayrollEntry
   */

  export type AggregatePayrollEntry = {
    _count: PayrollEntryCountAggregateOutputType | null
    _avg: PayrollEntryAvgAggregateOutputType | null
    _sum: PayrollEntrySumAggregateOutputType | null
    _min: PayrollEntryMinAggregateOutputType | null
    _max: PayrollEntryMaxAggregateOutputType | null
  }

  export type PayrollEntryAvgAggregateOutputType = {
    computedSalary: number | null
    overtimePay: number | null
    deductions: number | null
    netPay: number | null
  }

  export type PayrollEntrySumAggregateOutputType = {
    computedSalary: number | null
    overtimePay: number | null
    deductions: number | null
    netPay: number | null
  }

  export type PayrollEntryMinAggregateOutputType = {
    id: string | null
    periodId: string | null
    employeeUserId: string | null
    computedSalary: number | null
    overtimePay: number | null
    deductions: number | null
    netPay: number | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollEntryMaxAggregateOutputType = {
    id: string | null
    periodId: string | null
    employeeUserId: string | null
    computedSalary: number | null
    overtimePay: number | null
    deductions: number | null
    netPay: number | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollEntryCountAggregateOutputType = {
    id: number
    periodId: number
    employeeUserId: number
    computedSalary: number
    overtimePay: number
    deductions: number
    netPay: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollEntryAvgAggregateInputType = {
    computedSalary?: true
    overtimePay?: true
    deductions?: true
    netPay?: true
  }

  export type PayrollEntrySumAggregateInputType = {
    computedSalary?: true
    overtimePay?: true
    deductions?: true
    netPay?: true
  }

  export type PayrollEntryMinAggregateInputType = {
    id?: true
    periodId?: true
    employeeUserId?: true
    computedSalary?: true
    overtimePay?: true
    deductions?: true
    netPay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollEntryMaxAggregateInputType = {
    id?: true
    periodId?: true
    employeeUserId?: true
    computedSalary?: true
    overtimePay?: true
    deductions?: true
    netPay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollEntryCountAggregateInputType = {
    id?: true
    periodId?: true
    employeeUserId?: true
    computedSalary?: true
    overtimePay?: true
    deductions?: true
    netPay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollEntry to aggregate.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollEntries
    **/
    _count?: true | PayrollEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollEntryMaxAggregateInputType
  }

  export type GetPayrollEntryAggregateType<T extends PayrollEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollEntry[P]>
      : GetScalarType<T[P], AggregatePayrollEntry[P]>
  }




  export type PayrollEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithAggregationInput | PayrollEntryOrderByWithAggregationInput[]
    by: PayrollEntryScalarFieldEnum[] | PayrollEntryScalarFieldEnum
    having?: PayrollEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollEntryCountAggregateInputType | true
    _avg?: PayrollEntryAvgAggregateInputType
    _sum?: PayrollEntrySumAggregateInputType
    _min?: PayrollEntryMinAggregateInputType
    _max?: PayrollEntryMaxAggregateInputType
  }

  export type PayrollEntryGroupByOutputType = {
    id: string
    periodId: string
    employeeUserId: string
    computedSalary: number
    overtimePay: number
    deductions: number
    netPay: number
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollEntryCountAggregateOutputType | null
    _avg: PayrollEntryAvgAggregateOutputType | null
    _sum: PayrollEntrySumAggregateOutputType | null
    _min: PayrollEntryMinAggregateOutputType | null
    _max: PayrollEntryMaxAggregateOutputType | null
  }

  type GetPayrollEntryGroupByPayload<T extends PayrollEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollEntryGroupByOutputType[P]>
        }
      >
    >


  export type PayrollEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodId?: boolean
    employeeUserId?: boolean
    computedSalary?: boolean
    overtimePay?: boolean
    deductions?: boolean
    netPay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodId?: boolean
    employeeUserId?: boolean
    computedSalary?: boolean
    overtimePay?: boolean
    deductions?: boolean
    netPay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodId?: boolean
    employeeUserId?: boolean
    computedSalary?: boolean
    overtimePay?: boolean
    deductions?: boolean
    netPay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectScalar = {
    id?: boolean
    periodId?: boolean
    employeeUserId?: boolean
    computedSalary?: boolean
    overtimePay?: boolean
    deductions?: boolean
    netPay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "periodId" | "employeeUserId" | "computedSalary" | "overtimePay" | "deductions" | "netPay" | "paidAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payrollEntry"]>
  export type PayrollEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PayrollEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PayrollEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    period?: boolean | PayrollPeriodDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PayrollEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollEntry"
    objects: {
      period: Prisma.$PayrollPeriodPayload<ExtArgs>
      employee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      periodId: string
      employeeUserId: string
      computedSalary: number
      overtimePay: number
      deductions: number
      netPay: number
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payrollEntry"]>
    composites: {}
  }

  type PayrollEntryGetPayload<S extends boolean | null | undefined | PayrollEntryDefaultArgs> = $Result.GetResult<Prisma.$PayrollEntryPayload, S>

  type PayrollEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollEntryCountAggregateInputType | true
    }

  export interface PayrollEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollEntry'], meta: { name: 'PayrollEntry' } }
    /**
     * Find zero or one PayrollEntry that matches the filter.
     * @param {PayrollEntryFindUniqueArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollEntryFindUniqueArgs>(args: SelectSubset<T, PayrollEntryFindUniqueArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollEntryFindUniqueOrThrowArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindFirstArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollEntryFindFirstArgs>(args?: SelectSubset<T, PayrollEntryFindFirstArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindFirstOrThrowArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollEntries
     * const payrollEntries = await prisma.payrollEntry.findMany()
     * 
     * // Get first 10 PayrollEntries
     * const payrollEntries = await prisma.payrollEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollEntryFindManyArgs>(args?: SelectSubset<T, PayrollEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollEntry.
     * @param {PayrollEntryCreateArgs} args - Arguments to create a PayrollEntry.
     * @example
     * // Create one PayrollEntry
     * const PayrollEntry = await prisma.payrollEntry.create({
     *   data: {
     *     // ... data to create a PayrollEntry
     *   }
     * })
     * 
     */
    create<T extends PayrollEntryCreateArgs>(args: SelectSubset<T, PayrollEntryCreateArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollEntries.
     * @param {PayrollEntryCreateManyArgs} args - Arguments to create many PayrollEntries.
     * @example
     * // Create many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollEntryCreateManyArgs>(args?: SelectSubset<T, PayrollEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollEntries and returns the data saved in the database.
     * @param {PayrollEntryCreateManyAndReturnArgs} args - Arguments to create many PayrollEntries.
     * @example
     * // Create many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollEntries and only return the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollEntry.
     * @param {PayrollEntryDeleteArgs} args - Arguments to delete one PayrollEntry.
     * @example
     * // Delete one PayrollEntry
     * const PayrollEntry = await prisma.payrollEntry.delete({
     *   where: {
     *     // ... filter to delete one PayrollEntry
     *   }
     * })
     * 
     */
    delete<T extends PayrollEntryDeleteArgs>(args: SelectSubset<T, PayrollEntryDeleteArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollEntry.
     * @param {PayrollEntryUpdateArgs} args - Arguments to update one PayrollEntry.
     * @example
     * // Update one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollEntryUpdateArgs>(args: SelectSubset<T, PayrollEntryUpdateArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollEntries.
     * @param {PayrollEntryDeleteManyArgs} args - Arguments to filter PayrollEntries to delete.
     * @example
     * // Delete a few PayrollEntries
     * const { count } = await prisma.payrollEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollEntryDeleteManyArgs>(args?: SelectSubset<T, PayrollEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollEntryUpdateManyArgs>(args: SelectSubset<T, PayrollEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollEntries and returns the data updated in the database.
     * @param {PayrollEntryUpdateManyAndReturnArgs} args - Arguments to update many PayrollEntries.
     * @example
     * // Update many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollEntries and only return the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollEntry.
     * @param {PayrollEntryUpsertArgs} args - Arguments to update or create a PayrollEntry.
     * @example
     * // Update or create a PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.upsert({
     *   create: {
     *     // ... data to create a PayrollEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollEntry we want to update
     *   }
     * })
     */
    upsert<T extends PayrollEntryUpsertArgs>(args: SelectSubset<T, PayrollEntryUpsertArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryCountArgs} args - Arguments to filter PayrollEntries to count.
     * @example
     * // Count the number of PayrollEntries
     * const count = await prisma.payrollEntry.count({
     *   where: {
     *     // ... the filter for the PayrollEntries we want to count
     *   }
     * })
    **/
    count<T extends PayrollEntryCountArgs>(
      args?: Subset<T, PayrollEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollEntryAggregateArgs>(args: Subset<T, PayrollEntryAggregateArgs>): Prisma.PrismaPromise<GetPayrollEntryAggregateType<T>>

    /**
     * Group by PayrollEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollEntryGroupByArgs['orderBy'] }
        : { orderBy?: PayrollEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollEntry model
   */
  readonly fields: PayrollEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    period<T extends PayrollPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollPeriodDefaultArgs<ExtArgs>>): Prisma__PayrollPeriodClient<$Result.GetResult<Prisma.$PayrollPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollEntry model
   */
  interface PayrollEntryFieldRefs {
    readonly id: FieldRef<"PayrollEntry", 'String'>
    readonly periodId: FieldRef<"PayrollEntry", 'String'>
    readonly employeeUserId: FieldRef<"PayrollEntry", 'String'>
    readonly computedSalary: FieldRef<"PayrollEntry", 'Int'>
    readonly overtimePay: FieldRef<"PayrollEntry", 'Int'>
    readonly deductions: FieldRef<"PayrollEntry", 'Int'>
    readonly netPay: FieldRef<"PayrollEntry", 'Int'>
    readonly paidAt: FieldRef<"PayrollEntry", 'DateTime'>
    readonly createdAt: FieldRef<"PayrollEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"PayrollEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollEntry findUnique
   */
  export type PayrollEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry findUniqueOrThrow
   */
  export type PayrollEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry findFirst
   */
  export type PayrollEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollEntries.
     */
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry findFirstOrThrow
   */
  export type PayrollEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollEntries.
     */
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry findMany
   */
  export type PayrollEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntries to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry create
   */
  export type PayrollEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollEntry.
     */
    data: XOR<PayrollEntryCreateInput, PayrollEntryUncheckedCreateInput>
  }

  /**
   * PayrollEntry createMany
   */
  export type PayrollEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollEntries.
     */
    data: PayrollEntryCreateManyInput | PayrollEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollEntry createManyAndReturn
   */
  export type PayrollEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollEntries.
     */
    data: PayrollEntryCreateManyInput | PayrollEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollEntry update
   */
  export type PayrollEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollEntry.
     */
    data: XOR<PayrollEntryUpdateInput, PayrollEntryUncheckedUpdateInput>
    /**
     * Choose, which PayrollEntry to update.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry updateMany
   */
  export type PayrollEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollEntries.
     */
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyInput>
    /**
     * Filter which PayrollEntries to update
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to update.
     */
    limit?: number
  }

  /**
   * PayrollEntry updateManyAndReturn
   */
  export type PayrollEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * The data used to update PayrollEntries.
     */
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyInput>
    /**
     * Filter which PayrollEntries to update
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollEntry upsert
   */
  export type PayrollEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollEntry to update in case it exists.
     */
    where: PayrollEntryWhereUniqueInput
    /**
     * In case the PayrollEntry found by the `where` argument doesn't exist, create a new PayrollEntry with this data.
     */
    create: XOR<PayrollEntryCreateInput, PayrollEntryUncheckedCreateInput>
    /**
     * In case the PayrollEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollEntryUpdateInput, PayrollEntryUncheckedUpdateInput>
  }

  /**
   * PayrollEntry delete
   */
  export type PayrollEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter which PayrollEntry to delete.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry deleteMany
   */
  export type PayrollEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollEntries to delete
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to delete.
     */
    limit?: number
  }

  /**
   * PayrollEntry without action
   */
  export type PayrollEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
  }


  /**
   * Model Reminder
   */

  export type AggregateReminder = {
    _count: ReminderCountAggregateOutputType | null
    _min: ReminderMinAggregateOutputType | null
    _max: ReminderMaxAggregateOutputType | null
  }

  export type ReminderMinAggregateOutputType = {
    id: string | null
    type: $Enums.ReminderType | null
    dueAt: Date | null
    status: $Enums.ReminderStatus | null
    createdByUserId: string | null
    createdAt: Date | null
    doneAt: Date | null
  }

  export type ReminderMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ReminderType | null
    dueAt: Date | null
    status: $Enums.ReminderStatus | null
    createdByUserId: string | null
    createdAt: Date | null
    doneAt: Date | null
  }

  export type ReminderCountAggregateOutputType = {
    id: number
    type: number
    dueAt: number
    status: number
    payload: number
    createdByUserId: number
    createdAt: number
    doneAt: number
    _all: number
  }


  export type ReminderMinAggregateInputType = {
    id?: true
    type?: true
    dueAt?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    doneAt?: true
  }

  export type ReminderMaxAggregateInputType = {
    id?: true
    type?: true
    dueAt?: true
    status?: true
    createdByUserId?: true
    createdAt?: true
    doneAt?: true
  }

  export type ReminderCountAggregateInputType = {
    id?: true
    type?: true
    dueAt?: true
    status?: true
    payload?: true
    createdByUserId?: true
    createdAt?: true
    doneAt?: true
    _all?: true
  }

  export type ReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reminder to aggregate.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reminders
    **/
    _count?: true | ReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReminderMaxAggregateInputType
  }

  export type GetReminderAggregateType<T extends ReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminder[P]>
      : GetScalarType<T[P], AggregateReminder[P]>
  }




  export type ReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderWhereInput
    orderBy?: ReminderOrderByWithAggregationInput | ReminderOrderByWithAggregationInput[]
    by: ReminderScalarFieldEnum[] | ReminderScalarFieldEnum
    having?: ReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReminderCountAggregateInputType | true
    _min?: ReminderMinAggregateInputType
    _max?: ReminderMaxAggregateInputType
  }

  export type ReminderGroupByOutputType = {
    id: string
    type: $Enums.ReminderType
    dueAt: Date
    status: $Enums.ReminderStatus
    payload: JsonValue
    createdByUserId: string | null
    createdAt: Date
    doneAt: Date | null
    _count: ReminderCountAggregateOutputType | null
    _min: ReminderMinAggregateOutputType | null
    _max: ReminderMaxAggregateOutputType | null
  }

  type GetReminderGroupByPayload<T extends ReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReminderGroupByOutputType[P]>
            : GetScalarType<T[P], ReminderGroupByOutputType[P]>
        }
      >
    >


  export type ReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    dueAt?: boolean
    status?: boolean
    payload?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    doneAt?: boolean
    createdBy?: boolean | Reminder$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    dueAt?: boolean
    status?: boolean
    payload?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    doneAt?: boolean
    createdBy?: boolean | Reminder$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    dueAt?: boolean
    status?: boolean
    payload?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    doneAt?: boolean
    createdBy?: boolean | Reminder$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["reminder"]>

  export type ReminderSelectScalar = {
    id?: boolean
    type?: boolean
    dueAt?: boolean
    status?: boolean
    payload?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    doneAt?: boolean
  }

  export type ReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "dueAt" | "status" | "payload" | "createdByUserId" | "createdAt" | "doneAt", ExtArgs["result"]["reminder"]>
  export type ReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Reminder$createdByArgs<ExtArgs>
  }
  export type ReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Reminder$createdByArgs<ExtArgs>
  }
  export type ReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Reminder$createdByArgs<ExtArgs>
  }

  export type $ReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reminder"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ReminderType
      dueAt: Date
      status: $Enums.ReminderStatus
      payload: Prisma.JsonValue
      createdByUserId: string | null
      createdAt: Date
      doneAt: Date | null
    }, ExtArgs["result"]["reminder"]>
    composites: {}
  }

  type ReminderGetPayload<S extends boolean | null | undefined | ReminderDefaultArgs> = $Result.GetResult<Prisma.$ReminderPayload, S>

  type ReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReminderCountAggregateInputType | true
    }

  export interface ReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reminder'], meta: { name: 'Reminder' } }
    /**
     * Find zero or one Reminder that matches the filter.
     * @param {ReminderFindUniqueArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReminderFindUniqueArgs>(args: SelectSubset<T, ReminderFindUniqueArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReminderFindUniqueOrThrowArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, ReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindFirstArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReminderFindFirstArgs>(args?: SelectSubset<T, ReminderFindFirstArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindFirstOrThrowArgs} args - Arguments to find a Reminder
     * @example
     * // Get one Reminder
     * const reminder = await prisma.reminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, ReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reminders
     * const reminders = await prisma.reminder.findMany()
     * 
     * // Get first 10 Reminders
     * const reminders = await prisma.reminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reminderWithIdOnly = await prisma.reminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReminderFindManyArgs>(args?: SelectSubset<T, ReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reminder.
     * @param {ReminderCreateArgs} args - Arguments to create a Reminder.
     * @example
     * // Create one Reminder
     * const Reminder = await prisma.reminder.create({
     *   data: {
     *     // ... data to create a Reminder
     *   }
     * })
     * 
     */
    create<T extends ReminderCreateArgs>(args: SelectSubset<T, ReminderCreateArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reminders.
     * @param {ReminderCreateManyArgs} args - Arguments to create many Reminders.
     * @example
     * // Create many Reminders
     * const reminder = await prisma.reminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReminderCreateManyArgs>(args?: SelectSubset<T, ReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reminders and returns the data saved in the database.
     * @param {ReminderCreateManyAndReturnArgs} args - Arguments to create many Reminders.
     * @example
     * // Create many Reminders
     * const reminder = await prisma.reminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reminders and only return the `id`
     * const reminderWithIdOnly = await prisma.reminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, ReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reminder.
     * @param {ReminderDeleteArgs} args - Arguments to delete one Reminder.
     * @example
     * // Delete one Reminder
     * const Reminder = await prisma.reminder.delete({
     *   where: {
     *     // ... filter to delete one Reminder
     *   }
     * })
     * 
     */
    delete<T extends ReminderDeleteArgs>(args: SelectSubset<T, ReminderDeleteArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reminder.
     * @param {ReminderUpdateArgs} args - Arguments to update one Reminder.
     * @example
     * // Update one Reminder
     * const reminder = await prisma.reminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReminderUpdateArgs>(args: SelectSubset<T, ReminderUpdateArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reminders.
     * @param {ReminderDeleteManyArgs} args - Arguments to filter Reminders to delete.
     * @example
     * // Delete a few Reminders
     * const { count } = await prisma.reminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReminderDeleteManyArgs>(args?: SelectSubset<T, ReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reminders
     * const reminder = await prisma.reminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReminderUpdateManyArgs>(args: SelectSubset<T, ReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reminders and returns the data updated in the database.
     * @param {ReminderUpdateManyAndReturnArgs} args - Arguments to update many Reminders.
     * @example
     * // Update many Reminders
     * const reminder = await prisma.reminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reminders and only return the `id`
     * const reminderWithIdOnly = await prisma.reminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, ReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reminder.
     * @param {ReminderUpsertArgs} args - Arguments to update or create a Reminder.
     * @example
     * // Update or create a Reminder
     * const reminder = await prisma.reminder.upsert({
     *   create: {
     *     // ... data to create a Reminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reminder we want to update
     *   }
     * })
     */
    upsert<T extends ReminderUpsertArgs>(args: SelectSubset<T, ReminderUpsertArgs<ExtArgs>>): Prisma__ReminderClient<$Result.GetResult<Prisma.$ReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderCountArgs} args - Arguments to filter Reminders to count.
     * @example
     * // Count the number of Reminders
     * const count = await prisma.reminder.count({
     *   where: {
     *     // ... the filter for the Reminders we want to count
     *   }
     * })
    **/
    count<T extends ReminderCountArgs>(
      args?: Subset<T, ReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReminderAggregateArgs>(args: Subset<T, ReminderAggregateArgs>): Prisma.PrismaPromise<GetReminderAggregateType<T>>

    /**
     * Group by Reminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReminderGroupByArgs['orderBy'] }
        : { orderBy?: ReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reminder model
   */
  readonly fields: ReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Reminder$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Reminder$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reminder model
   */
  interface ReminderFieldRefs {
    readonly id: FieldRef<"Reminder", 'String'>
    readonly type: FieldRef<"Reminder", 'ReminderType'>
    readonly dueAt: FieldRef<"Reminder", 'DateTime'>
    readonly status: FieldRef<"Reminder", 'ReminderStatus'>
    readonly payload: FieldRef<"Reminder", 'Json'>
    readonly createdByUserId: FieldRef<"Reminder", 'String'>
    readonly createdAt: FieldRef<"Reminder", 'DateTime'>
    readonly doneAt: FieldRef<"Reminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reminder findUnique
   */
  export type ReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder findUniqueOrThrow
   */
  export type ReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder findFirst
   */
  export type ReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reminders.
     */
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder findFirstOrThrow
   */
  export type ReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminder to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reminders.
     */
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder findMany
   */
  export type ReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter, which Reminders to fetch.
     */
    where?: ReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reminders to fetch.
     */
    orderBy?: ReminderOrderByWithRelationInput | ReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reminders.
     */
    cursor?: ReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reminders.
     */
    skip?: number
    distinct?: ReminderScalarFieldEnum | ReminderScalarFieldEnum[]
  }

  /**
   * Reminder create
   */
  export type ReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a Reminder.
     */
    data: XOR<ReminderCreateInput, ReminderUncheckedCreateInput>
  }

  /**
   * Reminder createMany
   */
  export type ReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reminders.
     */
    data: ReminderCreateManyInput | ReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reminder createManyAndReturn
   */
  export type ReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * The data used to create many Reminders.
     */
    data: ReminderCreateManyInput | ReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reminder update
   */
  export type ReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a Reminder.
     */
    data: XOR<ReminderUpdateInput, ReminderUncheckedUpdateInput>
    /**
     * Choose, which Reminder to update.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder updateMany
   */
  export type ReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reminders.
     */
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyInput>
    /**
     * Filter which Reminders to update
     */
    where?: ReminderWhereInput
    /**
     * Limit how many Reminders to update.
     */
    limit?: number
  }

  /**
   * Reminder updateManyAndReturn
   */
  export type ReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * The data used to update Reminders.
     */
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyInput>
    /**
     * Filter which Reminders to update
     */
    where?: ReminderWhereInput
    /**
     * Limit how many Reminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reminder upsert
   */
  export type ReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the Reminder to update in case it exists.
     */
    where: ReminderWhereUniqueInput
    /**
     * In case the Reminder found by the `where` argument doesn't exist, create a new Reminder with this data.
     */
    create: XOR<ReminderCreateInput, ReminderUncheckedCreateInput>
    /**
     * In case the Reminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReminderUpdateInput, ReminderUncheckedUpdateInput>
  }

  /**
   * Reminder delete
   */
  export type ReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
    /**
     * Filter which Reminder to delete.
     */
    where: ReminderWhereUniqueInput
  }

  /**
   * Reminder deleteMany
   */
  export type ReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reminders to delete
     */
    where?: ReminderWhereInput
    /**
     * Limit how many Reminders to delete.
     */
    limit?: number
  }

  /**
   * Reminder.createdBy
   */
  export type Reminder$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Reminder without action
   */
  export type ReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reminder
     */
    select?: ReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reminder
     */
    omit?: ReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorUserId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorUserId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorUserId: number
    action: number
    entityType: number
    entityId: number
    meta: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorUserId: string | null
    action: string
    entityType: string
    entityId: string | null
    meta: JsonValue
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorUserId" | "action" | "entityType" | "entityId" | "meta" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorUserId: string | null
      action: string
      entityType: string
      entityId: string | null
      meta: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorUserId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly meta: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const KitchenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    address: 'address',
    lat: 'lat',
    lng: 'lng',
    geofenceRadiusMeters: 'geofenceRadiusMeters',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KitchenScalarFieldEnum = (typeof KitchenScalarFieldEnum)[keyof typeof KitchenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    kitchenId: 'kitchenId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeProfileScalarFieldEnum: {
    userId: 'userId',
    fullName: 'fullName',
    baseSalaryMonthly: 'baseSalaryMonthly',
    overtimeRatePerHour: 'overtimeRatePerHour',
    latePenaltyPerMinute: 'latePenaltyPerMinute',
    joinDate: 'joinDate'
  };

  export type EmployeeProfileScalarFieldEnum = (typeof EmployeeProfileScalarFieldEnum)[keyof typeof EmployeeProfileScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    uom: 'uom',
    reorderPoint: 'reorderPoint',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const KitchenStockScalarFieldEnum: {
    kitchenId: 'kitchenId',
    itemId: 'itemId',
    onHandQty: 'onHandQty',
    avgCost: 'avgCost',
    updatedAt: 'updatedAt'
  };

  export type KitchenStockScalarFieldEnum = (typeof KitchenStockScalarFieldEnum)[keyof typeof KitchenStockScalarFieldEnum]


  export const StockLedgerScalarFieldEnum: {
    id: 'id',
    kitchenId: 'kitchenId',
    itemId: 'itemId',
    type: 'type',
    qtyDelta: 'qtyDelta',
    unitCost: 'unitCost',
    refType: 'refType',
    refId: 'refId',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt'
  };

  export type StockLedgerScalarFieldEnum = (typeof StockLedgerScalarFieldEnum)[keyof typeof StockLedgerScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    kitchenId: 'kitchenId',
    supplierId: 'supplierId',
    status: 'status',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseLineScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    itemId: 'itemId',
    qty: 'qty',
    unitCost: 'unitCost'
  };

  export type PurchaseLineScalarFieldEnum = (typeof PurchaseLineScalarFieldEnum)[keyof typeof PurchaseLineScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    fromKitchenId: 'fromKitchenId',
    toKitchenId: 'toKitchenId',
    status: 'status',
    requestedByUserId: 'requestedByUserId',
    approvedByUserId: 'approvedByUserId',
    dispatchedByUserId: 'dispatchedByUserId',
    receivedByUserId: 'receivedByUserId',
    requestedAt: 'requestedAt',
    approvedAt: 'approvedAt',
    dispatchedAt: 'dispatchedAt',
    receivedAt: 'receivedAt',
    cancelledAt: 'cancelledAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const TransferLineScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    itemId: 'itemId',
    qty: 'qty'
  };

  export type TransferLineScalarFieldEnum = (typeof TransferLineScalarFieldEnum)[keyof typeof TransferLineScalarFieldEnum]


  export const AttendanceEventScalarFieldEnum: {
    id: 'id',
    employeeUserId: 'employeeUserId',
    kitchenId: 'kitchenId',
    type: 'type',
    method: 'method',
    lat: 'lat',
    lng: 'lng',
    distanceMeters: 'distanceMeters',
    createdAt: 'createdAt'
  };

  export type AttendanceEventScalarFieldEnum = (typeof AttendanceEventScalarFieldEnum)[keyof typeof AttendanceEventScalarFieldEnum]


  export const ShiftDaySummaryScalarFieldEnum: {
    id: 'id',
    employeeUserId: 'employeeUserId',
    kitchenId: 'kitchenId',
    date: 'date',
    minutesWorked: 'minutesWorked',
    minutesLate: 'minutesLate',
    overtimeMinutes: 'overtimeMinutes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftDaySummaryScalarFieldEnum = (typeof ShiftDaySummaryScalarFieldEnum)[keyof typeof ShiftDaySummaryScalarFieldEnum]


  export const PayrollPeriodScalarFieldEnum: {
    id: 'id',
    month: 'month',
    status: 'status',
    generatedAt: 'generatedAt'
  };

  export type PayrollPeriodScalarFieldEnum = (typeof PayrollPeriodScalarFieldEnum)[keyof typeof PayrollPeriodScalarFieldEnum]


  export const PayrollEntryScalarFieldEnum: {
    id: 'id',
    periodId: 'periodId',
    employeeUserId: 'employeeUserId',
    computedSalary: 'computedSalary',
    overtimePay: 'overtimePay',
    deductions: 'deductions',
    netPay: 'netPay',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollEntryScalarFieldEnum = (typeof PayrollEntryScalarFieldEnum)[keyof typeof PayrollEntryScalarFieldEnum]


  export const ReminderScalarFieldEnum: {
    id: 'id',
    type: 'type',
    dueAt: 'dueAt',
    status: 'status',
    payload: 'payload',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    doneAt: 'doneAt'
  };

  export type ReminderScalarFieldEnum = (typeof ReminderScalarFieldEnum)[keyof typeof ReminderScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorUserId: 'actorUserId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'KitchenType'
   */
  export type EnumKitchenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KitchenType'>
    


  /**
   * Reference to a field of type 'KitchenType[]'
   */
  export type ListEnumKitchenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KitchenType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StockLedgerType'
   */
  export type EnumStockLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockLedgerType'>
    


  /**
   * Reference to a field of type 'StockLedgerType[]'
   */
  export type ListEnumStockLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockLedgerType[]'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'AttendanceType'
   */
  export type EnumAttendanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceType'>
    


  /**
   * Reference to a field of type 'AttendanceType[]'
   */
  export type ListEnumAttendanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceType[]'>
    


  /**
   * Reference to a field of type 'AttendanceMethod'
   */
  export type EnumAttendanceMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceMethod'>
    


  /**
   * Reference to a field of type 'AttendanceMethod[]'
   */
  export type ListEnumAttendanceMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceMethod[]'>
    


  /**
   * Reference to a field of type 'PayrollPeriodStatus'
   */
  export type EnumPayrollPeriodStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollPeriodStatus'>
    


  /**
   * Reference to a field of type 'PayrollPeriodStatus[]'
   */
  export type ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollPeriodStatus[]'>
    


  /**
   * Reference to a field of type 'ReminderType'
   */
  export type EnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType'>
    


  /**
   * Reference to a field of type 'ReminderType[]'
   */
  export type ListEnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType[]'>
    


  /**
   * Reference to a field of type 'ReminderStatus'
   */
  export type EnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus'>
    


  /**
   * Reference to a field of type 'ReminderStatus[]'
   */
  export type ListEnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type KitchenWhereInput = {
    AND?: KitchenWhereInput | KitchenWhereInput[]
    OR?: KitchenWhereInput[]
    NOT?: KitchenWhereInput | KitchenWhereInput[]
    id?: StringFilter<"Kitchen"> | string
    name?: StringFilter<"Kitchen"> | string
    type?: EnumKitchenTypeFilter<"Kitchen"> | $Enums.KitchenType
    address?: StringNullableFilter<"Kitchen"> | string | null
    lat?: FloatNullableFilter<"Kitchen"> | number | null
    lng?: FloatNullableFilter<"Kitchen"> | number | null
    geofenceRadiusMeters?: IntFilter<"Kitchen"> | number
    createdAt?: DateTimeFilter<"Kitchen"> | Date | string
    updatedAt?: DateTimeFilter<"Kitchen"> | Date | string
    users?: UserListRelationFilter
    stocks?: KitchenStockListRelationFilter
    ledger?: StockLedgerListRelationFilter
    purchases?: PurchaseOrderListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    shiftSummaries?: ShiftDaySummaryListRelationFilter
  }

  export type KitchenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    geofenceRadiusMeters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    stocks?: KitchenStockOrderByRelationAggregateInput
    ledger?: StockLedgerOrderByRelationAggregateInput
    purchases?: PurchaseOrderOrderByRelationAggregateInput
    transfersFrom?: TransferOrderByRelationAggregateInput
    transfersTo?: TransferOrderByRelationAggregateInput
    attendanceEvents?: AttendanceEventOrderByRelationAggregateInput
    shiftSummaries?: ShiftDaySummaryOrderByRelationAggregateInput
  }

  export type KitchenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KitchenWhereInput | KitchenWhereInput[]
    OR?: KitchenWhereInput[]
    NOT?: KitchenWhereInput | KitchenWhereInput[]
    name?: StringFilter<"Kitchen"> | string
    type?: EnumKitchenTypeFilter<"Kitchen"> | $Enums.KitchenType
    address?: StringNullableFilter<"Kitchen"> | string | null
    lat?: FloatNullableFilter<"Kitchen"> | number | null
    lng?: FloatNullableFilter<"Kitchen"> | number | null
    geofenceRadiusMeters?: IntFilter<"Kitchen"> | number
    createdAt?: DateTimeFilter<"Kitchen"> | Date | string
    updatedAt?: DateTimeFilter<"Kitchen"> | Date | string
    users?: UserListRelationFilter
    stocks?: KitchenStockListRelationFilter
    ledger?: StockLedgerListRelationFilter
    purchases?: PurchaseOrderListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    shiftSummaries?: ShiftDaySummaryListRelationFilter
  }, "id">

  export type KitchenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    geofenceRadiusMeters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KitchenCountOrderByAggregateInput
    _avg?: KitchenAvgOrderByAggregateInput
    _max?: KitchenMaxOrderByAggregateInput
    _min?: KitchenMinOrderByAggregateInput
    _sum?: KitchenSumOrderByAggregateInput
  }

  export type KitchenScalarWhereWithAggregatesInput = {
    AND?: KitchenScalarWhereWithAggregatesInput | KitchenScalarWhereWithAggregatesInput[]
    OR?: KitchenScalarWhereWithAggregatesInput[]
    NOT?: KitchenScalarWhereWithAggregatesInput | KitchenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Kitchen"> | string
    name?: StringWithAggregatesFilter<"Kitchen"> | string
    type?: EnumKitchenTypeWithAggregatesFilter<"Kitchen"> | $Enums.KitchenType
    address?: StringNullableWithAggregatesFilter<"Kitchen"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"Kitchen"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"Kitchen"> | number | null
    geofenceRadiusMeters?: IntWithAggregatesFilter<"Kitchen"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Kitchen"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kitchen"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    kitchenId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    kitchen?: XOR<KitchenNullableScalarRelationFilter, KitchenWhereInput> | null
    employeeProfile?: XOR<EmployeeProfileNullableScalarRelationFilter, EmployeeProfileWhereInput> | null
    createdLedgerEntries?: StockLedgerListRelationFilter
    requestedTransfers?: TransferListRelationFilter
    approvedTransfers?: TransferListRelationFilter
    dispatchedTransfers?: TransferListRelationFilter
    receivedTransfers?: TransferListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    shiftSummaries?: ShiftDaySummaryListRelationFilter
    payrollEntries?: PayrollEntryListRelationFilter
    remindersCreated?: ReminderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    kitchenId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kitchen?: KitchenOrderByWithRelationInput
    employeeProfile?: EmployeeProfileOrderByWithRelationInput
    createdLedgerEntries?: StockLedgerOrderByRelationAggregateInput
    requestedTransfers?: TransferOrderByRelationAggregateInput
    approvedTransfers?: TransferOrderByRelationAggregateInput
    dispatchedTransfers?: TransferOrderByRelationAggregateInput
    receivedTransfers?: TransferOrderByRelationAggregateInput
    attendanceEvents?: AttendanceEventOrderByRelationAggregateInput
    shiftSummaries?: ShiftDaySummaryOrderByRelationAggregateInput
    payrollEntries?: PayrollEntryOrderByRelationAggregateInput
    remindersCreated?: ReminderOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    kitchenId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    kitchen?: XOR<KitchenNullableScalarRelationFilter, KitchenWhereInput> | null
    employeeProfile?: XOR<EmployeeProfileNullableScalarRelationFilter, EmployeeProfileWhereInput> | null
    createdLedgerEntries?: StockLedgerListRelationFilter
    requestedTransfers?: TransferListRelationFilter
    approvedTransfers?: TransferListRelationFilter
    dispatchedTransfers?: TransferListRelationFilter
    receivedTransfers?: TransferListRelationFilter
    attendanceEvents?: AttendanceEventListRelationFilter
    shiftSummaries?: ShiftDaySummaryListRelationFilter
    payrollEntries?: PayrollEntryListRelationFilter
    remindersCreated?: ReminderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    kitchenId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    kitchenId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EmployeeProfileWhereInput = {
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    userId?: StringFilter<"EmployeeProfile"> | string
    fullName?: StringFilter<"EmployeeProfile"> | string
    baseSalaryMonthly?: IntFilter<"EmployeeProfile"> | number
    overtimeRatePerHour?: IntFilter<"EmployeeProfile"> | number
    latePenaltyPerMinute?: IntFilter<"EmployeeProfile"> | number
    joinDate?: DateTimeFilter<"EmployeeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmployeeProfileOrderByWithRelationInput = {
    userId?: SortOrder
    fullName?: SortOrder
    baseSalaryMonthly?: SortOrder
    overtimeRatePerHour?: SortOrder
    latePenaltyPerMinute?: SortOrder
    joinDate?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmployeeProfileWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    fullName?: StringFilter<"EmployeeProfile"> | string
    baseSalaryMonthly?: IntFilter<"EmployeeProfile"> | number
    overtimeRatePerHour?: IntFilter<"EmployeeProfile"> | number
    latePenaltyPerMinute?: IntFilter<"EmployeeProfile"> | number
    joinDate?: DateTimeFilter<"EmployeeProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type EmployeeProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    fullName?: SortOrder
    baseSalaryMonthly?: SortOrder
    overtimeRatePerHour?: SortOrder
    latePenaltyPerMinute?: SortOrder
    joinDate?: SortOrder
    _count?: EmployeeProfileCountOrderByAggregateInput
    _avg?: EmployeeProfileAvgOrderByAggregateInput
    _max?: EmployeeProfileMaxOrderByAggregateInput
    _min?: EmployeeProfileMinOrderByAggregateInput
    _sum?: EmployeeProfileSumOrderByAggregateInput
  }

  export type EmployeeProfileScalarWhereWithAggregatesInput = {
    AND?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    OR?: EmployeeProfileScalarWhereWithAggregatesInput[]
    NOT?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"EmployeeProfile"> | string
    fullName?: StringWithAggregatesFilter<"EmployeeProfile"> | string
    baseSalaryMonthly?: IntWithAggregatesFilter<"EmployeeProfile"> | number
    overtimeRatePerHour?: IntWithAggregatesFilter<"EmployeeProfile"> | number
    latePenaltyPerMinute?: IntWithAggregatesFilter<"EmployeeProfile"> | number
    joinDate?: DateTimeWithAggregatesFilter<"EmployeeProfile"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contact?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contact?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contact?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    category?: StringNullableFilter<"Item"> | string | null
    uom?: StringFilter<"Item"> | string
    reorderPoint?: FloatFilter<"Item"> | number
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    stocks?: KitchenStockListRelationFilter
    ledger?: StockLedgerListRelationFilter
    purchaseLines?: PurchaseLineListRelationFilter
    transferLines?: TransferLineListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    uom?: SortOrder
    reorderPoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stocks?: KitchenStockOrderByRelationAggregateInput
    ledger?: StockLedgerOrderByRelationAggregateInput
    purchaseLines?: PurchaseLineOrderByRelationAggregateInput
    transferLines?: TransferLineOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_uom?: ItemNameUomCompoundUniqueInput
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    category?: StringNullableFilter<"Item"> | string | null
    uom?: StringFilter<"Item"> | string
    reorderPoint?: FloatFilter<"Item"> | number
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    stocks?: KitchenStockListRelationFilter
    ledger?: StockLedgerListRelationFilter
    purchaseLines?: PurchaseLineListRelationFilter
    transferLines?: TransferLineListRelationFilter
  }, "id" | "name_uom">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    uom?: SortOrder
    reorderPoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    category?: StringNullableWithAggregatesFilter<"Item"> | string | null
    uom?: StringWithAggregatesFilter<"Item"> | string
    reorderPoint?: FloatWithAggregatesFilter<"Item"> | number
    isActive?: BoolWithAggregatesFilter<"Item"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type KitchenStockWhereInput = {
    AND?: KitchenStockWhereInput | KitchenStockWhereInput[]
    OR?: KitchenStockWhereInput[]
    NOT?: KitchenStockWhereInput | KitchenStockWhereInput[]
    kitchenId?: StringFilter<"KitchenStock"> | string
    itemId?: StringFilter<"KitchenStock"> | string
    onHandQty?: FloatFilter<"KitchenStock"> | number
    avgCost?: FloatFilter<"KitchenStock"> | number
    updatedAt?: DateTimeFilter<"KitchenStock"> | Date | string
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type KitchenStockOrderByWithRelationInput = {
    kitchenId?: SortOrder
    itemId?: SortOrder
    onHandQty?: SortOrder
    avgCost?: SortOrder
    updatedAt?: SortOrder
    kitchen?: KitchenOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type KitchenStockWhereUniqueInput = Prisma.AtLeast<{
    kitchenId_itemId?: KitchenStockKitchenIdItemIdCompoundUniqueInput
    AND?: KitchenStockWhereInput | KitchenStockWhereInput[]
    OR?: KitchenStockWhereInput[]
    NOT?: KitchenStockWhereInput | KitchenStockWhereInput[]
    kitchenId?: StringFilter<"KitchenStock"> | string
    itemId?: StringFilter<"KitchenStock"> | string
    onHandQty?: FloatFilter<"KitchenStock"> | number
    avgCost?: FloatFilter<"KitchenStock"> | number
    updatedAt?: DateTimeFilter<"KitchenStock"> | Date | string
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "kitchenId_itemId">

  export type KitchenStockOrderByWithAggregationInput = {
    kitchenId?: SortOrder
    itemId?: SortOrder
    onHandQty?: SortOrder
    avgCost?: SortOrder
    updatedAt?: SortOrder
    _count?: KitchenStockCountOrderByAggregateInput
    _avg?: KitchenStockAvgOrderByAggregateInput
    _max?: KitchenStockMaxOrderByAggregateInput
    _min?: KitchenStockMinOrderByAggregateInput
    _sum?: KitchenStockSumOrderByAggregateInput
  }

  export type KitchenStockScalarWhereWithAggregatesInput = {
    AND?: KitchenStockScalarWhereWithAggregatesInput | KitchenStockScalarWhereWithAggregatesInput[]
    OR?: KitchenStockScalarWhereWithAggregatesInput[]
    NOT?: KitchenStockScalarWhereWithAggregatesInput | KitchenStockScalarWhereWithAggregatesInput[]
    kitchenId?: StringWithAggregatesFilter<"KitchenStock"> | string
    itemId?: StringWithAggregatesFilter<"KitchenStock"> | string
    onHandQty?: FloatWithAggregatesFilter<"KitchenStock"> | number
    avgCost?: FloatWithAggregatesFilter<"KitchenStock"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"KitchenStock"> | Date | string
  }

  export type StockLedgerWhereInput = {
    AND?: StockLedgerWhereInput | StockLedgerWhereInput[]
    OR?: StockLedgerWhereInput[]
    NOT?: StockLedgerWhereInput | StockLedgerWhereInput[]
    id?: StringFilter<"StockLedger"> | string
    kitchenId?: StringFilter<"StockLedger"> | string
    itemId?: StringFilter<"StockLedger"> | string
    type?: EnumStockLedgerTypeFilter<"StockLedger"> | $Enums.StockLedgerType
    qtyDelta?: FloatFilter<"StockLedger"> | number
    unitCost?: FloatNullableFilter<"StockLedger"> | number | null
    refType?: StringNullableFilter<"StockLedger"> | string | null
    refId?: StringNullableFilter<"StockLedger"> | string | null
    createdByUserId?: StringNullableFilter<"StockLedger"> | string | null
    createdAt?: DateTimeFilter<"StockLedger"> | Date | string
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StockLedgerOrderByWithRelationInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qtyDelta?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    kitchen?: KitchenOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type StockLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockLedgerWhereInput | StockLedgerWhereInput[]
    OR?: StockLedgerWhereInput[]
    NOT?: StockLedgerWhereInput | StockLedgerWhereInput[]
    kitchenId?: StringFilter<"StockLedger"> | string
    itemId?: StringFilter<"StockLedger"> | string
    type?: EnumStockLedgerTypeFilter<"StockLedger"> | $Enums.StockLedgerType
    qtyDelta?: FloatFilter<"StockLedger"> | number
    unitCost?: FloatNullableFilter<"StockLedger"> | number | null
    refType?: StringNullableFilter<"StockLedger"> | string | null
    refId?: StringNullableFilter<"StockLedger"> | string | null
    createdByUserId?: StringNullableFilter<"StockLedger"> | string | null
    createdAt?: DateTimeFilter<"StockLedger"> | Date | string
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type StockLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qtyDelta?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockLedgerCountOrderByAggregateInput
    _avg?: StockLedgerAvgOrderByAggregateInput
    _max?: StockLedgerMaxOrderByAggregateInput
    _min?: StockLedgerMinOrderByAggregateInput
    _sum?: StockLedgerSumOrderByAggregateInput
  }

  export type StockLedgerScalarWhereWithAggregatesInput = {
    AND?: StockLedgerScalarWhereWithAggregatesInput | StockLedgerScalarWhereWithAggregatesInput[]
    OR?: StockLedgerScalarWhereWithAggregatesInput[]
    NOT?: StockLedgerScalarWhereWithAggregatesInput | StockLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockLedger"> | string
    kitchenId?: StringWithAggregatesFilter<"StockLedger"> | string
    itemId?: StringWithAggregatesFilter<"StockLedger"> | string
    type?: EnumStockLedgerTypeWithAggregatesFilter<"StockLedger"> | $Enums.StockLedgerType
    qtyDelta?: FloatWithAggregatesFilter<"StockLedger"> | number
    unitCost?: FloatNullableWithAggregatesFilter<"StockLedger"> | number | null
    refType?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    refId?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"StockLedger"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockLedger"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    kitchenId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringNullableFilter<"PurchaseOrder"> | string | null
    status?: StringFilter<"PurchaseOrder"> | string
    createdByUserId?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    lines?: PurchaseLineListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kitchen?: KitchenOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    lines?: PurchaseLineOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    kitchenId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringNullableFilter<"PurchaseOrder"> | string | null
    status?: StringFilter<"PurchaseOrder"> | string
    createdByUserId?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    lines?: PurchaseLineListRelationFilter
  }, "id">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    kitchenId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplierId?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    status?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    createdByUserId?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseLineWhereInput = {
    AND?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    OR?: PurchaseLineWhereInput[]
    NOT?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    id?: StringFilter<"PurchaseLine"> | string
    purchaseOrderId?: StringFilter<"PurchaseLine"> | string
    itemId?: StringFilter<"PurchaseLine"> | string
    qty?: FloatFilter<"PurchaseLine"> | number
    unitCost?: FloatFilter<"PurchaseLine"> | number
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type PurchaseLineOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type PurchaseLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    OR?: PurchaseLineWhereInput[]
    NOT?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    purchaseOrderId?: StringFilter<"PurchaseLine"> | string
    itemId?: StringFilter<"PurchaseLine"> | string
    qty?: FloatFilter<"PurchaseLine"> | number
    unitCost?: FloatFilter<"PurchaseLine"> | number
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type PurchaseLineOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
    _count?: PurchaseLineCountOrderByAggregateInput
    _avg?: PurchaseLineAvgOrderByAggregateInput
    _max?: PurchaseLineMaxOrderByAggregateInput
    _min?: PurchaseLineMinOrderByAggregateInput
    _sum?: PurchaseLineSumOrderByAggregateInput
  }

  export type PurchaseLineScalarWhereWithAggregatesInput = {
    AND?: PurchaseLineScalarWhereWithAggregatesInput | PurchaseLineScalarWhereWithAggregatesInput[]
    OR?: PurchaseLineScalarWhereWithAggregatesInput[]
    NOT?: PurchaseLineScalarWhereWithAggregatesInput | PurchaseLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseLine"> | string
    purchaseOrderId?: StringWithAggregatesFilter<"PurchaseLine"> | string
    itemId?: StringWithAggregatesFilter<"PurchaseLine"> | string
    qty?: FloatWithAggregatesFilter<"PurchaseLine"> | number
    unitCost?: FloatWithAggregatesFilter<"PurchaseLine"> | number
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    fromKitchenId?: StringFilter<"Transfer"> | string
    toKitchenId?: StringFilter<"Transfer"> | string
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    requestedByUserId?: StringNullableFilter<"Transfer"> | string | null
    approvedByUserId?: StringNullableFilter<"Transfer"> | string | null
    dispatchedByUserId?: StringNullableFilter<"Transfer"> | string | null
    receivedByUserId?: StringNullableFilter<"Transfer"> | string | null
    requestedAt?: DateTimeFilter<"Transfer"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    fromKitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    toKitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    lines?: TransferLineListRelationFilter
    requestedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    dispatchedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    receivedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    fromKitchenId?: SortOrder
    toKitchenId?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrderInput | SortOrder
    approvedByUserId?: SortOrderInput | SortOrder
    dispatchedByUserId?: SortOrderInput | SortOrder
    receivedByUserId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    fromKitchen?: KitchenOrderByWithRelationInput
    toKitchen?: KitchenOrderByWithRelationInput
    lines?: TransferLineOrderByRelationAggregateInput
    requestedBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    dispatchedBy?: UserOrderByWithRelationInput
    receivedBy?: UserOrderByWithRelationInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    fromKitchenId?: StringFilter<"Transfer"> | string
    toKitchenId?: StringFilter<"Transfer"> | string
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    requestedByUserId?: StringNullableFilter<"Transfer"> | string | null
    approvedByUserId?: StringNullableFilter<"Transfer"> | string | null
    dispatchedByUserId?: StringNullableFilter<"Transfer"> | string | null
    receivedByUserId?: StringNullableFilter<"Transfer"> | string | null
    requestedAt?: DateTimeFilter<"Transfer"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    fromKitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    toKitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
    lines?: TransferLineListRelationFilter
    requestedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    dispatchedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    receivedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    fromKitchenId?: SortOrder
    toKitchenId?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrderInput | SortOrder
    approvedByUserId?: SortOrderInput | SortOrder
    dispatchedByUserId?: SortOrderInput | SortOrder
    receivedByUserId?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    _count?: TransferCountOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    fromKitchenId?: StringWithAggregatesFilter<"Transfer"> | string
    toKitchenId?: StringWithAggregatesFilter<"Transfer"> | string
    status?: EnumTransferStatusWithAggregatesFilter<"Transfer"> | $Enums.TransferStatus
    requestedByUserId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    approvedByUserId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    dispatchedByUserId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    receivedByUserId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    dispatchedAt?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    receivedAt?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
  }

  export type TransferLineWhereInput = {
    AND?: TransferLineWhereInput | TransferLineWhereInput[]
    OR?: TransferLineWhereInput[]
    NOT?: TransferLineWhereInput | TransferLineWhereInput[]
    id?: StringFilter<"TransferLine"> | string
    transferId?: StringFilter<"TransferLine"> | string
    itemId?: StringFilter<"TransferLine"> | string
    qty?: FloatFilter<"TransferLine"> | number
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type TransferLineOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    transfer?: TransferOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type TransferLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferLineWhereInput | TransferLineWhereInput[]
    OR?: TransferLineWhereInput[]
    NOT?: TransferLineWhereInput | TransferLineWhereInput[]
    transferId?: StringFilter<"TransferLine"> | string
    itemId?: StringFilter<"TransferLine"> | string
    qty?: FloatFilter<"TransferLine"> | number
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type TransferLineOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    _count?: TransferLineCountOrderByAggregateInput
    _avg?: TransferLineAvgOrderByAggregateInput
    _max?: TransferLineMaxOrderByAggregateInput
    _min?: TransferLineMinOrderByAggregateInput
    _sum?: TransferLineSumOrderByAggregateInput
  }

  export type TransferLineScalarWhereWithAggregatesInput = {
    AND?: TransferLineScalarWhereWithAggregatesInput | TransferLineScalarWhereWithAggregatesInput[]
    OR?: TransferLineScalarWhereWithAggregatesInput[]
    NOT?: TransferLineScalarWhereWithAggregatesInput | TransferLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferLine"> | string
    transferId?: StringWithAggregatesFilter<"TransferLine"> | string
    itemId?: StringWithAggregatesFilter<"TransferLine"> | string
    qty?: FloatWithAggregatesFilter<"TransferLine"> | number
  }

  export type AttendanceEventWhereInput = {
    AND?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    OR?: AttendanceEventWhereInput[]
    NOT?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    id?: StringFilter<"AttendanceEvent"> | string
    employeeUserId?: StringFilter<"AttendanceEvent"> | string
    kitchenId?: StringFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeFilter<"AttendanceEvent"> | $Enums.AttendanceType
    method?: EnumAttendanceMethodFilter<"AttendanceEvent"> | $Enums.AttendanceMethod
    lat?: FloatNullableFilter<"AttendanceEvent"> | number | null
    lng?: FloatNullableFilter<"AttendanceEvent"> | number | null
    distanceMeters?: FloatNullableFilter<"AttendanceEvent"> | number | null
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
  }

  export type AttendanceEventOrderByWithRelationInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    distanceMeters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    kitchen?: KitchenOrderByWithRelationInput
  }

  export type AttendanceEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    OR?: AttendanceEventWhereInput[]
    NOT?: AttendanceEventWhereInput | AttendanceEventWhereInput[]
    employeeUserId?: StringFilter<"AttendanceEvent"> | string
    kitchenId?: StringFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeFilter<"AttendanceEvent"> | $Enums.AttendanceType
    method?: EnumAttendanceMethodFilter<"AttendanceEvent"> | $Enums.AttendanceMethod
    lat?: FloatNullableFilter<"AttendanceEvent"> | number | null
    lng?: FloatNullableFilter<"AttendanceEvent"> | number | null
    distanceMeters?: FloatNullableFilter<"AttendanceEvent"> | number | null
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
  }, "id">

  export type AttendanceEventOrderByWithAggregationInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    distanceMeters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceEventCountOrderByAggregateInput
    _avg?: AttendanceEventAvgOrderByAggregateInput
    _max?: AttendanceEventMaxOrderByAggregateInput
    _min?: AttendanceEventMinOrderByAggregateInput
    _sum?: AttendanceEventSumOrderByAggregateInput
  }

  export type AttendanceEventScalarWhereWithAggregatesInput = {
    AND?: AttendanceEventScalarWhereWithAggregatesInput | AttendanceEventScalarWhereWithAggregatesInput[]
    OR?: AttendanceEventScalarWhereWithAggregatesInput[]
    NOT?: AttendanceEventScalarWhereWithAggregatesInput | AttendanceEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceEvent"> | string
    employeeUserId?: StringWithAggregatesFilter<"AttendanceEvent"> | string
    kitchenId?: StringWithAggregatesFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeWithAggregatesFilter<"AttendanceEvent"> | $Enums.AttendanceType
    method?: EnumAttendanceMethodWithAggregatesFilter<"AttendanceEvent"> | $Enums.AttendanceMethod
    lat?: FloatNullableWithAggregatesFilter<"AttendanceEvent"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"AttendanceEvent"> | number | null
    distanceMeters?: FloatNullableWithAggregatesFilter<"AttendanceEvent"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceEvent"> | Date | string
  }

  export type ShiftDaySummaryWhereInput = {
    AND?: ShiftDaySummaryWhereInput | ShiftDaySummaryWhereInput[]
    OR?: ShiftDaySummaryWhereInput[]
    NOT?: ShiftDaySummaryWhereInput | ShiftDaySummaryWhereInput[]
    id?: StringFilter<"ShiftDaySummary"> | string
    employeeUserId?: StringFilter<"ShiftDaySummary"> | string
    kitchenId?: StringFilter<"ShiftDaySummary"> | string
    date?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    minutesWorked?: IntFilter<"ShiftDaySummary"> | number
    minutesLate?: IntFilter<"ShiftDaySummary"> | number
    overtimeMinutes?: IntFilter<"ShiftDaySummary"> | number
    createdAt?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
  }

  export type ShiftDaySummaryOrderByWithRelationInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    date?: SortOrder
    minutesWorked?: SortOrder
    minutesLate?: SortOrder
    overtimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    kitchen?: KitchenOrderByWithRelationInput
  }

  export type ShiftDaySummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeUserId_kitchenId_date?: ShiftDaySummaryEmployeeUserIdKitchenIdDateCompoundUniqueInput
    AND?: ShiftDaySummaryWhereInput | ShiftDaySummaryWhereInput[]
    OR?: ShiftDaySummaryWhereInput[]
    NOT?: ShiftDaySummaryWhereInput | ShiftDaySummaryWhereInput[]
    employeeUserId?: StringFilter<"ShiftDaySummary"> | string
    kitchenId?: StringFilter<"ShiftDaySummary"> | string
    date?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    minutesWorked?: IntFilter<"ShiftDaySummary"> | number
    minutesLate?: IntFilter<"ShiftDaySummary"> | number
    overtimeMinutes?: IntFilter<"ShiftDaySummary"> | number
    createdAt?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    kitchen?: XOR<KitchenScalarRelationFilter, KitchenWhereInput>
  }, "id" | "employeeUserId_kitchenId_date">

  export type ShiftDaySummaryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    date?: SortOrder
    minutesWorked?: SortOrder
    minutesLate?: SortOrder
    overtimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftDaySummaryCountOrderByAggregateInput
    _avg?: ShiftDaySummaryAvgOrderByAggregateInput
    _max?: ShiftDaySummaryMaxOrderByAggregateInput
    _min?: ShiftDaySummaryMinOrderByAggregateInput
    _sum?: ShiftDaySummarySumOrderByAggregateInput
  }

  export type ShiftDaySummaryScalarWhereWithAggregatesInput = {
    AND?: ShiftDaySummaryScalarWhereWithAggregatesInput | ShiftDaySummaryScalarWhereWithAggregatesInput[]
    OR?: ShiftDaySummaryScalarWhereWithAggregatesInput[]
    NOT?: ShiftDaySummaryScalarWhereWithAggregatesInput | ShiftDaySummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftDaySummary"> | string
    employeeUserId?: StringWithAggregatesFilter<"ShiftDaySummary"> | string
    kitchenId?: StringWithAggregatesFilter<"ShiftDaySummary"> | string
    date?: DateTimeWithAggregatesFilter<"ShiftDaySummary"> | Date | string
    minutesWorked?: IntWithAggregatesFilter<"ShiftDaySummary"> | number
    minutesLate?: IntWithAggregatesFilter<"ShiftDaySummary"> | number
    overtimeMinutes?: IntWithAggregatesFilter<"ShiftDaySummary"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ShiftDaySummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShiftDaySummary"> | Date | string
  }

  export type PayrollPeriodWhereInput = {
    AND?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    OR?: PayrollPeriodWhereInput[]
    NOT?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    id?: StringFilter<"PayrollPeriod"> | string
    month?: StringFilter<"PayrollPeriod"> | string
    status?: EnumPayrollPeriodStatusFilter<"PayrollPeriod"> | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
    entries?: PayrollEntryListRelationFilter
  }

  export type PayrollPeriodOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    entries?: PayrollEntryOrderByRelationAggregateInput
  }

  export type PayrollPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    month?: string
    AND?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    OR?: PayrollPeriodWhereInput[]
    NOT?: PayrollPeriodWhereInput | PayrollPeriodWhereInput[]
    status?: EnumPayrollPeriodStatusFilter<"PayrollPeriod"> | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFilter<"PayrollPeriod"> | Date | string
    entries?: PayrollEntryListRelationFilter
  }, "id" | "month">

  export type PayrollPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    _count?: PayrollPeriodCountOrderByAggregateInput
    _max?: PayrollPeriodMaxOrderByAggregateInput
    _min?: PayrollPeriodMinOrderByAggregateInput
  }

  export type PayrollPeriodScalarWhereWithAggregatesInput = {
    AND?: PayrollPeriodScalarWhereWithAggregatesInput | PayrollPeriodScalarWhereWithAggregatesInput[]
    OR?: PayrollPeriodScalarWhereWithAggregatesInput[]
    NOT?: PayrollPeriodScalarWhereWithAggregatesInput | PayrollPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollPeriod"> | string
    month?: StringWithAggregatesFilter<"PayrollPeriod"> | string
    status?: EnumPayrollPeriodStatusWithAggregatesFilter<"PayrollPeriod"> | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeWithAggregatesFilter<"PayrollPeriod"> | Date | string
  }

  export type PayrollEntryWhereInput = {
    AND?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    OR?: PayrollEntryWhereInput[]
    NOT?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    id?: StringFilter<"PayrollEntry"> | string
    periodId?: StringFilter<"PayrollEntry"> | string
    employeeUserId?: StringFilter<"PayrollEntry"> | string
    computedSalary?: IntFilter<"PayrollEntry"> | number
    overtimePay?: IntFilter<"PayrollEntry"> | number
    deductions?: IntFilter<"PayrollEntry"> | number
    netPay?: IntFilter<"PayrollEntry"> | number
    paidAt?: DateTimeNullableFilter<"PayrollEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    period?: XOR<PayrollPeriodScalarRelationFilter, PayrollPeriodWhereInput>
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PayrollEntryOrderByWithRelationInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeUserId?: SortOrder
    computedSalary?: SortOrder
    overtimePay?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    period?: PayrollPeriodOrderByWithRelationInput
    employee?: UserOrderByWithRelationInput
  }

  export type PayrollEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    periodId_employeeUserId?: PayrollEntryPeriodIdEmployeeUserIdCompoundUniqueInput
    AND?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    OR?: PayrollEntryWhereInput[]
    NOT?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    periodId?: StringFilter<"PayrollEntry"> | string
    employeeUserId?: StringFilter<"PayrollEntry"> | string
    computedSalary?: IntFilter<"PayrollEntry"> | number
    overtimePay?: IntFilter<"PayrollEntry"> | number
    deductions?: IntFilter<"PayrollEntry"> | number
    netPay?: IntFilter<"PayrollEntry"> | number
    paidAt?: DateTimeNullableFilter<"PayrollEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    period?: XOR<PayrollPeriodScalarRelationFilter, PayrollPeriodWhereInput>
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "periodId_employeeUserId">

  export type PayrollEntryOrderByWithAggregationInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeUserId?: SortOrder
    computedSalary?: SortOrder
    overtimePay?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollEntryCountOrderByAggregateInput
    _avg?: PayrollEntryAvgOrderByAggregateInput
    _max?: PayrollEntryMaxOrderByAggregateInput
    _min?: PayrollEntryMinOrderByAggregateInput
    _sum?: PayrollEntrySumOrderByAggregateInput
  }

  export type PayrollEntryScalarWhereWithAggregatesInput = {
    AND?: PayrollEntryScalarWhereWithAggregatesInput | PayrollEntryScalarWhereWithAggregatesInput[]
    OR?: PayrollEntryScalarWhereWithAggregatesInput[]
    NOT?: PayrollEntryScalarWhereWithAggregatesInput | PayrollEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollEntry"> | string
    periodId?: StringWithAggregatesFilter<"PayrollEntry"> | string
    employeeUserId?: StringWithAggregatesFilter<"PayrollEntry"> | string
    computedSalary?: IntWithAggregatesFilter<"PayrollEntry"> | number
    overtimePay?: IntWithAggregatesFilter<"PayrollEntry"> | number
    deductions?: IntWithAggregatesFilter<"PayrollEntry"> | number
    netPay?: IntWithAggregatesFilter<"PayrollEntry"> | number
    paidAt?: DateTimeNullableWithAggregatesFilter<"PayrollEntry"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayrollEntry"> | Date | string
  }

  export type ReminderWhereInput = {
    AND?: ReminderWhereInput | ReminderWhereInput[]
    OR?: ReminderWhereInput[]
    NOT?: ReminderWhereInput | ReminderWhereInput[]
    id?: StringFilter<"Reminder"> | string
    type?: EnumReminderTypeFilter<"Reminder"> | $Enums.ReminderType
    dueAt?: DateTimeFilter<"Reminder"> | Date | string
    status?: EnumReminderStatusFilter<"Reminder"> | $Enums.ReminderStatus
    payload?: JsonFilter<"Reminder">
    createdByUserId?: StringNullableFilter<"Reminder"> | string | null
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
    doneAt?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ReminderOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    dueAt?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    doneAt?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type ReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReminderWhereInput | ReminderWhereInput[]
    OR?: ReminderWhereInput[]
    NOT?: ReminderWhereInput | ReminderWhereInput[]
    type?: EnumReminderTypeFilter<"Reminder"> | $Enums.ReminderType
    dueAt?: DateTimeFilter<"Reminder"> | Date | string
    status?: EnumReminderStatusFilter<"Reminder"> | $Enums.ReminderStatus
    payload?: JsonFilter<"Reminder">
    createdByUserId?: StringNullableFilter<"Reminder"> | string | null
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
    doneAt?: DateTimeNullableFilter<"Reminder"> | Date | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReminderOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    dueAt?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    doneAt?: SortOrderInput | SortOrder
    _count?: ReminderCountOrderByAggregateInput
    _max?: ReminderMaxOrderByAggregateInput
    _min?: ReminderMinOrderByAggregateInput
  }

  export type ReminderScalarWhereWithAggregatesInput = {
    AND?: ReminderScalarWhereWithAggregatesInput | ReminderScalarWhereWithAggregatesInput[]
    OR?: ReminderScalarWhereWithAggregatesInput[]
    NOT?: ReminderScalarWhereWithAggregatesInput | ReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reminder"> | string
    type?: EnumReminderTypeWithAggregatesFilter<"Reminder"> | $Enums.ReminderType
    dueAt?: DateTimeWithAggregatesFilter<"Reminder"> | Date | string
    status?: EnumReminderStatusWithAggregatesFilter<"Reminder"> | $Enums.ReminderStatus
    payload?: JsonWithAggregatesFilter<"Reminder">
    createdByUserId?: StringNullableWithAggregatesFilter<"Reminder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reminder"> | Date | string
    doneAt?: DateTimeNullableWithAggregatesFilter<"Reminder"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    meta?: JsonFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    meta?: JsonFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorUserId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    meta?: JsonWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type KitchenCreateInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenCreateManyInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateInput = {
    fullName: string
    baseSalaryMonthly: number
    overtimeRatePerHour?: number
    latePenaltyPerMinute?: number
    joinDate?: Date | string
    user: UserCreateNestedOneWithoutEmployeeProfileInput
  }

  export type EmployeeProfileUncheckedCreateInput = {
    userId: string
    fullName: string
    baseSalaryMonthly: number
    overtimeRatePerHour?: number
    latePenaltyPerMinute?: number
    joinDate?: Date | string
  }

  export type EmployeeProfileUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    baseSalaryMonthly?: IntFieldUpdateOperationsInput | number
    overtimeRatePerHour?: IntFieldUpdateOperationsInput | number
    latePenaltyPerMinute?: IntFieldUpdateOperationsInput | number
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeProfileNestedInput
  }

  export type EmployeeProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    baseSalaryMonthly?: IntFieldUpdateOperationsInput | number
    overtimeRatePerHour?: IntFieldUpdateOperationsInput | number
    latePenaltyPerMinute?: IntFieldUpdateOperationsInput | number
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateManyInput = {
    userId: string
    fullName: string
    baseSalaryMonthly: number
    overtimeRatePerHour?: number
    latePenaltyPerMinute?: number
    joinDate?: Date | string
  }

  export type EmployeeProfileUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    baseSalaryMonthly?: IntFieldUpdateOperationsInput | number
    overtimeRatePerHour?: IntFieldUpdateOperationsInput | number
    latePenaltyPerMinute?: IntFieldUpdateOperationsInput | number
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    baseSalaryMonthly?: IntFieldUpdateOperationsInput | number
    overtimeRatePerHour?: IntFieldUpdateOperationsInput | number
    latePenaltyPerMinute?: IntFieldUpdateOperationsInput | number
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    contact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    contact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockCreateNestedManyWithoutItemInput
    ledger?: StockLedgerCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    transferLines?: TransferLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutItemInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUpdateManyWithoutItemNestedInput
    ledger?: StockLedgerUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUncheckedUpdateManyWithoutItemNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenStockCreateInput = {
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutStocksInput
    item: ItemCreateNestedOneWithoutStocksInput
  }

  export type KitchenStockUncheckedCreateInput = {
    kitchenId: string
    itemId: string
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
  }

  export type KitchenStockUpdateInput = {
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutStocksNestedInput
    item?: ItemUpdateOneRequiredWithoutStocksNestedInput
  }

  export type KitchenStockUncheckedUpdateInput = {
    kitchenId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenStockCreateManyInput = {
    kitchenId: string
    itemId: string
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
  }

  export type KitchenStockUpdateManyMutationInput = {
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenStockUncheckedUpdateManyInput = {
    kitchenId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerCreateInput = {
    id?: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutLedgerInput
    item: ItemCreateNestedOneWithoutLedgerInput
    createdBy?: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
  }

  export type StockLedgerUncheckedCreateInput = {
    id?: string
    kitchenId: string
    itemId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type StockLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutLedgerNestedInput
    item?: ItemUpdateOneRequiredWithoutLedgerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedLedgerEntriesNestedInput
  }

  export type StockLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerCreateManyInput = {
    id?: string
    kitchenId: string
    itemId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type StockLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutPurchasesInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    lines?: PurchaseLineCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    kitchenId: string
    supplierId?: string | null
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutPurchasesNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    lines?: PurchaseLineUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    kitchenId: string
    supplierId?: string | null
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLineCreateInput = {
    id?: string
    qty: number
    unitCost: number
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutPurchaseLinesInput
  }

  export type PurchaseLineUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    itemId: string
    qty: number
    unitCost: number
  }

  export type PurchaseLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutPurchaseLinesNestedInput
  }

  export type PurchaseLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseLineCreateManyInput = {
    id?: string
    purchaseOrderId: string
    itemId: string
    qty: number
    unitCost: number
  }

  export type PurchaseLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferCreateInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    fromKitchen: KitchenCreateNestedOneWithoutTransfersFromInput
    toKitchen: KitchenCreateNestedOneWithoutTransfersToInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
    requestedBy?: UserCreateNestedOneWithoutRequestedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
    dispatchedBy?: UserCreateNestedOneWithoutDispatchedTransfersInput
    receivedBy?: UserCreateNestedOneWithoutReceivedTransfersInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromKitchen?: KitchenUpdateOneRequiredWithoutTransfersFromNestedInput
    toKitchen?: KitchenUpdateOneRequiredWithoutTransfersToNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
    requestedBy?: UserUpdateOneWithoutRequestedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
    dispatchedBy?: UserUpdateOneWithoutDispatchedTransfersNestedInput
    receivedBy?: UserUpdateOneWithoutReceivedTransfersNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferCreateManyInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferLineCreateInput = {
    id?: string
    qty: number
    transfer: TransferCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutTransferLinesInput
  }

  export type TransferLineUncheckedCreateInput = {
    id?: string
    transferId: string
    itemId: string
    qty: number
  }

  export type TransferLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    transfer?: TransferUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutTransferLinesNestedInput
  }

  export type TransferLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferLineCreateManyInput = {
    id?: string
    transferId: string
    itemId: string
    qty: number
  }

  export type TransferLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
  }

  export type AttendanceEventCreateInput = {
    id?: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
    employee: UserCreateNestedOneWithoutAttendanceEventsInput
    kitchen: KitchenCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateInput = {
    id?: string
    employeeUserId: string
    kitchenId: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type AttendanceEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutAttendanceEventsNestedInput
    kitchen?: KitchenUpdateOneRequiredWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventCreateManyInput = {
    id?: string
    employeeUserId: string
    kitchenId: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type AttendanceEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftDaySummaryCreateInput = {
    id?: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutShiftSummariesInput
    kitchen: KitchenCreateNestedOneWithoutShiftSummariesInput
  }

  export type ShiftDaySummaryUncheckedCreateInput = {
    id?: string
    employeeUserId: string
    kitchenId: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftDaySummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutShiftSummariesNestedInput
    kitchen?: KitchenUpdateOneRequiredWithoutShiftSummariesNestedInput
  }

  export type ShiftDaySummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftDaySummaryCreateManyInput = {
    id?: string
    employeeUserId: string
    kitchenId: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftDaySummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftDaySummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollPeriodCreateInput = {
    id?: string
    month: string
    status?: $Enums.PayrollPeriodStatus
    generatedAt?: Date | string
    entries?: PayrollEntryCreateNestedManyWithoutPeriodInput
  }

  export type PayrollPeriodUncheckedCreateInput = {
    id?: string
    month: string
    status?: $Enums.PayrollPeriodStatus
    generatedAt?: Date | string
    entries?: PayrollEntryUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PayrollPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: PayrollEntryUpdateManyWithoutPeriodNestedInput
  }

  export type PayrollPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: PayrollEntryUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type PayrollPeriodCreateManyInput = {
    id?: string
    month: string
    status?: $Enums.PayrollPeriodStatus
    generatedAt?: Date | string
  }

  export type PayrollPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryCreateInput = {
    id?: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PayrollPeriodCreateNestedOneWithoutEntriesInput
    employee: UserCreateNestedOneWithoutPayrollEntriesInput
  }

  export type PayrollEntryUncheckedCreateInput = {
    id?: string
    periodId: string
    employeeUserId: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PayrollPeriodUpdateOneRequiredWithoutEntriesNestedInput
    employee?: UserUpdateOneRequiredWithoutPayrollEntriesNestedInput
  }

  export type PayrollEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryCreateManyInput = {
    id?: string
    periodId: string
    employeeUserId: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderCreateInput = {
    id?: string
    type: $Enums.ReminderType
    dueAt: Date | string
    status?: $Enums.ReminderStatus
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    doneAt?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutRemindersCreatedInput
  }

  export type ReminderUncheckedCreateInput = {
    id?: string
    type: $Enums.ReminderType
    dueAt: Date | string
    status?: $Enums.ReminderStatus
    payload: JsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    createdAt?: Date | string
    doneAt?: Date | string | null
  }

  export type ReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutRemindersCreatedNestedInput
  }

  export type ReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    payload?: JsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReminderCreateManyInput = {
    id?: string
    type: $Enums.ReminderType
    dueAt: Date | string
    status?: $Enums.ReminderStatus
    payload: JsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    createdAt?: Date | string
    doneAt?: Date | string | null
  }

  export type ReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    payload?: JsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    meta: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorUserId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    meta: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorUserId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    meta: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumKitchenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenType | EnumKitchenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenTypeFilter<$PrismaModel> | $Enums.KitchenType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type KitchenStockListRelationFilter = {
    every?: KitchenStockWhereInput
    some?: KitchenStockWhereInput
    none?: KitchenStockWhereInput
  }

  export type StockLedgerListRelationFilter = {
    every?: StockLedgerWhereInput
    some?: StockLedgerWhereInput
    none?: StockLedgerWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type AttendanceEventListRelationFilter = {
    every?: AttendanceEventWhereInput
    some?: AttendanceEventWhereInput
    none?: AttendanceEventWhereInput
  }

  export type ShiftDaySummaryListRelationFilter = {
    every?: ShiftDaySummaryWhereInput
    some?: ShiftDaySummaryWhereInput
    none?: ShiftDaySummaryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KitchenStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftDaySummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KitchenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    geofenceRadiusMeters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    geofenceRadiusMeters?: SortOrder
  }

  export type KitchenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    geofenceRadiusMeters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    geofenceRadiusMeters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    geofenceRadiusMeters?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumKitchenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenType | EnumKitchenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenTypeWithAggregatesFilter<$PrismaModel> | $Enums.KitchenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKitchenTypeFilter<$PrismaModel>
    _max?: NestedEnumKitchenTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type KitchenNullableScalarRelationFilter = {
    is?: KitchenWhereInput | null
    isNot?: KitchenWhereInput | null
  }

  export type EmployeeProfileNullableScalarRelationFilter = {
    is?: EmployeeProfileWhereInput | null
    isNot?: EmployeeProfileWhereInput | null
  }

  export type PayrollEntryListRelationFilter = {
    every?: PayrollEntryWhereInput
    some?: PayrollEntryWhereInput
    none?: PayrollEntryWhereInput
  }

  export type ReminderListRelationFilter = {
    every?: ReminderWhereInput
    some?: ReminderWhereInput
    none?: ReminderWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PayrollEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    kitchenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    kitchenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    kitchenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    fullName?: SortOrder
    baseSalaryMonthly?: SortOrder
    overtimeRatePerHour?: SortOrder
    latePenaltyPerMinute?: SortOrder
    joinDate?: SortOrder
  }

  export type EmployeeProfileAvgOrderByAggregateInput = {
    baseSalaryMonthly?: SortOrder
    overtimeRatePerHour?: SortOrder
    latePenaltyPerMinute?: SortOrder
  }

  export type EmployeeProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    fullName?: SortOrder
    baseSalaryMonthly?: SortOrder
    overtimeRatePerHour?: SortOrder
    latePenaltyPerMinute?: SortOrder
    joinDate?: SortOrder
  }

  export type EmployeeProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    fullName?: SortOrder
    baseSalaryMonthly?: SortOrder
    overtimeRatePerHour?: SortOrder
    latePenaltyPerMinute?: SortOrder
    joinDate?: SortOrder
  }

  export type EmployeeProfileSumOrderByAggregateInput = {
    baseSalaryMonthly?: SortOrder
    overtimeRatePerHour?: SortOrder
    latePenaltyPerMinute?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PurchaseLineListRelationFilter = {
    every?: PurchaseLineWhereInput
    some?: PurchaseLineWhereInput
    none?: PurchaseLineWhereInput
  }

  export type TransferLineListRelationFilter = {
    every?: TransferLineWhereInput
    some?: TransferLineWhereInput
    none?: TransferLineWhereInput
  }

  export type PurchaseLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemNameUomCompoundUniqueInput = {
    name: string
    uom: string
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    uom?: SortOrder
    reorderPoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    reorderPoint?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    uom?: SortOrder
    reorderPoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    uom?: SortOrder
    reorderPoint?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    reorderPoint?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type KitchenScalarRelationFilter = {
    is?: KitchenWhereInput
    isNot?: KitchenWhereInput
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type KitchenStockKitchenIdItemIdCompoundUniqueInput = {
    kitchenId: string
    itemId: string
  }

  export type KitchenStockCountOrderByAggregateInput = {
    kitchenId?: SortOrder
    itemId?: SortOrder
    onHandQty?: SortOrder
    avgCost?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenStockAvgOrderByAggregateInput = {
    onHandQty?: SortOrder
    avgCost?: SortOrder
  }

  export type KitchenStockMaxOrderByAggregateInput = {
    kitchenId?: SortOrder
    itemId?: SortOrder
    onHandQty?: SortOrder
    avgCost?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenStockMinOrderByAggregateInput = {
    kitchenId?: SortOrder
    itemId?: SortOrder
    onHandQty?: SortOrder
    avgCost?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenStockSumOrderByAggregateInput = {
    onHandQty?: SortOrder
    avgCost?: SortOrder
  }

  export type EnumStockLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockLedgerType | EnumStockLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockLedgerTypeFilter<$PrismaModel> | $Enums.StockLedgerType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StockLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qtyDelta?: SortOrder
    unitCost?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockLedgerAvgOrderByAggregateInput = {
    qtyDelta?: SortOrder
    unitCost?: SortOrder
  }

  export type StockLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qtyDelta?: SortOrder
    unitCost?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    qtyDelta?: SortOrder
    unitCost?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockLedgerSumOrderByAggregateInput = {
    qtyDelta?: SortOrder
    unitCost?: SortOrder
  }

  export type EnumStockLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockLedgerType | EnumStockLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockLedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumStockLedgerTypeFilter<$PrismaModel>
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    supplierId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    supplierId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    kitchenId?: SortOrder
    supplierId?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseLineCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseLineMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseLineMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitCost?: SortOrder
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    fromKitchenId?: SortOrder
    toKitchenId?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrder
    approvedByUserId?: SortOrder
    dispatchedByUserId?: SortOrder
    receivedByUserId?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    dispatchedAt?: SortOrder
    receivedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    fromKitchenId?: SortOrder
    toKitchenId?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrder
    approvedByUserId?: SortOrder
    dispatchedByUserId?: SortOrder
    receivedByUserId?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    dispatchedAt?: SortOrder
    receivedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    fromKitchenId?: SortOrder
    toKitchenId?: SortOrder
    status?: SortOrder
    requestedByUserId?: SortOrder
    approvedByUserId?: SortOrder
    dispatchedByUserId?: SortOrder
    receivedByUserId?: SortOrder
    requestedAt?: SortOrder
    approvedAt?: SortOrder
    dispatchedAt?: SortOrder
    receivedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TransferScalarRelationFilter = {
    is?: TransferWhereInput
    isNot?: TransferWhereInput
  }

  export type TransferLineCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
  }

  export type TransferLineAvgOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type TransferLineMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
  }

  export type TransferLineMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
  }

  export type TransferLineSumOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type EnumAttendanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeFilter<$PrismaModel> | $Enums.AttendanceType
  }

  export type EnumAttendanceMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMethod | EnumAttendanceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceMethodFilter<$PrismaModel> | $Enums.AttendanceMethod
  }

  export type AttendanceEventCountOrderByAggregateInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    distanceMeters?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceEventAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    distanceMeters?: SortOrder
  }

  export type AttendanceEventMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    distanceMeters?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceEventMinOrderByAggregateInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    type?: SortOrder
    method?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    distanceMeters?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceEventSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    distanceMeters?: SortOrder
  }

  export type EnumAttendanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceTypeFilter<$PrismaModel>
  }

  export type EnumAttendanceMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMethod | EnumAttendanceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceMethodWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceMethodFilter<$PrismaModel>
    _max?: NestedEnumAttendanceMethodFilter<$PrismaModel>
  }

  export type ShiftDaySummaryEmployeeUserIdKitchenIdDateCompoundUniqueInput = {
    employeeUserId: string
    kitchenId: string
    date: Date | string
  }

  export type ShiftDaySummaryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    date?: SortOrder
    minutesWorked?: SortOrder
    minutesLate?: SortOrder
    overtimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftDaySummaryAvgOrderByAggregateInput = {
    minutesWorked?: SortOrder
    minutesLate?: SortOrder
    overtimeMinutes?: SortOrder
  }

  export type ShiftDaySummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    date?: SortOrder
    minutesWorked?: SortOrder
    minutesLate?: SortOrder
    overtimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftDaySummaryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeUserId?: SortOrder
    kitchenId?: SortOrder
    date?: SortOrder
    minutesWorked?: SortOrder
    minutesLate?: SortOrder
    overtimeMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftDaySummarySumOrderByAggregateInput = {
    minutesWorked?: SortOrder
    minutesLate?: SortOrder
    overtimeMinutes?: SortOrder
  }

  export type EnumPayrollPeriodStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
  }

  export type PayrollPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
  }

  export type PayrollPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
  }

  export type PayrollPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
  }

  export type EnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
  }

  export type PayrollPeriodScalarRelationFilter = {
    is?: PayrollPeriodWhereInput
    isNot?: PayrollPeriodWhereInput
  }

  export type PayrollEntryPeriodIdEmployeeUserIdCompoundUniqueInput = {
    periodId: string
    employeeUserId: string
  }

  export type PayrollEntryCountOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeUserId?: SortOrder
    computedSalary?: SortOrder
    overtimePay?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntryAvgOrderByAggregateInput = {
    computedSalary?: SortOrder
    overtimePay?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
  }

  export type PayrollEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeUserId?: SortOrder
    computedSalary?: SortOrder
    overtimePay?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntryMinOrderByAggregateInput = {
    id?: SortOrder
    periodId?: SortOrder
    employeeUserId?: SortOrder
    computedSalary?: SortOrder
    overtimePay?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntrySumOrderByAggregateInput = {
    computedSalary?: SortOrder
    overtimePay?: SortOrder
    deductions?: SortOrder
    netPay?: SortOrder
  }

  export type EnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type EnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReminderCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dueAt?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    doneAt?: SortOrder
  }

  export type ReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dueAt?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    doneAt?: SortOrder
  }

  export type ReminderMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dueAt?: SortOrder
    status?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    doneAt?: SortOrder
  }

  export type EnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type EnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutKitchenInput = {
    create?: XOR<UserCreateWithoutKitchenInput, UserUncheckedCreateWithoutKitchenInput> | UserCreateWithoutKitchenInput[] | UserUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: UserCreateOrConnectWithoutKitchenInput | UserCreateOrConnectWithoutKitchenInput[]
    createMany?: UserCreateManyKitchenInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type KitchenStockCreateNestedManyWithoutKitchenInput = {
    create?: XOR<KitchenStockCreateWithoutKitchenInput, KitchenStockUncheckedCreateWithoutKitchenInput> | KitchenStockCreateWithoutKitchenInput[] | KitchenStockUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutKitchenInput | KitchenStockCreateOrConnectWithoutKitchenInput[]
    createMany?: KitchenStockCreateManyKitchenInputEnvelope
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
  }

  export type StockLedgerCreateNestedManyWithoutKitchenInput = {
    create?: XOR<StockLedgerCreateWithoutKitchenInput, StockLedgerUncheckedCreateWithoutKitchenInput> | StockLedgerCreateWithoutKitchenInput[] | StockLedgerUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutKitchenInput | StockLedgerCreateOrConnectWithoutKitchenInput[]
    createMany?: StockLedgerCreateManyKitchenInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutKitchenInput = {
    create?: XOR<PurchaseOrderCreateWithoutKitchenInput, PurchaseOrderUncheckedCreateWithoutKitchenInput> | PurchaseOrderCreateWithoutKitchenInput[] | PurchaseOrderUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutKitchenInput | PurchaseOrderCreateOrConnectWithoutKitchenInput[]
    createMany?: PurchaseOrderCreateManyKitchenInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutFromKitchenInput = {
    create?: XOR<TransferCreateWithoutFromKitchenInput, TransferUncheckedCreateWithoutFromKitchenInput> | TransferCreateWithoutFromKitchenInput[] | TransferUncheckedCreateWithoutFromKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromKitchenInput | TransferCreateOrConnectWithoutFromKitchenInput[]
    createMany?: TransferCreateManyFromKitchenInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutToKitchenInput = {
    create?: XOR<TransferCreateWithoutToKitchenInput, TransferUncheckedCreateWithoutToKitchenInput> | TransferCreateWithoutToKitchenInput[] | TransferUncheckedCreateWithoutToKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToKitchenInput | TransferCreateOrConnectWithoutToKitchenInput[]
    createMany?: TransferCreateManyToKitchenInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AttendanceEventCreateNestedManyWithoutKitchenInput = {
    create?: XOR<AttendanceEventCreateWithoutKitchenInput, AttendanceEventUncheckedCreateWithoutKitchenInput> | AttendanceEventCreateWithoutKitchenInput[] | AttendanceEventUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutKitchenInput | AttendanceEventCreateOrConnectWithoutKitchenInput[]
    createMany?: AttendanceEventCreateManyKitchenInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type ShiftDaySummaryCreateNestedManyWithoutKitchenInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutKitchenInput, ShiftDaySummaryUncheckedCreateWithoutKitchenInput> | ShiftDaySummaryCreateWithoutKitchenInput[] | ShiftDaySummaryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutKitchenInput | ShiftDaySummaryCreateOrConnectWithoutKitchenInput[]
    createMany?: ShiftDaySummaryCreateManyKitchenInputEnvelope
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<UserCreateWithoutKitchenInput, UserUncheckedCreateWithoutKitchenInput> | UserCreateWithoutKitchenInput[] | UserUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: UserCreateOrConnectWithoutKitchenInput | UserCreateOrConnectWithoutKitchenInput[]
    createMany?: UserCreateManyKitchenInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type KitchenStockUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<KitchenStockCreateWithoutKitchenInput, KitchenStockUncheckedCreateWithoutKitchenInput> | KitchenStockCreateWithoutKitchenInput[] | KitchenStockUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutKitchenInput | KitchenStockCreateOrConnectWithoutKitchenInput[]
    createMany?: KitchenStockCreateManyKitchenInputEnvelope
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<StockLedgerCreateWithoutKitchenInput, StockLedgerUncheckedCreateWithoutKitchenInput> | StockLedgerCreateWithoutKitchenInput[] | StockLedgerUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutKitchenInput | StockLedgerCreateOrConnectWithoutKitchenInput[]
    createMany?: StockLedgerCreateManyKitchenInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<PurchaseOrderCreateWithoutKitchenInput, PurchaseOrderUncheckedCreateWithoutKitchenInput> | PurchaseOrderCreateWithoutKitchenInput[] | PurchaseOrderUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutKitchenInput | PurchaseOrderCreateOrConnectWithoutKitchenInput[]
    createMany?: PurchaseOrderCreateManyKitchenInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutFromKitchenInput = {
    create?: XOR<TransferCreateWithoutFromKitchenInput, TransferUncheckedCreateWithoutFromKitchenInput> | TransferCreateWithoutFromKitchenInput[] | TransferUncheckedCreateWithoutFromKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromKitchenInput | TransferCreateOrConnectWithoutFromKitchenInput[]
    createMany?: TransferCreateManyFromKitchenInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutToKitchenInput = {
    create?: XOR<TransferCreateWithoutToKitchenInput, TransferUncheckedCreateWithoutToKitchenInput> | TransferCreateWithoutToKitchenInput[] | TransferUncheckedCreateWithoutToKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToKitchenInput | TransferCreateOrConnectWithoutToKitchenInput[]
    createMany?: TransferCreateManyToKitchenInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<AttendanceEventCreateWithoutKitchenInput, AttendanceEventUncheckedCreateWithoutKitchenInput> | AttendanceEventCreateWithoutKitchenInput[] | AttendanceEventUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutKitchenInput | AttendanceEventCreateOrConnectWithoutKitchenInput[]
    createMany?: AttendanceEventCreateManyKitchenInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutKitchenInput, ShiftDaySummaryUncheckedCreateWithoutKitchenInput> | ShiftDaySummaryCreateWithoutKitchenInput[] | ShiftDaySummaryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutKitchenInput | ShiftDaySummaryCreateOrConnectWithoutKitchenInput[]
    createMany?: ShiftDaySummaryCreateManyKitchenInputEnvelope
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumKitchenTypeFieldUpdateOperationsInput = {
    set?: $Enums.KitchenType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<UserCreateWithoutKitchenInput, UserUncheckedCreateWithoutKitchenInput> | UserCreateWithoutKitchenInput[] | UserUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: UserCreateOrConnectWithoutKitchenInput | UserCreateOrConnectWithoutKitchenInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutKitchenInput | UserUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: UserCreateManyKitchenInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutKitchenInput | UserUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: UserUpdateManyWithWhereWithoutKitchenInput | UserUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type KitchenStockUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<KitchenStockCreateWithoutKitchenInput, KitchenStockUncheckedCreateWithoutKitchenInput> | KitchenStockCreateWithoutKitchenInput[] | KitchenStockUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutKitchenInput | KitchenStockCreateOrConnectWithoutKitchenInput[]
    upsert?: KitchenStockUpsertWithWhereUniqueWithoutKitchenInput | KitchenStockUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: KitchenStockCreateManyKitchenInputEnvelope
    set?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    disconnect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    delete?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    update?: KitchenStockUpdateWithWhereUniqueWithoutKitchenInput | KitchenStockUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: KitchenStockUpdateManyWithWhereWithoutKitchenInput | KitchenStockUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: KitchenStockScalarWhereInput | KitchenStockScalarWhereInput[]
  }

  export type StockLedgerUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<StockLedgerCreateWithoutKitchenInput, StockLedgerUncheckedCreateWithoutKitchenInput> | StockLedgerCreateWithoutKitchenInput[] | StockLedgerUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutKitchenInput | StockLedgerCreateOrConnectWithoutKitchenInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutKitchenInput | StockLedgerUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: StockLedgerCreateManyKitchenInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutKitchenInput | StockLedgerUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutKitchenInput | StockLedgerUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutKitchenInput, PurchaseOrderUncheckedCreateWithoutKitchenInput> | PurchaseOrderCreateWithoutKitchenInput[] | PurchaseOrderUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutKitchenInput | PurchaseOrderCreateOrConnectWithoutKitchenInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutKitchenInput | PurchaseOrderUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: PurchaseOrderCreateManyKitchenInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutKitchenInput | PurchaseOrderUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutKitchenInput | PurchaseOrderUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutFromKitchenNestedInput = {
    create?: XOR<TransferCreateWithoutFromKitchenInput, TransferUncheckedCreateWithoutFromKitchenInput> | TransferCreateWithoutFromKitchenInput[] | TransferUncheckedCreateWithoutFromKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromKitchenInput | TransferCreateOrConnectWithoutFromKitchenInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromKitchenInput | TransferUpsertWithWhereUniqueWithoutFromKitchenInput[]
    createMany?: TransferCreateManyFromKitchenInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromKitchenInput | TransferUpdateWithWhereUniqueWithoutFromKitchenInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromKitchenInput | TransferUpdateManyWithWhereWithoutFromKitchenInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutToKitchenNestedInput = {
    create?: XOR<TransferCreateWithoutToKitchenInput, TransferUncheckedCreateWithoutToKitchenInput> | TransferCreateWithoutToKitchenInput[] | TransferUncheckedCreateWithoutToKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToKitchenInput | TransferCreateOrConnectWithoutToKitchenInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToKitchenInput | TransferUpsertWithWhereUniqueWithoutToKitchenInput[]
    createMany?: TransferCreateManyToKitchenInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToKitchenInput | TransferUpdateWithWhereUniqueWithoutToKitchenInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToKitchenInput | TransferUpdateManyWithWhereWithoutToKitchenInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AttendanceEventUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutKitchenInput, AttendanceEventUncheckedCreateWithoutKitchenInput> | AttendanceEventCreateWithoutKitchenInput[] | AttendanceEventUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutKitchenInput | AttendanceEventCreateOrConnectWithoutKitchenInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutKitchenInput | AttendanceEventUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: AttendanceEventCreateManyKitchenInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutKitchenInput | AttendanceEventUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutKitchenInput | AttendanceEventUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type ShiftDaySummaryUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutKitchenInput, ShiftDaySummaryUncheckedCreateWithoutKitchenInput> | ShiftDaySummaryCreateWithoutKitchenInput[] | ShiftDaySummaryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutKitchenInput | ShiftDaySummaryCreateOrConnectWithoutKitchenInput[]
    upsert?: ShiftDaySummaryUpsertWithWhereUniqueWithoutKitchenInput | ShiftDaySummaryUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: ShiftDaySummaryCreateManyKitchenInputEnvelope
    set?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    disconnect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    delete?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    update?: ShiftDaySummaryUpdateWithWhereUniqueWithoutKitchenInput | ShiftDaySummaryUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: ShiftDaySummaryUpdateManyWithWhereWithoutKitchenInput | ShiftDaySummaryUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: ShiftDaySummaryScalarWhereInput | ShiftDaySummaryScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<UserCreateWithoutKitchenInput, UserUncheckedCreateWithoutKitchenInput> | UserCreateWithoutKitchenInput[] | UserUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: UserCreateOrConnectWithoutKitchenInput | UserCreateOrConnectWithoutKitchenInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutKitchenInput | UserUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: UserCreateManyKitchenInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutKitchenInput | UserUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: UserUpdateManyWithWhereWithoutKitchenInput | UserUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<KitchenStockCreateWithoutKitchenInput, KitchenStockUncheckedCreateWithoutKitchenInput> | KitchenStockCreateWithoutKitchenInput[] | KitchenStockUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutKitchenInput | KitchenStockCreateOrConnectWithoutKitchenInput[]
    upsert?: KitchenStockUpsertWithWhereUniqueWithoutKitchenInput | KitchenStockUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: KitchenStockCreateManyKitchenInputEnvelope
    set?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    disconnect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    delete?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    update?: KitchenStockUpdateWithWhereUniqueWithoutKitchenInput | KitchenStockUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: KitchenStockUpdateManyWithWhereWithoutKitchenInput | KitchenStockUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: KitchenStockScalarWhereInput | KitchenStockScalarWhereInput[]
  }

  export type StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<StockLedgerCreateWithoutKitchenInput, StockLedgerUncheckedCreateWithoutKitchenInput> | StockLedgerCreateWithoutKitchenInput[] | StockLedgerUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutKitchenInput | StockLedgerCreateOrConnectWithoutKitchenInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutKitchenInput | StockLedgerUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: StockLedgerCreateManyKitchenInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutKitchenInput | StockLedgerUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutKitchenInput | StockLedgerUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutKitchenInput, PurchaseOrderUncheckedCreateWithoutKitchenInput> | PurchaseOrderCreateWithoutKitchenInput[] | PurchaseOrderUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutKitchenInput | PurchaseOrderCreateOrConnectWithoutKitchenInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutKitchenInput | PurchaseOrderUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: PurchaseOrderCreateManyKitchenInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutKitchenInput | PurchaseOrderUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutKitchenInput | PurchaseOrderUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutFromKitchenNestedInput = {
    create?: XOR<TransferCreateWithoutFromKitchenInput, TransferUncheckedCreateWithoutFromKitchenInput> | TransferCreateWithoutFromKitchenInput[] | TransferUncheckedCreateWithoutFromKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromKitchenInput | TransferCreateOrConnectWithoutFromKitchenInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromKitchenInput | TransferUpsertWithWhereUniqueWithoutFromKitchenInput[]
    createMany?: TransferCreateManyFromKitchenInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromKitchenInput | TransferUpdateWithWhereUniqueWithoutFromKitchenInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromKitchenInput | TransferUpdateManyWithWhereWithoutFromKitchenInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutToKitchenNestedInput = {
    create?: XOR<TransferCreateWithoutToKitchenInput, TransferUncheckedCreateWithoutToKitchenInput> | TransferCreateWithoutToKitchenInput[] | TransferUncheckedCreateWithoutToKitchenInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToKitchenInput | TransferCreateOrConnectWithoutToKitchenInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToKitchenInput | TransferUpsertWithWhereUniqueWithoutToKitchenInput[]
    createMany?: TransferCreateManyToKitchenInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToKitchenInput | TransferUpdateWithWhereUniqueWithoutToKitchenInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToKitchenInput | TransferUpdateManyWithWhereWithoutToKitchenInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutKitchenInput, AttendanceEventUncheckedCreateWithoutKitchenInput> | AttendanceEventCreateWithoutKitchenInput[] | AttendanceEventUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutKitchenInput | AttendanceEventCreateOrConnectWithoutKitchenInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutKitchenInput | AttendanceEventUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: AttendanceEventCreateManyKitchenInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutKitchenInput | AttendanceEventUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutKitchenInput | AttendanceEventUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutKitchenInput, ShiftDaySummaryUncheckedCreateWithoutKitchenInput> | ShiftDaySummaryCreateWithoutKitchenInput[] | ShiftDaySummaryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutKitchenInput | ShiftDaySummaryCreateOrConnectWithoutKitchenInput[]
    upsert?: ShiftDaySummaryUpsertWithWhereUniqueWithoutKitchenInput | ShiftDaySummaryUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: ShiftDaySummaryCreateManyKitchenInputEnvelope
    set?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    disconnect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    delete?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    update?: ShiftDaySummaryUpdateWithWhereUniqueWithoutKitchenInput | ShiftDaySummaryUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: ShiftDaySummaryUpdateManyWithWhereWithoutKitchenInput | ShiftDaySummaryUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: ShiftDaySummaryScalarWhereInput | ShiftDaySummaryScalarWhereInput[]
  }

  export type KitchenCreateNestedOneWithoutUsersInput = {
    create?: XOR<KitchenCreateWithoutUsersInput, KitchenUncheckedCreateWithoutUsersInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutUsersInput
    connect?: KitchenWhereUniqueInput
  }

  export type EmployeeProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type StockLedgerCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StockLedgerCreateWithoutCreatedByInput, StockLedgerUncheckedCreateWithoutCreatedByInput> | StockLedgerCreateWithoutCreatedByInput[] | StockLedgerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutCreatedByInput | StockLedgerCreateOrConnectWithoutCreatedByInput[]
    createMany?: StockLedgerCreateManyCreatedByInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<TransferCreateWithoutRequestedByInput, TransferUncheckedCreateWithoutRequestedByInput> | TransferCreateWithoutRequestedByInput[] | TransferUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutRequestedByInput | TransferCreateOrConnectWithoutRequestedByInput[]
    createMany?: TransferCreateManyRequestedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput> | TransferCreateWithoutApprovedByInput[] | TransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutApprovedByInput | TransferCreateOrConnectWithoutApprovedByInput[]
    createMany?: TransferCreateManyApprovedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutDispatchedByInput = {
    create?: XOR<TransferCreateWithoutDispatchedByInput, TransferUncheckedCreateWithoutDispatchedByInput> | TransferCreateWithoutDispatchedByInput[] | TransferUncheckedCreateWithoutDispatchedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDispatchedByInput | TransferCreateOrConnectWithoutDispatchedByInput[]
    createMany?: TransferCreateManyDispatchedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<TransferCreateWithoutReceivedByInput, TransferUncheckedCreateWithoutReceivedByInput> | TransferCreateWithoutReceivedByInput[] | TransferUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutReceivedByInput | TransferCreateOrConnectWithoutReceivedByInput[]
    createMany?: TransferCreateManyReceivedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AttendanceEventCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type ShiftDaySummaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutEmployeeInput, ShiftDaySummaryUncheckedCreateWithoutEmployeeInput> | ShiftDaySummaryCreateWithoutEmployeeInput[] | ShiftDaySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutEmployeeInput | ShiftDaySummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftDaySummaryCreateManyEmployeeInputEnvelope
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
  }

  export type PayrollEntryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type ReminderCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReminderCreateWithoutCreatedByInput, ReminderUncheckedCreateWithoutCreatedByInput> | ReminderCreateWithoutCreatedByInput[] | ReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatedByInput | ReminderCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReminderCreateManyCreatedByInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EmployeeProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StockLedgerCreateWithoutCreatedByInput, StockLedgerUncheckedCreateWithoutCreatedByInput> | StockLedgerCreateWithoutCreatedByInput[] | StockLedgerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutCreatedByInput | StockLedgerCreateOrConnectWithoutCreatedByInput[]
    createMany?: StockLedgerCreateManyCreatedByInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<TransferCreateWithoutRequestedByInput, TransferUncheckedCreateWithoutRequestedByInput> | TransferCreateWithoutRequestedByInput[] | TransferUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutRequestedByInput | TransferCreateOrConnectWithoutRequestedByInput[]
    createMany?: TransferCreateManyRequestedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput> | TransferCreateWithoutApprovedByInput[] | TransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutApprovedByInput | TransferCreateOrConnectWithoutApprovedByInput[]
    createMany?: TransferCreateManyApprovedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutDispatchedByInput = {
    create?: XOR<TransferCreateWithoutDispatchedByInput, TransferUncheckedCreateWithoutDispatchedByInput> | TransferCreateWithoutDispatchedByInput[] | TransferUncheckedCreateWithoutDispatchedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDispatchedByInput | TransferCreateOrConnectWithoutDispatchedByInput[]
    createMany?: TransferCreateManyDispatchedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<TransferCreateWithoutReceivedByInput, TransferUncheckedCreateWithoutReceivedByInput> | TransferCreateWithoutReceivedByInput[] | TransferUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutReceivedByInput | TransferCreateOrConnectWithoutReceivedByInput[]
    createMany?: TransferCreateManyReceivedByInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
  }

  export type ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutEmployeeInput, ShiftDaySummaryUncheckedCreateWithoutEmployeeInput> | ShiftDaySummaryCreateWithoutEmployeeInput[] | ShiftDaySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutEmployeeInput | ShiftDaySummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftDaySummaryCreateManyEmployeeInputEnvelope
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
  }

  export type PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type ReminderUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ReminderCreateWithoutCreatedByInput, ReminderUncheckedCreateWithoutCreatedByInput> | ReminderCreateWithoutCreatedByInput[] | ReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatedByInput | ReminderCreateOrConnectWithoutCreatedByInput[]
    createMany?: ReminderCreateManyCreatedByInputEnvelope
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type KitchenUpdateOneWithoutUsersNestedInput = {
    create?: XOR<KitchenCreateWithoutUsersInput, KitchenUncheckedCreateWithoutUsersInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutUsersInput
    upsert?: KitchenUpsertWithoutUsersInput
    disconnect?: KitchenWhereInput | boolean
    delete?: KitchenWhereInput | boolean
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutUsersInput, KitchenUpdateWithoutUsersInput>, KitchenUncheckedUpdateWithoutUsersInput>
  }

  export type EmployeeProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type StockLedgerUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StockLedgerCreateWithoutCreatedByInput, StockLedgerUncheckedCreateWithoutCreatedByInput> | StockLedgerCreateWithoutCreatedByInput[] | StockLedgerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutCreatedByInput | StockLedgerCreateOrConnectWithoutCreatedByInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutCreatedByInput | StockLedgerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StockLedgerCreateManyCreatedByInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutCreatedByInput | StockLedgerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutCreatedByInput | StockLedgerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<TransferCreateWithoutRequestedByInput, TransferUncheckedCreateWithoutRequestedByInput> | TransferCreateWithoutRequestedByInput[] | TransferUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutRequestedByInput | TransferCreateOrConnectWithoutRequestedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutRequestedByInput | TransferUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: TransferCreateManyRequestedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutRequestedByInput | TransferUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutRequestedByInput | TransferUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput> | TransferCreateWithoutApprovedByInput[] | TransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutApprovedByInput | TransferCreateOrConnectWithoutApprovedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutApprovedByInput | TransferUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: TransferCreateManyApprovedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutApprovedByInput | TransferUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutApprovedByInput | TransferUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutDispatchedByNestedInput = {
    create?: XOR<TransferCreateWithoutDispatchedByInput, TransferUncheckedCreateWithoutDispatchedByInput> | TransferCreateWithoutDispatchedByInput[] | TransferUncheckedCreateWithoutDispatchedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDispatchedByInput | TransferCreateOrConnectWithoutDispatchedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDispatchedByInput | TransferUpsertWithWhereUniqueWithoutDispatchedByInput[]
    createMany?: TransferCreateManyDispatchedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDispatchedByInput | TransferUpdateWithWhereUniqueWithoutDispatchedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDispatchedByInput | TransferUpdateManyWithWhereWithoutDispatchedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<TransferCreateWithoutReceivedByInput, TransferUncheckedCreateWithoutReceivedByInput> | TransferCreateWithoutReceivedByInput[] | TransferUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutReceivedByInput | TransferCreateOrConnectWithoutReceivedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutReceivedByInput | TransferUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: TransferCreateManyReceivedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutReceivedByInput | TransferUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutReceivedByInput | TransferUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AttendanceEventUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutEmployeeInput | AttendanceEventUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutEmployeeInput, ShiftDaySummaryUncheckedCreateWithoutEmployeeInput> | ShiftDaySummaryCreateWithoutEmployeeInput[] | ShiftDaySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutEmployeeInput | ShiftDaySummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftDaySummaryUpsertWithWhereUniqueWithoutEmployeeInput | ShiftDaySummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftDaySummaryCreateManyEmployeeInputEnvelope
    set?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    disconnect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    delete?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    update?: ShiftDaySummaryUpdateWithWhereUniqueWithoutEmployeeInput | ShiftDaySummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftDaySummaryUpdateManyWithWhereWithoutEmployeeInput | ShiftDaySummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftDaySummaryScalarWhereInput | ShiftDaySummaryScalarWhereInput[]
  }

  export type PayrollEntryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutEmployeeInput | PayrollEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type ReminderUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReminderCreateWithoutCreatedByInput, ReminderUncheckedCreateWithoutCreatedByInput> | ReminderCreateWithoutCreatedByInput[] | ReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatedByInput | ReminderCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutCreatedByInput | ReminderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReminderCreateManyCreatedByInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutCreatedByInput | ReminderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutCreatedByInput | ReminderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StockLedgerCreateWithoutCreatedByInput, StockLedgerUncheckedCreateWithoutCreatedByInput> | StockLedgerCreateWithoutCreatedByInput[] | StockLedgerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutCreatedByInput | StockLedgerCreateOrConnectWithoutCreatedByInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutCreatedByInput | StockLedgerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StockLedgerCreateManyCreatedByInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutCreatedByInput | StockLedgerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutCreatedByInput | StockLedgerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<TransferCreateWithoutRequestedByInput, TransferUncheckedCreateWithoutRequestedByInput> | TransferCreateWithoutRequestedByInput[] | TransferUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutRequestedByInput | TransferCreateOrConnectWithoutRequestedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutRequestedByInput | TransferUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: TransferCreateManyRequestedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutRequestedByInput | TransferUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutRequestedByInput | TransferUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput> | TransferCreateWithoutApprovedByInput[] | TransferUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutApprovedByInput | TransferCreateOrConnectWithoutApprovedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutApprovedByInput | TransferUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: TransferCreateManyApprovedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutApprovedByInput | TransferUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutApprovedByInput | TransferUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutDispatchedByNestedInput = {
    create?: XOR<TransferCreateWithoutDispatchedByInput, TransferUncheckedCreateWithoutDispatchedByInput> | TransferCreateWithoutDispatchedByInput[] | TransferUncheckedCreateWithoutDispatchedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutDispatchedByInput | TransferCreateOrConnectWithoutDispatchedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutDispatchedByInput | TransferUpsertWithWhereUniqueWithoutDispatchedByInput[]
    createMany?: TransferCreateManyDispatchedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutDispatchedByInput | TransferUpdateWithWhereUniqueWithoutDispatchedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutDispatchedByInput | TransferUpdateManyWithWhereWithoutDispatchedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<TransferCreateWithoutReceivedByInput, TransferUncheckedCreateWithoutReceivedByInput> | TransferCreateWithoutReceivedByInput[] | TransferUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutReceivedByInput | TransferCreateOrConnectWithoutReceivedByInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutReceivedByInput | TransferUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: TransferCreateManyReceivedByInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutReceivedByInput | TransferUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutReceivedByInput | TransferUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput> | AttendanceEventCreateWithoutEmployeeInput[] | AttendanceEventUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceEventCreateOrConnectWithoutEmployeeInput | AttendanceEventCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceEventCreateManyEmployeeInputEnvelope
    set?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    disconnect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    delete?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    connect?: AttendanceEventWhereUniqueInput | AttendanceEventWhereUniqueInput[]
    update?: AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceEventUpdateManyWithWhereWithoutEmployeeInput | AttendanceEventUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
  }

  export type ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftDaySummaryCreateWithoutEmployeeInput, ShiftDaySummaryUncheckedCreateWithoutEmployeeInput> | ShiftDaySummaryCreateWithoutEmployeeInput[] | ShiftDaySummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftDaySummaryCreateOrConnectWithoutEmployeeInput | ShiftDaySummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftDaySummaryUpsertWithWhereUniqueWithoutEmployeeInput | ShiftDaySummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftDaySummaryCreateManyEmployeeInputEnvelope
    set?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    disconnect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    delete?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    connect?: ShiftDaySummaryWhereUniqueInput | ShiftDaySummaryWhereUniqueInput[]
    update?: ShiftDaySummaryUpdateWithWhereUniqueWithoutEmployeeInput | ShiftDaySummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftDaySummaryUpdateManyWithWhereWithoutEmployeeInput | ShiftDaySummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftDaySummaryScalarWhereInput | ShiftDaySummaryScalarWhereInput[]
  }

  export type PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutEmployeeInput | PayrollEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type ReminderUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ReminderCreateWithoutCreatedByInput, ReminderUncheckedCreateWithoutCreatedByInput> | ReminderCreateWithoutCreatedByInput[] | ReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ReminderCreateOrConnectWithoutCreatedByInput | ReminderCreateOrConnectWithoutCreatedByInput[]
    upsert?: ReminderUpsertWithWhereUniqueWithoutCreatedByInput | ReminderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ReminderCreateManyCreatedByInputEnvelope
    set?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    disconnect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    delete?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    connect?: ReminderWhereUniqueInput | ReminderWhereUniqueInput[]
    update?: ReminderUpdateWithWhereUniqueWithoutCreatedByInput | ReminderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ReminderUpdateManyWithWhereWithoutCreatedByInput | ReminderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeProfileInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmployeeProfileNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    upsert?: UserUpsertWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeProfileInput, UserUpdateWithoutEmployeeProfileInput>, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type KitchenStockCreateNestedManyWithoutItemInput = {
    create?: XOR<KitchenStockCreateWithoutItemInput, KitchenStockUncheckedCreateWithoutItemInput> | KitchenStockCreateWithoutItemInput[] | KitchenStockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutItemInput | KitchenStockCreateOrConnectWithoutItemInput[]
    createMany?: KitchenStockCreateManyItemInputEnvelope
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
  }

  export type StockLedgerCreateNestedManyWithoutItemInput = {
    create?: XOR<StockLedgerCreateWithoutItemInput, StockLedgerUncheckedCreateWithoutItemInput> | StockLedgerCreateWithoutItemInput[] | StockLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutItemInput | StockLedgerCreateOrConnectWithoutItemInput[]
    createMany?: StockLedgerCreateManyItemInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseLineCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type TransferLineCreateNestedManyWithoutItemInput = {
    create?: XOR<TransferLineCreateWithoutItemInput, TransferLineUncheckedCreateWithoutItemInput> | TransferLineCreateWithoutItemInput[] | TransferLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutItemInput | TransferLineCreateOrConnectWithoutItemInput[]
    createMany?: TransferLineCreateManyItemInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type KitchenStockUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<KitchenStockCreateWithoutItemInput, KitchenStockUncheckedCreateWithoutItemInput> | KitchenStockCreateWithoutItemInput[] | KitchenStockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutItemInput | KitchenStockCreateOrConnectWithoutItemInput[]
    createMany?: KitchenStockCreateManyItemInputEnvelope
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
  }

  export type StockLedgerUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<StockLedgerCreateWithoutItemInput, StockLedgerUncheckedCreateWithoutItemInput> | StockLedgerCreateWithoutItemInput[] | StockLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutItemInput | StockLedgerCreateOrConnectWithoutItemInput[]
    createMany?: StockLedgerCreateManyItemInputEnvelope
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
  }

  export type PurchaseLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type TransferLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<TransferLineCreateWithoutItemInput, TransferLineUncheckedCreateWithoutItemInput> | TransferLineCreateWithoutItemInput[] | TransferLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutItemInput | TransferLineCreateOrConnectWithoutItemInput[]
    createMany?: TransferLineCreateManyItemInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KitchenStockUpdateManyWithoutItemNestedInput = {
    create?: XOR<KitchenStockCreateWithoutItemInput, KitchenStockUncheckedCreateWithoutItemInput> | KitchenStockCreateWithoutItemInput[] | KitchenStockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutItemInput | KitchenStockCreateOrConnectWithoutItemInput[]
    upsert?: KitchenStockUpsertWithWhereUniqueWithoutItemInput | KitchenStockUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: KitchenStockCreateManyItemInputEnvelope
    set?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    disconnect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    delete?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    update?: KitchenStockUpdateWithWhereUniqueWithoutItemInput | KitchenStockUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: KitchenStockUpdateManyWithWhereWithoutItemInput | KitchenStockUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: KitchenStockScalarWhereInput | KitchenStockScalarWhereInput[]
  }

  export type StockLedgerUpdateManyWithoutItemNestedInput = {
    create?: XOR<StockLedgerCreateWithoutItemInput, StockLedgerUncheckedCreateWithoutItemInput> | StockLedgerCreateWithoutItemInput[] | StockLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutItemInput | StockLedgerCreateOrConnectWithoutItemInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutItemInput | StockLedgerUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StockLedgerCreateManyItemInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutItemInput | StockLedgerUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutItemInput | StockLedgerUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutItemInput | PurchaseLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutItemInput | PurchaseLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutItemInput | PurchaseLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type TransferLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<TransferLineCreateWithoutItemInput, TransferLineUncheckedCreateWithoutItemInput> | TransferLineCreateWithoutItemInput[] | TransferLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutItemInput | TransferLineCreateOrConnectWithoutItemInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutItemInput | TransferLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: TransferLineCreateManyItemInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutItemInput | TransferLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutItemInput | TransferLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type KitchenStockUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<KitchenStockCreateWithoutItemInput, KitchenStockUncheckedCreateWithoutItemInput> | KitchenStockCreateWithoutItemInput[] | KitchenStockUncheckedCreateWithoutItemInput[]
    connectOrCreate?: KitchenStockCreateOrConnectWithoutItemInput | KitchenStockCreateOrConnectWithoutItemInput[]
    upsert?: KitchenStockUpsertWithWhereUniqueWithoutItemInput | KitchenStockUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: KitchenStockCreateManyItemInputEnvelope
    set?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    disconnect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    delete?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    connect?: KitchenStockWhereUniqueInput | KitchenStockWhereUniqueInput[]
    update?: KitchenStockUpdateWithWhereUniqueWithoutItemInput | KitchenStockUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: KitchenStockUpdateManyWithWhereWithoutItemInput | KitchenStockUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: KitchenStockScalarWhereInput | KitchenStockScalarWhereInput[]
  }

  export type StockLedgerUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<StockLedgerCreateWithoutItemInput, StockLedgerUncheckedCreateWithoutItemInput> | StockLedgerCreateWithoutItemInput[] | StockLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockLedgerCreateOrConnectWithoutItemInput | StockLedgerCreateOrConnectWithoutItemInput[]
    upsert?: StockLedgerUpsertWithWhereUniqueWithoutItemInput | StockLedgerUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StockLedgerCreateManyItemInputEnvelope
    set?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    disconnect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    delete?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    connect?: StockLedgerWhereUniqueInput | StockLedgerWhereUniqueInput[]
    update?: StockLedgerUpdateWithWhereUniqueWithoutItemInput | StockLedgerUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StockLedgerUpdateManyWithWhereWithoutItemInput | StockLedgerUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
  }

  export type PurchaseLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutItemInput | PurchaseLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutItemInput | PurchaseLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutItemInput | PurchaseLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type TransferLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<TransferLineCreateWithoutItemInput, TransferLineUncheckedCreateWithoutItemInput> | TransferLineCreateWithoutItemInput[] | TransferLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutItemInput | TransferLineCreateOrConnectWithoutItemInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutItemInput | TransferLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: TransferLineCreateManyItemInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutItemInput | TransferLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutItemInput | TransferLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type KitchenCreateNestedOneWithoutStocksInput = {
    create?: XOR<KitchenCreateWithoutStocksInput, KitchenUncheckedCreateWithoutStocksInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutStocksInput
    connect?: KitchenWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutStocksInput = {
    create?: XOR<ItemCreateWithoutStocksInput, ItemUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStocksInput
    connect?: ItemWhereUniqueInput
  }

  export type KitchenUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<KitchenCreateWithoutStocksInput, KitchenUncheckedCreateWithoutStocksInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutStocksInput
    upsert?: KitchenUpsertWithoutStocksInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutStocksInput, KitchenUpdateWithoutStocksInput>, KitchenUncheckedUpdateWithoutStocksInput>
  }

  export type ItemUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<ItemCreateWithoutStocksInput, ItemUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStocksInput
    upsert?: ItemUpsertWithoutStocksInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutStocksInput, ItemUpdateWithoutStocksInput>, ItemUncheckedUpdateWithoutStocksInput>
  }

  export type KitchenCreateNestedOneWithoutLedgerInput = {
    create?: XOR<KitchenCreateWithoutLedgerInput, KitchenUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutLedgerInput
    connect?: KitchenWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutLedgerInput = {
    create?: XOR<ItemCreateWithoutLedgerInput, ItemUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: ItemCreateOrConnectWithoutLedgerInput
    connect?: ItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedLedgerEntriesInput = {
    create?: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLedgerEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStockLedgerTypeFieldUpdateOperationsInput = {
    set?: $Enums.StockLedgerType
  }

  export type KitchenUpdateOneRequiredWithoutLedgerNestedInput = {
    create?: XOR<KitchenCreateWithoutLedgerInput, KitchenUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutLedgerInput
    upsert?: KitchenUpsertWithoutLedgerInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutLedgerInput, KitchenUpdateWithoutLedgerInput>, KitchenUncheckedUpdateWithoutLedgerInput>
  }

  export type ItemUpdateOneRequiredWithoutLedgerNestedInput = {
    create?: XOR<ItemCreateWithoutLedgerInput, ItemUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: ItemCreateOrConnectWithoutLedgerInput
    upsert?: ItemUpsertWithoutLedgerInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutLedgerInput, ItemUpdateWithoutLedgerInput>, ItemUncheckedUpdateWithoutLedgerInput>
  }

  export type UserUpdateOneWithoutCreatedLedgerEntriesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLedgerEntriesInput
    upsert?: UserUpsertWithoutCreatedLedgerEntriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedLedgerEntriesInput, UserUpdateWithoutCreatedLedgerEntriesInput>, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
  }

  export type KitchenCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<KitchenCreateWithoutPurchasesInput, KitchenUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutPurchasesInput
    connect?: KitchenWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseLineCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseOrderInput, PurchaseLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseLineCreateWithoutPurchaseOrderInput[] | PurchaseLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseLineCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseLineCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type PurchaseLineUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseOrderInput, PurchaseLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseLineCreateWithoutPurchaseOrderInput[] | PurchaseLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseLineCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseLineCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type KitchenUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<KitchenCreateWithoutPurchasesInput, KitchenUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutPurchasesInput
    upsert?: KitchenUpsertWithoutPurchasesInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutPurchasesInput, KitchenUpdateWithoutPurchasesInput>, KitchenUncheckedUpdateWithoutPurchasesInput>
  }

  export type SupplierUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseLineUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseOrderInput, PurchaseLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseLineCreateWithoutPurchaseOrderInput[] | PurchaseLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseLineCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseLineUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseLineCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseLineUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseLineUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type PurchaseLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseOrderInput, PurchaseLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseLineCreateWithoutPurchaseOrderInput[] | PurchaseLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseLineCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseLineUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseLineCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseLineUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseLineUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPurchaseLinesInput = {
    create?: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    upsert?: PurchaseOrderUpsertWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutLinesInput, PurchaseOrderUpdateWithoutLinesInput>, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutPurchaseLinesNestedInput = {
    create?: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseLinesInput
    upsert?: ItemUpsertWithoutPurchaseLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPurchaseLinesInput, ItemUpdateWithoutPurchaseLinesInput>, ItemUncheckedUpdateWithoutPurchaseLinesInput>
  }

  export type KitchenCreateNestedOneWithoutTransfersFromInput = {
    create?: XOR<KitchenCreateWithoutTransfersFromInput, KitchenUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutTransfersFromInput
    connect?: KitchenWhereUniqueInput
  }

  export type KitchenCreateNestedOneWithoutTransfersToInput = {
    create?: XOR<KitchenCreateWithoutTransfersToInput, KitchenUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutTransfersToInput
    connect?: KitchenWhereUniqueInput
  }

  export type TransferLineCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutRequestedTransfersInput = {
    create?: XOR<UserCreateWithoutRequestedTransfersInput, UserUncheckedCreateWithoutRequestedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedTransfersInput = {
    create?: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDispatchedTransfersInput = {
    create?: XOR<UserCreateWithoutDispatchedTransfersInput, UserUncheckedCreateWithoutDispatchedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispatchedTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedTransfersInput = {
    create?: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedTransfersInput
    connect?: UserWhereUniqueInput
  }

  export type TransferLineUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type KitchenUpdateOneRequiredWithoutTransfersFromNestedInput = {
    create?: XOR<KitchenCreateWithoutTransfersFromInput, KitchenUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutTransfersFromInput
    upsert?: KitchenUpsertWithoutTransfersFromInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutTransfersFromInput, KitchenUpdateWithoutTransfersFromInput>, KitchenUncheckedUpdateWithoutTransfersFromInput>
  }

  export type KitchenUpdateOneRequiredWithoutTransfersToNestedInput = {
    create?: XOR<KitchenCreateWithoutTransfersToInput, KitchenUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutTransfersToInput
    upsert?: KitchenUpsertWithoutTransfersToInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutTransfersToInput, KitchenUpdateWithoutTransfersToInput>, KitchenUncheckedUpdateWithoutTransfersToInput>
  }

  export type TransferLineUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutTransferInput | TransferLineUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutTransferInput | TransferLineUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutTransferInput | TransferLineUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type UserUpdateOneWithoutRequestedTransfersNestedInput = {
    create?: XOR<UserCreateWithoutRequestedTransfersInput, UserUncheckedCreateWithoutRequestedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedTransfersInput
    upsert?: UserUpsertWithoutRequestedTransfersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestedTransfersInput, UserUpdateWithoutRequestedTransfersInput>, UserUncheckedUpdateWithoutRequestedTransfersInput>
  }

  export type UserUpdateOneWithoutApprovedTransfersNestedInput = {
    create?: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedTransfersInput
    upsert?: UserUpsertWithoutApprovedTransfersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedTransfersInput, UserUpdateWithoutApprovedTransfersInput>, UserUncheckedUpdateWithoutApprovedTransfersInput>
  }

  export type UserUpdateOneWithoutDispatchedTransfersNestedInput = {
    create?: XOR<UserCreateWithoutDispatchedTransfersInput, UserUncheckedCreateWithoutDispatchedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispatchedTransfersInput
    upsert?: UserUpsertWithoutDispatchedTransfersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDispatchedTransfersInput, UserUpdateWithoutDispatchedTransfersInput>, UserUncheckedUpdateWithoutDispatchedTransfersInput>
  }

  export type UserUpdateOneWithoutReceivedTransfersNestedInput = {
    create?: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedTransfersInput
    upsert?: UserUpsertWithoutReceivedTransfersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedTransfersInput, UserUpdateWithoutReceivedTransfersInput>, UserUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type TransferLineUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput> | TransferLineCreateWithoutTransferInput[] | TransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferLineCreateOrConnectWithoutTransferInput | TransferLineCreateOrConnectWithoutTransferInput[]
    upsert?: TransferLineUpsertWithWhereUniqueWithoutTransferInput | TransferLineUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferLineCreateManyTransferInputEnvelope
    set?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    disconnect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    delete?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    connect?: TransferLineWhereUniqueInput | TransferLineWhereUniqueInput[]
    update?: TransferLineUpdateWithWhereUniqueWithoutTransferInput | TransferLineUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferLineUpdateManyWithWhereWithoutTransferInput | TransferLineUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
  }

  export type TransferCreateNestedOneWithoutLinesInput = {
    create?: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
    connectOrCreate?: TransferCreateOrConnectWithoutLinesInput
    connect?: TransferWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutTransferLinesInput = {
    create?: XOR<ItemCreateWithoutTransferLinesInput, ItemUncheckedCreateWithoutTransferLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTransferLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type TransferUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
    connectOrCreate?: TransferCreateOrConnectWithoutLinesInput
    upsert?: TransferUpsertWithoutLinesInput
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutLinesInput, TransferUpdateWithoutLinesInput>, TransferUncheckedUpdateWithoutLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutTransferLinesNestedInput = {
    create?: XOR<ItemCreateWithoutTransferLinesInput, ItemUncheckedCreateWithoutTransferLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTransferLinesInput
    upsert?: ItemUpsertWithoutTransferLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutTransferLinesInput, ItemUpdateWithoutTransferLinesInput>, ItemUncheckedUpdateWithoutTransferLinesInput>
  }

  export type UserCreateNestedOneWithoutAttendanceEventsInput = {
    create?: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceEventsInput
    connect?: UserWhereUniqueInput
  }

  export type KitchenCreateNestedOneWithoutAttendanceEventsInput = {
    create?: XOR<KitchenCreateWithoutAttendanceEventsInput, KitchenUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutAttendanceEventsInput
    connect?: KitchenWhereUniqueInput
  }

  export type EnumAttendanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceType
  }

  export type EnumAttendanceMethodFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceMethod
  }

  export type UserUpdateOneRequiredWithoutAttendanceEventsNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceEventsInput
    upsert?: UserUpsertWithoutAttendanceEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceEventsInput, UserUpdateWithoutAttendanceEventsInput>, UserUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type KitchenUpdateOneRequiredWithoutAttendanceEventsNestedInput = {
    create?: XOR<KitchenCreateWithoutAttendanceEventsInput, KitchenUncheckedCreateWithoutAttendanceEventsInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutAttendanceEventsInput
    upsert?: KitchenUpsertWithoutAttendanceEventsInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutAttendanceEventsInput, KitchenUpdateWithoutAttendanceEventsInput>, KitchenUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type UserCreateNestedOneWithoutShiftSummariesInput = {
    create?: XOR<UserCreateWithoutShiftSummariesInput, UserUncheckedCreateWithoutShiftSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftSummariesInput
    connect?: UserWhereUniqueInput
  }

  export type KitchenCreateNestedOneWithoutShiftSummariesInput = {
    create?: XOR<KitchenCreateWithoutShiftSummariesInput, KitchenUncheckedCreateWithoutShiftSummariesInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutShiftSummariesInput
    connect?: KitchenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutShiftSummariesNestedInput = {
    create?: XOR<UserCreateWithoutShiftSummariesInput, UserUncheckedCreateWithoutShiftSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftSummariesInput
    upsert?: UserUpsertWithoutShiftSummariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftSummariesInput, UserUpdateWithoutShiftSummariesInput>, UserUncheckedUpdateWithoutShiftSummariesInput>
  }

  export type KitchenUpdateOneRequiredWithoutShiftSummariesNestedInput = {
    create?: XOR<KitchenCreateWithoutShiftSummariesInput, KitchenUncheckedCreateWithoutShiftSummariesInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutShiftSummariesInput
    upsert?: KitchenUpsertWithoutShiftSummariesInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutShiftSummariesInput, KitchenUpdateWithoutShiftSummariesInput>, KitchenUncheckedUpdateWithoutShiftSummariesInput>
  }

  export type PayrollEntryCreateNestedManyWithoutPeriodInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type PayrollEntryUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type EnumPayrollPeriodStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayrollPeriodStatus
  }

  export type PayrollEntryUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput | PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput | PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutPeriodInput | PayrollEntryUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type PayrollEntryUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput> | PayrollEntryCreateWithoutPeriodInput[] | PayrollEntryUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPeriodInput | PayrollEntryCreateOrConnectWithoutPeriodInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput | PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: PayrollEntryCreateManyPeriodInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput | PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutPeriodInput | PayrollEntryUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type PayrollPeriodCreateNestedOneWithoutEntriesInput = {
    create?: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutEntriesInput
    connect?: PayrollPeriodWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPayrollEntriesInput = {
    create?: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type PayrollPeriodUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: PayrollPeriodCreateOrConnectWithoutEntriesInput
    upsert?: PayrollPeriodUpsertWithoutEntriesInput
    connect?: PayrollPeriodWhereUniqueInput
    update?: XOR<XOR<PayrollPeriodUpdateToOneWithWhereWithoutEntriesInput, PayrollPeriodUpdateWithoutEntriesInput>, PayrollPeriodUncheckedUpdateWithoutEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutPayrollEntriesNestedInput = {
    create?: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollEntriesInput
    upsert?: UserUpsertWithoutPayrollEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPayrollEntriesInput, UserUpdateWithoutPayrollEntriesInput>, UserUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type UserCreateNestedOneWithoutRemindersCreatedInput = {
    create?: XOR<UserCreateWithoutRemindersCreatedInput, UserUncheckedCreateWithoutRemindersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRemindersCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReminderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReminderType
  }

  export type EnumReminderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReminderStatus
  }

  export type UserUpdateOneWithoutRemindersCreatedNestedInput = {
    create?: XOR<UserCreateWithoutRemindersCreatedInput, UserUncheckedCreateWithoutRemindersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRemindersCreatedInput
    upsert?: UserUpsertWithoutRemindersCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRemindersCreatedInput, UserUpdateWithoutRemindersCreatedInput>, UserUncheckedUpdateWithoutRemindersCreatedInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumKitchenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenType | EnumKitchenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenTypeFilter<$PrismaModel> | $Enums.KitchenType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumKitchenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenType | EnumKitchenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenType[] | ListEnumKitchenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenTypeWithAggregatesFilter<$PrismaModel> | $Enums.KitchenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKitchenTypeFilter<$PrismaModel>
    _max?: NestedEnumKitchenTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStockLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockLedgerType | EnumStockLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockLedgerTypeFilter<$PrismaModel> | $Enums.StockLedgerType
  }

  export type NestedEnumStockLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockLedgerType | EnumStockLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockLedgerType[] | ListEnumStockLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockLedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumStockLedgerTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeFilter<$PrismaModel> | $Enums.AttendanceType
  }

  export type NestedEnumAttendanceMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMethod | EnumAttendanceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceMethodFilter<$PrismaModel> | $Enums.AttendanceMethod
  }

  export type NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceType | EnumAttendanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceType[] | ListEnumAttendanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceTypeFilter<$PrismaModel>
    _max?: NestedEnumAttendanceTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMethod | EnumAttendanceMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceMethod[] | ListEnumAttendanceMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceMethodWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceMethodFilter<$PrismaModel>
    _max?: NestedEnumAttendanceMethodFilter<$PrismaModel>
  }

  export type NestedEnumPayrollPeriodStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
  }

  export type NestedEnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollPeriodStatus | EnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollPeriodStatus[] | ListEnumPayrollPeriodStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollPeriodStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollPeriodStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollPeriodStatusFilter<$PrismaModel>
  }

  export type NestedEnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type NestedEnumReminderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusFilter<$PrismaModel> | $Enums.ReminderStatus
  }

  export type NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderStatus | EnumReminderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderStatus[] | ListEnumReminderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReminderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderStatusFilter<$PrismaModel>
    _max?: NestedEnumReminderStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutKitchenInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutKitchenInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutKitchenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKitchenInput, UserUncheckedCreateWithoutKitchenInput>
  }

  export type UserCreateManyKitchenInputEnvelope = {
    data: UserCreateManyKitchenInput | UserCreateManyKitchenInput[]
    skipDuplicates?: boolean
  }

  export type KitchenStockCreateWithoutKitchenInput = {
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutStocksInput
  }

  export type KitchenStockUncheckedCreateWithoutKitchenInput = {
    itemId: string
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
  }

  export type KitchenStockCreateOrConnectWithoutKitchenInput = {
    where: KitchenStockWhereUniqueInput
    create: XOR<KitchenStockCreateWithoutKitchenInput, KitchenStockUncheckedCreateWithoutKitchenInput>
  }

  export type KitchenStockCreateManyKitchenInputEnvelope = {
    data: KitchenStockCreateManyKitchenInput | KitchenStockCreateManyKitchenInput[]
    skipDuplicates?: boolean
  }

  export type StockLedgerCreateWithoutKitchenInput = {
    id?: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutLedgerInput
    createdBy?: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
  }

  export type StockLedgerUncheckedCreateWithoutKitchenInput = {
    id?: string
    itemId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutKitchenInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutKitchenInput, StockLedgerUncheckedCreateWithoutKitchenInput>
  }

  export type StockLedgerCreateManyKitchenInputEnvelope = {
    data: StockLedgerCreateManyKitchenInput | StockLedgerCreateManyKitchenInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutKitchenInput = {
    id?: string
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    lines?: PurchaseLineCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutKitchenInput = {
    id?: string
    supplierId?: string | null
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutKitchenInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutKitchenInput, PurchaseOrderUncheckedCreateWithoutKitchenInput>
  }

  export type PurchaseOrderCreateManyKitchenInputEnvelope = {
    data: PurchaseOrderCreateManyKitchenInput | PurchaseOrderCreateManyKitchenInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutFromKitchenInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    toKitchen: KitchenCreateNestedOneWithoutTransfersToInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
    requestedBy?: UserCreateNestedOneWithoutRequestedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
    dispatchedBy?: UserCreateNestedOneWithoutDispatchedTransfersInput
    receivedBy?: UserCreateNestedOneWithoutReceivedTransfersInput
  }

  export type TransferUncheckedCreateWithoutFromKitchenInput = {
    id?: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutFromKitchenInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutFromKitchenInput, TransferUncheckedCreateWithoutFromKitchenInput>
  }

  export type TransferCreateManyFromKitchenInputEnvelope = {
    data: TransferCreateManyFromKitchenInput | TransferCreateManyFromKitchenInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutToKitchenInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    fromKitchen: KitchenCreateNestedOneWithoutTransfersFromInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
    requestedBy?: UserCreateNestedOneWithoutRequestedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
    dispatchedBy?: UserCreateNestedOneWithoutDispatchedTransfersInput
    receivedBy?: UserCreateNestedOneWithoutReceivedTransfersInput
  }

  export type TransferUncheckedCreateWithoutToKitchenInput = {
    id?: string
    fromKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutToKitchenInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutToKitchenInput, TransferUncheckedCreateWithoutToKitchenInput>
  }

  export type TransferCreateManyToKitchenInputEnvelope = {
    data: TransferCreateManyToKitchenInput | TransferCreateManyToKitchenInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceEventCreateWithoutKitchenInput = {
    id?: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
    employee: UserCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutKitchenInput = {
    id?: string
    employeeUserId: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type AttendanceEventCreateOrConnectWithoutKitchenInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutKitchenInput, AttendanceEventUncheckedCreateWithoutKitchenInput>
  }

  export type AttendanceEventCreateManyKitchenInputEnvelope = {
    data: AttendanceEventCreateManyKitchenInput | AttendanceEventCreateManyKitchenInput[]
    skipDuplicates?: boolean
  }

  export type ShiftDaySummaryCreateWithoutKitchenInput = {
    id?: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutShiftSummariesInput
  }

  export type ShiftDaySummaryUncheckedCreateWithoutKitchenInput = {
    id?: string
    employeeUserId: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftDaySummaryCreateOrConnectWithoutKitchenInput = {
    where: ShiftDaySummaryWhereUniqueInput
    create: XOR<ShiftDaySummaryCreateWithoutKitchenInput, ShiftDaySummaryUncheckedCreateWithoutKitchenInput>
  }

  export type ShiftDaySummaryCreateManyKitchenInputEnvelope = {
    data: ShiftDaySummaryCreateManyKitchenInput | ShiftDaySummaryCreateManyKitchenInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutKitchenInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutKitchenInput, UserUncheckedUpdateWithoutKitchenInput>
    create: XOR<UserCreateWithoutKitchenInput, UserUncheckedCreateWithoutKitchenInput>
  }

  export type UserUpdateWithWhereUniqueWithoutKitchenInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutKitchenInput, UserUncheckedUpdateWithoutKitchenInput>
  }

  export type UserUpdateManyWithWhereWithoutKitchenInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutKitchenInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    kitchenId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type KitchenStockUpsertWithWhereUniqueWithoutKitchenInput = {
    where: KitchenStockWhereUniqueInput
    update: XOR<KitchenStockUpdateWithoutKitchenInput, KitchenStockUncheckedUpdateWithoutKitchenInput>
    create: XOR<KitchenStockCreateWithoutKitchenInput, KitchenStockUncheckedCreateWithoutKitchenInput>
  }

  export type KitchenStockUpdateWithWhereUniqueWithoutKitchenInput = {
    where: KitchenStockWhereUniqueInput
    data: XOR<KitchenStockUpdateWithoutKitchenInput, KitchenStockUncheckedUpdateWithoutKitchenInput>
  }

  export type KitchenStockUpdateManyWithWhereWithoutKitchenInput = {
    where: KitchenStockScalarWhereInput
    data: XOR<KitchenStockUpdateManyMutationInput, KitchenStockUncheckedUpdateManyWithoutKitchenInput>
  }

  export type KitchenStockScalarWhereInput = {
    AND?: KitchenStockScalarWhereInput | KitchenStockScalarWhereInput[]
    OR?: KitchenStockScalarWhereInput[]
    NOT?: KitchenStockScalarWhereInput | KitchenStockScalarWhereInput[]
    kitchenId?: StringFilter<"KitchenStock"> | string
    itemId?: StringFilter<"KitchenStock"> | string
    onHandQty?: FloatFilter<"KitchenStock"> | number
    avgCost?: FloatFilter<"KitchenStock"> | number
    updatedAt?: DateTimeFilter<"KitchenStock"> | Date | string
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutKitchenInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutKitchenInput, StockLedgerUncheckedUpdateWithoutKitchenInput>
    create: XOR<StockLedgerCreateWithoutKitchenInput, StockLedgerUncheckedCreateWithoutKitchenInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutKitchenInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutKitchenInput, StockLedgerUncheckedUpdateWithoutKitchenInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutKitchenInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutKitchenInput>
  }

  export type StockLedgerScalarWhereInput = {
    AND?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
    OR?: StockLedgerScalarWhereInput[]
    NOT?: StockLedgerScalarWhereInput | StockLedgerScalarWhereInput[]
    id?: StringFilter<"StockLedger"> | string
    kitchenId?: StringFilter<"StockLedger"> | string
    itemId?: StringFilter<"StockLedger"> | string
    type?: EnumStockLedgerTypeFilter<"StockLedger"> | $Enums.StockLedgerType
    qtyDelta?: FloatFilter<"StockLedger"> | number
    unitCost?: FloatNullableFilter<"StockLedger"> | number | null
    refType?: StringNullableFilter<"StockLedger"> | string | null
    refId?: StringNullableFilter<"StockLedger"> | string | null
    createdByUserId?: StringNullableFilter<"StockLedger"> | string | null
    createdAt?: DateTimeFilter<"StockLedger"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutKitchenInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutKitchenInput, PurchaseOrderUncheckedUpdateWithoutKitchenInput>
    create: XOR<PurchaseOrderCreateWithoutKitchenInput, PurchaseOrderUncheckedCreateWithoutKitchenInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutKitchenInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutKitchenInput, PurchaseOrderUncheckedUpdateWithoutKitchenInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutKitchenInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutKitchenInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    kitchenId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringNullableFilter<"PurchaseOrder"> | string | null
    status?: StringFilter<"PurchaseOrder"> | string
    createdByUserId?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutFromKitchenInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutFromKitchenInput, TransferUncheckedUpdateWithoutFromKitchenInput>
    create: XOR<TransferCreateWithoutFromKitchenInput, TransferUncheckedCreateWithoutFromKitchenInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutFromKitchenInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutFromKitchenInput, TransferUncheckedUpdateWithoutFromKitchenInput>
  }

  export type TransferUpdateManyWithWhereWithoutFromKitchenInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutFromKitchenInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    fromKitchenId?: StringFilter<"Transfer"> | string
    toKitchenId?: StringFilter<"Transfer"> | string
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    requestedByUserId?: StringNullableFilter<"Transfer"> | string | null
    approvedByUserId?: StringNullableFilter<"Transfer"> | string | null
    dispatchedByUserId?: StringNullableFilter<"Transfer"> | string | null
    receivedByUserId?: StringNullableFilter<"Transfer"> | string | null
    requestedAt?: DateTimeFilter<"Transfer"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
  }

  export type TransferUpsertWithWhereUniqueWithoutToKitchenInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutToKitchenInput, TransferUncheckedUpdateWithoutToKitchenInput>
    create: XOR<TransferCreateWithoutToKitchenInput, TransferUncheckedCreateWithoutToKitchenInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutToKitchenInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutToKitchenInput, TransferUncheckedUpdateWithoutToKitchenInput>
  }

  export type TransferUpdateManyWithWhereWithoutToKitchenInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutToKitchenInput>
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutKitchenInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutKitchenInput, AttendanceEventUncheckedUpdateWithoutKitchenInput>
    create: XOR<AttendanceEventCreateWithoutKitchenInput, AttendanceEventUncheckedCreateWithoutKitchenInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutKitchenInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutKitchenInput, AttendanceEventUncheckedUpdateWithoutKitchenInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutKitchenInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutKitchenInput>
  }

  export type AttendanceEventScalarWhereInput = {
    AND?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
    OR?: AttendanceEventScalarWhereInput[]
    NOT?: AttendanceEventScalarWhereInput | AttendanceEventScalarWhereInput[]
    id?: StringFilter<"AttendanceEvent"> | string
    employeeUserId?: StringFilter<"AttendanceEvent"> | string
    kitchenId?: StringFilter<"AttendanceEvent"> | string
    type?: EnumAttendanceTypeFilter<"AttendanceEvent"> | $Enums.AttendanceType
    method?: EnumAttendanceMethodFilter<"AttendanceEvent"> | $Enums.AttendanceMethod
    lat?: FloatNullableFilter<"AttendanceEvent"> | number | null
    lng?: FloatNullableFilter<"AttendanceEvent"> | number | null
    distanceMeters?: FloatNullableFilter<"AttendanceEvent"> | number | null
    createdAt?: DateTimeFilter<"AttendanceEvent"> | Date | string
  }

  export type ShiftDaySummaryUpsertWithWhereUniqueWithoutKitchenInput = {
    where: ShiftDaySummaryWhereUniqueInput
    update: XOR<ShiftDaySummaryUpdateWithoutKitchenInput, ShiftDaySummaryUncheckedUpdateWithoutKitchenInput>
    create: XOR<ShiftDaySummaryCreateWithoutKitchenInput, ShiftDaySummaryUncheckedCreateWithoutKitchenInput>
  }

  export type ShiftDaySummaryUpdateWithWhereUniqueWithoutKitchenInput = {
    where: ShiftDaySummaryWhereUniqueInput
    data: XOR<ShiftDaySummaryUpdateWithoutKitchenInput, ShiftDaySummaryUncheckedUpdateWithoutKitchenInput>
  }

  export type ShiftDaySummaryUpdateManyWithWhereWithoutKitchenInput = {
    where: ShiftDaySummaryScalarWhereInput
    data: XOR<ShiftDaySummaryUpdateManyMutationInput, ShiftDaySummaryUncheckedUpdateManyWithoutKitchenInput>
  }

  export type ShiftDaySummaryScalarWhereInput = {
    AND?: ShiftDaySummaryScalarWhereInput | ShiftDaySummaryScalarWhereInput[]
    OR?: ShiftDaySummaryScalarWhereInput[]
    NOT?: ShiftDaySummaryScalarWhereInput | ShiftDaySummaryScalarWhereInput[]
    id?: StringFilter<"ShiftDaySummary"> | string
    employeeUserId?: StringFilter<"ShiftDaySummary"> | string
    kitchenId?: StringFilter<"ShiftDaySummary"> | string
    date?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    minutesWorked?: IntFilter<"ShiftDaySummary"> | number
    minutesLate?: IntFilter<"ShiftDaySummary"> | number
    overtimeMinutes?: IntFilter<"ShiftDaySummary"> | number
    createdAt?: DateTimeFilter<"ShiftDaySummary"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftDaySummary"> | Date | string
  }

  export type KitchenCreateWithoutUsersInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutUsersInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutUsersInput, KitchenUncheckedCreateWithoutUsersInput>
  }

  export type EmployeeProfileCreateWithoutUserInput = {
    fullName: string
    baseSalaryMonthly: number
    overtimeRatePerHour?: number
    latePenaltyPerMinute?: number
    joinDate?: Date | string
  }

  export type EmployeeProfileUncheckedCreateWithoutUserInput = {
    fullName: string
    baseSalaryMonthly: number
    overtimeRatePerHour?: number
    latePenaltyPerMinute?: number
    joinDate?: Date | string
  }

  export type EmployeeProfileCreateOrConnectWithoutUserInput = {
    where: EmployeeProfileWhereUniqueInput
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
  }

  export type StockLedgerCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutLedgerInput
    item: ItemCreateNestedOneWithoutLedgerInput
  }

  export type StockLedgerUncheckedCreateWithoutCreatedByInput = {
    id?: string
    kitchenId: string
    itemId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutCreatedByInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutCreatedByInput, StockLedgerUncheckedCreateWithoutCreatedByInput>
  }

  export type StockLedgerCreateManyCreatedByInputEnvelope = {
    data: StockLedgerCreateManyCreatedByInput | StockLedgerCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutRequestedByInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    fromKitchen: KitchenCreateNestedOneWithoutTransfersFromInput
    toKitchen: KitchenCreateNestedOneWithoutTransfersToInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
    dispatchedBy?: UserCreateNestedOneWithoutDispatchedTransfersInput
    receivedBy?: UserCreateNestedOneWithoutReceivedTransfersInput
  }

  export type TransferUncheckedCreateWithoutRequestedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutRequestedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutRequestedByInput, TransferUncheckedCreateWithoutRequestedByInput>
  }

  export type TransferCreateManyRequestedByInputEnvelope = {
    data: TransferCreateManyRequestedByInput | TransferCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutApprovedByInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    fromKitchen: KitchenCreateNestedOneWithoutTransfersFromInput
    toKitchen: KitchenCreateNestedOneWithoutTransfersToInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
    requestedBy?: UserCreateNestedOneWithoutRequestedTransfersInput
    dispatchedBy?: UserCreateNestedOneWithoutDispatchedTransfersInput
    receivedBy?: UserCreateNestedOneWithoutReceivedTransfersInput
  }

  export type TransferUncheckedCreateWithoutApprovedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutApprovedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput>
  }

  export type TransferCreateManyApprovedByInputEnvelope = {
    data: TransferCreateManyApprovedByInput | TransferCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutDispatchedByInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    fromKitchen: KitchenCreateNestedOneWithoutTransfersFromInput
    toKitchen: KitchenCreateNestedOneWithoutTransfersToInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
    requestedBy?: UserCreateNestedOneWithoutRequestedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
    receivedBy?: UserCreateNestedOneWithoutReceivedTransfersInput
  }

  export type TransferUncheckedCreateWithoutDispatchedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutDispatchedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutDispatchedByInput, TransferUncheckedCreateWithoutDispatchedByInput>
  }

  export type TransferCreateManyDispatchedByInputEnvelope = {
    data: TransferCreateManyDispatchedByInput | TransferCreateManyDispatchedByInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutReceivedByInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    fromKitchen: KitchenCreateNestedOneWithoutTransfersFromInput
    toKitchen: KitchenCreateNestedOneWithoutTransfersToInput
    lines?: TransferLineCreateNestedManyWithoutTransferInput
    requestedBy?: UserCreateNestedOneWithoutRequestedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
    dispatchedBy?: UserCreateNestedOneWithoutDispatchedTransfersInput
  }

  export type TransferUncheckedCreateWithoutReceivedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    lines?: TransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutReceivedByInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutReceivedByInput, TransferUncheckedCreateWithoutReceivedByInput>
  }

  export type TransferCreateManyReceivedByInputEnvelope = {
    data: TransferCreateManyReceivedByInput | TransferCreateManyReceivedByInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceEventCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutAttendanceEventsInput
  }

  export type AttendanceEventUncheckedCreateWithoutEmployeeInput = {
    id?: string
    kitchenId: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type AttendanceEventCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceEventWhereUniqueInput
    create: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceEventCreateManyEmployeeInputEnvelope = {
    data: AttendanceEventCreateManyEmployeeInput | AttendanceEventCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ShiftDaySummaryCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutShiftSummariesInput
  }

  export type ShiftDaySummaryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    kitchenId: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftDaySummaryCreateOrConnectWithoutEmployeeInput = {
    where: ShiftDaySummaryWhereUniqueInput
    create: XOR<ShiftDaySummaryCreateWithoutEmployeeInput, ShiftDaySummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftDaySummaryCreateManyEmployeeInputEnvelope = {
    data: ShiftDaySummaryCreateManyEmployeeInput | ShiftDaySummaryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PayrollEntryCreateWithoutEmployeeInput = {
    id?: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PayrollPeriodCreateNestedOneWithoutEntriesInput
  }

  export type PayrollEntryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    periodId: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateOrConnectWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    create: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollEntryCreateManyEmployeeInputEnvelope = {
    data: PayrollEntryCreateManyEmployeeInput | PayrollEntryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ReminderCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.ReminderType
    dueAt: Date | string
    status?: $Enums.ReminderStatus
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    doneAt?: Date | string | null
  }

  export type ReminderUncheckedCreateWithoutCreatedByInput = {
    id?: string
    type: $Enums.ReminderType
    dueAt: Date | string
    status?: $Enums.ReminderStatus
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    doneAt?: Date | string | null
  }

  export type ReminderCreateOrConnectWithoutCreatedByInput = {
    where: ReminderWhereUniqueInput
    create: XOR<ReminderCreateWithoutCreatedByInput, ReminderUncheckedCreateWithoutCreatedByInput>
  }

  export type ReminderCreateManyCreatedByInputEnvelope = {
    data: ReminderCreateManyCreatedByInput | ReminderCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    meta: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    meta: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type KitchenUpsertWithoutUsersInput = {
    update: XOR<KitchenUpdateWithoutUsersInput, KitchenUncheckedUpdateWithoutUsersInput>
    create: XOR<KitchenCreateWithoutUsersInput, KitchenUncheckedCreateWithoutUsersInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutUsersInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutUsersInput, KitchenUncheckedUpdateWithoutUsersInput>
  }

  export type KitchenUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type EmployeeProfileUpsertWithoutUserInput = {
    update: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    where?: EmployeeProfileWhereInput
  }

  export type EmployeeProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeProfileWhereInput
    data: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeProfileUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    baseSalaryMonthly?: IntFieldUpdateOperationsInput | number
    overtimeRatePerHour?: IntFieldUpdateOperationsInput | number
    latePenaltyPerMinute?: IntFieldUpdateOperationsInput | number
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUncheckedUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    baseSalaryMonthly?: IntFieldUpdateOperationsInput | number
    overtimeRatePerHour?: IntFieldUpdateOperationsInput | number
    latePenaltyPerMinute?: IntFieldUpdateOperationsInput | number
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutCreatedByInput, StockLedgerUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StockLedgerCreateWithoutCreatedByInput, StockLedgerUncheckedCreateWithoutCreatedByInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutCreatedByInput, StockLedgerUncheckedUpdateWithoutCreatedByInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutCreatedByInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutRequestedByInput, TransferUncheckedUpdateWithoutRequestedByInput>
    create: XOR<TransferCreateWithoutRequestedByInput, TransferUncheckedCreateWithoutRequestedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutRequestedByInput, TransferUncheckedUpdateWithoutRequestedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutRequestedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutApprovedByInput, TransferUncheckedUpdateWithoutApprovedByInput>
    create: XOR<TransferCreateWithoutApprovedByInput, TransferUncheckedCreateWithoutApprovedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutApprovedByInput, TransferUncheckedUpdateWithoutApprovedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutApprovedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutDispatchedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutDispatchedByInput, TransferUncheckedUpdateWithoutDispatchedByInput>
    create: XOR<TransferCreateWithoutDispatchedByInput, TransferUncheckedCreateWithoutDispatchedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutDispatchedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutDispatchedByInput, TransferUncheckedUpdateWithoutDispatchedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutDispatchedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutDispatchedByInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutReceivedByInput, TransferUncheckedUpdateWithoutReceivedByInput>
    create: XOR<TransferCreateWithoutReceivedByInput, TransferUncheckedCreateWithoutReceivedByInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutReceivedByInput, TransferUncheckedUpdateWithoutReceivedByInput>
  }

  export type TransferUpdateManyWithWhereWithoutReceivedByInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type AttendanceEventUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceEventWhereUniqueInput
    update: XOR<AttendanceEventUpdateWithoutEmployeeInput, AttendanceEventUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceEventCreateWithoutEmployeeInput, AttendanceEventUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceEventUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceEventWhereUniqueInput
    data: XOR<AttendanceEventUpdateWithoutEmployeeInput, AttendanceEventUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceEventUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceEventScalarWhereInput
    data: XOR<AttendanceEventUpdateManyMutationInput, AttendanceEventUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ShiftDaySummaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftDaySummaryWhereUniqueInput
    update: XOR<ShiftDaySummaryUpdateWithoutEmployeeInput, ShiftDaySummaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ShiftDaySummaryCreateWithoutEmployeeInput, ShiftDaySummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftDaySummaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftDaySummaryWhereUniqueInput
    data: XOR<ShiftDaySummaryUpdateWithoutEmployeeInput, ShiftDaySummaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type ShiftDaySummaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: ShiftDaySummaryScalarWhereInput
    data: XOR<ShiftDaySummaryUpdateManyMutationInput, ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    update: XOR<PayrollEntryUpdateWithoutEmployeeInput, PayrollEntryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    data: XOR<PayrollEntryUpdateWithoutEmployeeInput, PayrollEntryUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollEntryUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollEntryScalarWhereInput
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollEntryScalarWhereInput = {
    AND?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
    OR?: PayrollEntryScalarWhereInput[]
    NOT?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
    id?: StringFilter<"PayrollEntry"> | string
    periodId?: StringFilter<"PayrollEntry"> | string
    employeeUserId?: StringFilter<"PayrollEntry"> | string
    computedSalary?: IntFilter<"PayrollEntry"> | number
    overtimePay?: IntFilter<"PayrollEntry"> | number
    deductions?: IntFilter<"PayrollEntry"> | number
    netPay?: IntFilter<"PayrollEntry"> | number
    paidAt?: DateTimeNullableFilter<"PayrollEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
  }

  export type ReminderUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ReminderWhereUniqueInput
    update: XOR<ReminderUpdateWithoutCreatedByInput, ReminderUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ReminderCreateWithoutCreatedByInput, ReminderUncheckedCreateWithoutCreatedByInput>
  }

  export type ReminderUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ReminderWhereUniqueInput
    data: XOR<ReminderUpdateWithoutCreatedByInput, ReminderUncheckedUpdateWithoutCreatedByInput>
  }

  export type ReminderUpdateManyWithWhereWithoutCreatedByInput = {
    where: ReminderScalarWhereInput
    data: XOR<ReminderUpdateManyMutationInput, ReminderUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ReminderScalarWhereInput = {
    AND?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
    OR?: ReminderScalarWhereInput[]
    NOT?: ReminderScalarWhereInput | ReminderScalarWhereInput[]
    id?: StringFilter<"Reminder"> | string
    type?: EnumReminderTypeFilter<"Reminder"> | $Enums.ReminderType
    dueAt?: DateTimeFilter<"Reminder"> | Date | string
    status?: EnumReminderStatusFilter<"Reminder"> | $Enums.ReminderStatus
    payload?: JsonFilter<"Reminder">
    createdByUserId?: StringNullableFilter<"Reminder"> | string | null
    createdAt?: DateTimeFilter<"Reminder"> | Date | string
    doneAt?: DateTimeNullableFilter<"Reminder"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorUserId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    meta?: JsonFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutEmployeeProfileInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutEmployeeProfileInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutEmployeeProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
  }

  export type UserUpsertWithoutEmployeeProfileInput = {
    update: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type UserUpdateWithoutEmployeeProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutPurchasesInput
    lines?: PurchaseLineCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    kitchenId: string
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type KitchenStockCreateWithoutItemInput = {
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutStocksInput
  }

  export type KitchenStockUncheckedCreateWithoutItemInput = {
    kitchenId: string
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
  }

  export type KitchenStockCreateOrConnectWithoutItemInput = {
    where: KitchenStockWhereUniqueInput
    create: XOR<KitchenStockCreateWithoutItemInput, KitchenStockUncheckedCreateWithoutItemInput>
  }

  export type KitchenStockCreateManyItemInputEnvelope = {
    data: KitchenStockCreateManyItemInput | KitchenStockCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type StockLedgerCreateWithoutItemInput = {
    id?: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutLedgerInput
    createdBy?: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
  }

  export type StockLedgerUncheckedCreateWithoutItemInput = {
    id?: string
    kitchenId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type StockLedgerCreateOrConnectWithoutItemInput = {
    where: StockLedgerWhereUniqueInput
    create: XOR<StockLedgerCreateWithoutItemInput, StockLedgerUncheckedCreateWithoutItemInput>
  }

  export type StockLedgerCreateManyItemInputEnvelope = {
    data: StockLedgerCreateManyItemInput | StockLedgerCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseLineCreateWithoutItemInput = {
    id?: string
    qty: number
    unitCost: number
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutLinesInput
  }

  export type PurchaseLineUncheckedCreateWithoutItemInput = {
    id?: string
    purchaseOrderId: string
    qty: number
    unitCost: number
  }

  export type PurchaseLineCreateOrConnectWithoutItemInput = {
    where: PurchaseLineWhereUniqueInput
    create: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseLineCreateManyItemInputEnvelope = {
    data: PurchaseLineCreateManyItemInput | PurchaseLineCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type TransferLineCreateWithoutItemInput = {
    id?: string
    qty: number
    transfer: TransferCreateNestedOneWithoutLinesInput
  }

  export type TransferLineUncheckedCreateWithoutItemInput = {
    id?: string
    transferId: string
    qty: number
  }

  export type TransferLineCreateOrConnectWithoutItemInput = {
    where: TransferLineWhereUniqueInput
    create: XOR<TransferLineCreateWithoutItemInput, TransferLineUncheckedCreateWithoutItemInput>
  }

  export type TransferLineCreateManyItemInputEnvelope = {
    data: TransferLineCreateManyItemInput | TransferLineCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type KitchenStockUpsertWithWhereUniqueWithoutItemInput = {
    where: KitchenStockWhereUniqueInput
    update: XOR<KitchenStockUpdateWithoutItemInput, KitchenStockUncheckedUpdateWithoutItemInput>
    create: XOR<KitchenStockCreateWithoutItemInput, KitchenStockUncheckedCreateWithoutItemInput>
  }

  export type KitchenStockUpdateWithWhereUniqueWithoutItemInput = {
    where: KitchenStockWhereUniqueInput
    data: XOR<KitchenStockUpdateWithoutItemInput, KitchenStockUncheckedUpdateWithoutItemInput>
  }

  export type KitchenStockUpdateManyWithWhereWithoutItemInput = {
    where: KitchenStockScalarWhereInput
    data: XOR<KitchenStockUpdateManyMutationInput, KitchenStockUncheckedUpdateManyWithoutItemInput>
  }

  export type StockLedgerUpsertWithWhereUniqueWithoutItemInput = {
    where: StockLedgerWhereUniqueInput
    update: XOR<StockLedgerUpdateWithoutItemInput, StockLedgerUncheckedUpdateWithoutItemInput>
    create: XOR<StockLedgerCreateWithoutItemInput, StockLedgerUncheckedCreateWithoutItemInput>
  }

  export type StockLedgerUpdateWithWhereUniqueWithoutItemInput = {
    where: StockLedgerWhereUniqueInput
    data: XOR<StockLedgerUpdateWithoutItemInput, StockLedgerUncheckedUpdateWithoutItemInput>
  }

  export type StockLedgerUpdateManyWithWhereWithoutItemInput = {
    where: StockLedgerScalarWhereInput
    data: XOR<StockLedgerUpdateManyMutationInput, StockLedgerUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseLineUpsertWithWhereUniqueWithoutItemInput = {
    where: PurchaseLineWhereUniqueInput
    update: XOR<PurchaseLineUpdateWithoutItemInput, PurchaseLineUncheckedUpdateWithoutItemInput>
    create: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseLineUpdateWithWhereUniqueWithoutItemInput = {
    where: PurchaseLineWhereUniqueInput
    data: XOR<PurchaseLineUpdateWithoutItemInput, PurchaseLineUncheckedUpdateWithoutItemInput>
  }

  export type PurchaseLineUpdateManyWithWhereWithoutItemInput = {
    where: PurchaseLineScalarWhereInput
    data: XOR<PurchaseLineUpdateManyMutationInput, PurchaseLineUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseLineScalarWhereInput = {
    AND?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
    OR?: PurchaseLineScalarWhereInput[]
    NOT?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
    id?: StringFilter<"PurchaseLine"> | string
    purchaseOrderId?: StringFilter<"PurchaseLine"> | string
    itemId?: StringFilter<"PurchaseLine"> | string
    qty?: FloatFilter<"PurchaseLine"> | number
    unitCost?: FloatFilter<"PurchaseLine"> | number
  }

  export type TransferLineUpsertWithWhereUniqueWithoutItemInput = {
    where: TransferLineWhereUniqueInput
    update: XOR<TransferLineUpdateWithoutItemInput, TransferLineUncheckedUpdateWithoutItemInput>
    create: XOR<TransferLineCreateWithoutItemInput, TransferLineUncheckedCreateWithoutItemInput>
  }

  export type TransferLineUpdateWithWhereUniqueWithoutItemInput = {
    where: TransferLineWhereUniqueInput
    data: XOR<TransferLineUpdateWithoutItemInput, TransferLineUncheckedUpdateWithoutItemInput>
  }

  export type TransferLineUpdateManyWithWhereWithoutItemInput = {
    where: TransferLineScalarWhereInput
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyWithoutItemInput>
  }

  export type TransferLineScalarWhereInput = {
    AND?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
    OR?: TransferLineScalarWhereInput[]
    NOT?: TransferLineScalarWhereInput | TransferLineScalarWhereInput[]
    id?: StringFilter<"TransferLine"> | string
    transferId?: StringFilter<"TransferLine"> | string
    itemId?: StringFilter<"TransferLine"> | string
    qty?: FloatFilter<"TransferLine"> | number
  }

  export type KitchenCreateWithoutStocksInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutStocksInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutStocksInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutStocksInput, KitchenUncheckedCreateWithoutStocksInput>
  }

  export type ItemCreateWithoutStocksInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledger?: StockLedgerCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    transferLines?: TransferLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutStocksInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutStocksInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutStocksInput, ItemUncheckedCreateWithoutStocksInput>
  }

  export type KitchenUpsertWithoutStocksInput = {
    update: XOR<KitchenUpdateWithoutStocksInput, KitchenUncheckedUpdateWithoutStocksInput>
    create: XOR<KitchenCreateWithoutStocksInput, KitchenUncheckedCreateWithoutStocksInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutStocksInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutStocksInput, KitchenUncheckedUpdateWithoutStocksInput>
  }

  export type KitchenUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type ItemUpsertWithoutStocksInput = {
    update: XOR<ItemUpdateWithoutStocksInput, ItemUncheckedUpdateWithoutStocksInput>
    create: XOR<ItemCreateWithoutStocksInput, ItemUncheckedCreateWithoutStocksInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutStocksInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutStocksInput, ItemUncheckedUpdateWithoutStocksInput>
  }

  export type ItemUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: StockLedgerUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: StockLedgerUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type KitchenCreateWithoutLedgerInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutLedgerInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutLedgerInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutLedgerInput, KitchenUncheckedCreateWithoutLedgerInput>
  }

  export type ItemCreateWithoutLedgerInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    transferLines?: TransferLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutLedgerInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutLedgerInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutLedgerInput, ItemUncheckedCreateWithoutLedgerInput>
  }

  export type UserCreateWithoutCreatedLedgerEntriesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCreatedLedgerEntriesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCreatedLedgerEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
  }

  export type KitchenUpsertWithoutLedgerInput = {
    update: XOR<KitchenUpdateWithoutLedgerInput, KitchenUncheckedUpdateWithoutLedgerInput>
    create: XOR<KitchenCreateWithoutLedgerInput, KitchenUncheckedCreateWithoutLedgerInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutLedgerInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutLedgerInput, KitchenUncheckedUpdateWithoutLedgerInput>
  }

  export type KitchenUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type ItemUpsertWithoutLedgerInput = {
    update: XOR<ItemUpdateWithoutLedgerInput, ItemUncheckedUpdateWithoutLedgerInput>
    create: XOR<ItemCreateWithoutLedgerInput, ItemUncheckedCreateWithoutLedgerInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutLedgerInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutLedgerInput, ItemUncheckedUpdateWithoutLedgerInput>
  }

  export type ItemUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type UserUpsertWithoutCreatedLedgerEntriesInput = {
    update: XOR<UserUpdateWithoutCreatedLedgerEntriesInput, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
    create: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedLedgerEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedLedgerEntriesInput, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
  }

  export type UserUpdateWithoutCreatedLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type KitchenCreateWithoutPurchasesInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutPurchasesInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutPurchasesInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutPurchasesInput, KitchenUncheckedCreateWithoutPurchasesInput>
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseLineCreateWithoutPurchaseOrderInput = {
    id?: string
    qty: number
    unitCost: number
    item: ItemCreateNestedOneWithoutPurchaseLinesInput
  }

  export type PurchaseLineUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    itemId: string
    qty: number
    unitCost: number
  }

  export type PurchaseLineCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseLineWhereUniqueInput
    create: XOR<PurchaseLineCreateWithoutPurchaseOrderInput, PurchaseLineUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseLineCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseLineCreateManyPurchaseOrderInput | PurchaseLineCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type KitchenUpsertWithoutPurchasesInput = {
    update: XOR<KitchenUpdateWithoutPurchasesInput, KitchenUncheckedUpdateWithoutPurchasesInput>
    create: XOR<KitchenCreateWithoutPurchasesInput, KitchenUncheckedCreateWithoutPurchasesInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutPurchasesInput, KitchenUncheckedUpdateWithoutPurchasesInput>
  }

  export type KitchenUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLineUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseLineWhereUniqueInput
    update: XOR<PurchaseLineUpdateWithoutPurchaseOrderInput, PurchaseLineUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseLineCreateWithoutPurchaseOrderInput, PurchaseLineUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseLineUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseLineWhereUniqueInput
    data: XOR<PurchaseLineUpdateWithoutPurchaseOrderInput, PurchaseLineUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseLineUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseLineScalarWhereInput
    data: XOR<PurchaseLineUpdateManyMutationInput, PurchaseLineUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderCreateWithoutLinesInput = {
    id?: string
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen: KitchenCreateNestedOneWithoutPurchasesInput
    supplier?: SupplierCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutLinesInput = {
    id?: string
    kitchenId: string
    supplierId?: string | null
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutLinesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
  }

  export type ItemCreateWithoutPurchaseLinesInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockCreateNestedManyWithoutItemInput
    ledger?: StockLedgerCreateNestedManyWithoutItemInput
    transferLines?: TransferLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPurchaseLinesInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutItemInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutItemInput
    transferLines?: TransferLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPurchaseLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
  }

  export type PurchaseOrderUpsertWithoutLinesInput = {
    update: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type PurchaseOrderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutPurchasesNestedInput
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpsertWithoutPurchaseLinesInput = {
    update: XOR<ItemUpdateWithoutPurchaseLinesInput, ItemUncheckedUpdateWithoutPurchaseLinesInput>
    create: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPurchaseLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPurchaseLinesInput, ItemUncheckedUpdateWithoutPurchaseLinesInput>
  }

  export type ItemUpdateWithoutPurchaseLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUpdateManyWithoutItemNestedInput
    ledger?: StockLedgerUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPurchaseLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUncheckedUpdateManyWithoutItemNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutItemNestedInput
    transferLines?: TransferLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type KitchenCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutTransfersFromInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutTransfersFromInput, KitchenUncheckedCreateWithoutTransfersFromInput>
  }

  export type KitchenCreateWithoutTransfersToInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutTransfersToInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutTransfersToInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutTransfersToInput, KitchenUncheckedCreateWithoutTransfersToInput>
  }

  export type TransferLineCreateWithoutTransferInput = {
    id?: string
    qty: number
    item: ItemCreateNestedOneWithoutTransferLinesInput
  }

  export type TransferLineUncheckedCreateWithoutTransferInput = {
    id?: string
    itemId: string
    qty: number
  }

  export type TransferLineCreateOrConnectWithoutTransferInput = {
    where: TransferLineWhereUniqueInput
    create: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput>
  }

  export type TransferLineCreateManyTransferInputEnvelope = {
    data: TransferLineCreateManyTransferInput | TransferLineCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRequestedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutRequestedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutRequestedTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestedTransfersInput, UserUncheckedCreateWithoutRequestedTransfersInput>
  }

  export type UserCreateWithoutApprovedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutApprovedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutApprovedTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
  }

  export type UserCreateWithoutDispatchedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutDispatchedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutDispatchedTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDispatchedTransfersInput, UserUncheckedCreateWithoutDispatchedTransfersInput>
  }

  export type UserCreateWithoutReceivedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutReceivedTransfersInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutReceivedTransfersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
  }

  export type KitchenUpsertWithoutTransfersFromInput = {
    update: XOR<KitchenUpdateWithoutTransfersFromInput, KitchenUncheckedUpdateWithoutTransfersFromInput>
    create: XOR<KitchenCreateWithoutTransfersFromInput, KitchenUncheckedCreateWithoutTransfersFromInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutTransfersFromInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutTransfersFromInput, KitchenUncheckedUpdateWithoutTransfersFromInput>
  }

  export type KitchenUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUpsertWithoutTransfersToInput = {
    update: XOR<KitchenUpdateWithoutTransfersToInput, KitchenUncheckedUpdateWithoutTransfersToInput>
    create: XOR<KitchenCreateWithoutTransfersToInput, KitchenUncheckedCreateWithoutTransfersToInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutTransfersToInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutTransfersToInput, KitchenUncheckedUpdateWithoutTransfersToInput>
  }

  export type KitchenUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type TransferLineUpsertWithWhereUniqueWithoutTransferInput = {
    where: TransferLineWhereUniqueInput
    update: XOR<TransferLineUpdateWithoutTransferInput, TransferLineUncheckedUpdateWithoutTransferInput>
    create: XOR<TransferLineCreateWithoutTransferInput, TransferLineUncheckedCreateWithoutTransferInput>
  }

  export type TransferLineUpdateWithWhereUniqueWithoutTransferInput = {
    where: TransferLineWhereUniqueInput
    data: XOR<TransferLineUpdateWithoutTransferInput, TransferLineUncheckedUpdateWithoutTransferInput>
  }

  export type TransferLineUpdateManyWithWhereWithoutTransferInput = {
    where: TransferLineScalarWhereInput
    data: XOR<TransferLineUpdateManyMutationInput, TransferLineUncheckedUpdateManyWithoutTransferInput>
  }

  export type UserUpsertWithoutRequestedTransfersInput = {
    update: XOR<UserUpdateWithoutRequestedTransfersInput, UserUncheckedUpdateWithoutRequestedTransfersInput>
    create: XOR<UserCreateWithoutRequestedTransfersInput, UserUncheckedCreateWithoutRequestedTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestedTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestedTransfersInput, UserUncheckedUpdateWithoutRequestedTransfersInput>
  }

  export type UserUpdateWithoutRequestedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithoutApprovedTransfersInput = {
    update: XOR<UserUpdateWithoutApprovedTransfersInput, UserUncheckedUpdateWithoutApprovedTransfersInput>
    create: XOR<UserCreateWithoutApprovedTransfersInput, UserUncheckedCreateWithoutApprovedTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedTransfersInput, UserUncheckedUpdateWithoutApprovedTransfersInput>
  }

  export type UserUpdateWithoutApprovedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithoutDispatchedTransfersInput = {
    update: XOR<UserUpdateWithoutDispatchedTransfersInput, UserUncheckedUpdateWithoutDispatchedTransfersInput>
    create: XOR<UserCreateWithoutDispatchedTransfersInput, UserUncheckedCreateWithoutDispatchedTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDispatchedTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDispatchedTransfersInput, UserUncheckedUpdateWithoutDispatchedTransfersInput>
  }

  export type UserUpdateWithoutDispatchedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutDispatchedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithoutReceivedTransfersInput = {
    update: XOR<UserUpdateWithoutReceivedTransfersInput, UserUncheckedUpdateWithoutReceivedTransfersInput>
    create: XOR<UserCreateWithoutReceivedTransfersInput, UserUncheckedCreateWithoutReceivedTransfersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedTransfersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedTransfersInput, UserUncheckedUpdateWithoutReceivedTransfersInput>
  }

  export type UserUpdateWithoutReceivedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type TransferCreateWithoutLinesInput = {
    id?: string
    status?: $Enums.TransferStatus
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
    fromKitchen: KitchenCreateNestedOneWithoutTransfersFromInput
    toKitchen: KitchenCreateNestedOneWithoutTransfersToInput
    requestedBy?: UserCreateNestedOneWithoutRequestedTransfersInput
    approvedBy?: UserCreateNestedOneWithoutApprovedTransfersInput
    dispatchedBy?: UserCreateNestedOneWithoutDispatchedTransfersInput
    receivedBy?: UserCreateNestedOneWithoutReceivedTransfersInput
  }

  export type TransferUncheckedCreateWithoutLinesInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type TransferCreateOrConnectWithoutLinesInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
  }

  export type ItemCreateWithoutTransferLinesInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockCreateNestedManyWithoutItemInput
    ledger?: StockLedgerCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutTransferLinesInput = {
    id?: string
    name: string
    category?: string | null
    uom: string
    reorderPoint?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutItemInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutTransferLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTransferLinesInput, ItemUncheckedCreateWithoutTransferLinesInput>
  }

  export type TransferUpsertWithoutLinesInput = {
    update: XOR<TransferUpdateWithoutLinesInput, TransferUncheckedUpdateWithoutLinesInput>
    create: XOR<TransferCreateWithoutLinesInput, TransferUncheckedCreateWithoutLinesInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutLinesInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutLinesInput, TransferUncheckedUpdateWithoutLinesInput>
  }

  export type TransferUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromKitchen?: KitchenUpdateOneRequiredWithoutTransfersFromNestedInput
    toKitchen?: KitchenUpdateOneRequiredWithoutTransfersToNestedInput
    requestedBy?: UserUpdateOneWithoutRequestedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
    dispatchedBy?: UserUpdateOneWithoutDispatchedTransfersNestedInput
    receivedBy?: UserUpdateOneWithoutReceivedTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemUpsertWithoutTransferLinesInput = {
    update: XOR<ItemUpdateWithoutTransferLinesInput, ItemUncheckedUpdateWithoutTransferLinesInput>
    create: XOR<ItemCreateWithoutTransferLinesInput, ItemUncheckedCreateWithoutTransferLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutTransferLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutTransferLinesInput, ItemUncheckedUpdateWithoutTransferLinesInput>
  }

  export type ItemUpdateWithoutTransferLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUpdateManyWithoutItemNestedInput
    ledger?: StockLedgerUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutTransferLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uom?: StringFieldUpdateOperationsInput | string
    reorderPoint?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: KitchenStockUncheckedUpdateManyWithoutItemNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type UserCreateWithoutAttendanceEventsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutAttendanceEventsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutAttendanceEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
  }

  export type KitchenCreateWithoutAttendanceEventsInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutAttendanceEventsInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutAttendanceEventsInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutAttendanceEventsInput, KitchenUncheckedCreateWithoutAttendanceEventsInput>
  }

  export type UserUpsertWithoutAttendanceEventsInput = {
    update: XOR<UserUpdateWithoutAttendanceEventsInput, UserUncheckedUpdateWithoutAttendanceEventsInput>
    create: XOR<UserCreateWithoutAttendanceEventsInput, UserUncheckedCreateWithoutAttendanceEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceEventsInput, UserUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type UserUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type KitchenUpsertWithoutAttendanceEventsInput = {
    update: XOR<KitchenUpdateWithoutAttendanceEventsInput, KitchenUncheckedUpdateWithoutAttendanceEventsInput>
    create: XOR<KitchenCreateWithoutAttendanceEventsInput, KitchenUncheckedCreateWithoutAttendanceEventsInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutAttendanceEventsInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutAttendanceEventsInput, KitchenUncheckedUpdateWithoutAttendanceEventsInput>
  }

  export type KitchenUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutAttendanceEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type UserCreateWithoutShiftSummariesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutShiftSummariesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutShiftSummariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftSummariesInput, UserUncheckedCreateWithoutShiftSummariesInput>
  }

  export type KitchenCreateWithoutShiftSummariesInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutShiftSummariesInput = {
    id?: string
    name: string
    type: $Enums.KitchenType
    address?: string | null
    lat?: number | null
    lng?: number | null
    geofenceRadiusMeters?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutKitchenInput
    stocks?: KitchenStockUncheckedCreateNestedManyWithoutKitchenInput
    ledger?: StockLedgerUncheckedCreateNestedManyWithoutKitchenInput
    purchases?: PurchaseOrderUncheckedCreateNestedManyWithoutKitchenInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromKitchenInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToKitchenInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutShiftSummariesInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutShiftSummariesInput, KitchenUncheckedCreateWithoutShiftSummariesInput>
  }

  export type UserUpsertWithoutShiftSummariesInput = {
    update: XOR<UserUpdateWithoutShiftSummariesInput, UserUncheckedUpdateWithoutShiftSummariesInput>
    create: XOR<UserCreateWithoutShiftSummariesInput, UserUncheckedCreateWithoutShiftSummariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftSummariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftSummariesInput, UserUncheckedUpdateWithoutShiftSummariesInput>
  }

  export type UserUpdateWithoutShiftSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type KitchenUpsertWithoutShiftSummariesInput = {
    update: XOR<KitchenUpdateWithoutShiftSummariesInput, KitchenUncheckedUpdateWithoutShiftSummariesInput>
    create: XOR<KitchenCreateWithoutShiftSummariesInput, KitchenUncheckedCreateWithoutShiftSummariesInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutShiftSummariesInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutShiftSummariesInput, KitchenUncheckedUpdateWithoutShiftSummariesInput>
  }

  export type KitchenUpdateWithoutShiftSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutShiftSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumKitchenTypeFieldUpdateOperationsInput | $Enums.KitchenType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    geofenceRadiusMeters?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutKitchenNestedInput
    stocks?: KitchenStockUncheckedUpdateManyWithoutKitchenNestedInput
    ledger?: StockLedgerUncheckedUpdateManyWithoutKitchenNestedInput
    purchases?: PurchaseOrderUncheckedUpdateManyWithoutKitchenNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromKitchenNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToKitchenNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type PayrollEntryCreateWithoutPeriodInput = {
    id?: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutPayrollEntriesInput
  }

  export type PayrollEntryUncheckedCreateWithoutPeriodInput = {
    id?: string
    employeeUserId: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateOrConnectWithoutPeriodInput = {
    where: PayrollEntryWhereUniqueInput
    create: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput>
  }

  export type PayrollEntryCreateManyPeriodInputEnvelope = {
    data: PayrollEntryCreateManyPeriodInput | PayrollEntryCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type PayrollEntryUpsertWithWhereUniqueWithoutPeriodInput = {
    where: PayrollEntryWhereUniqueInput
    update: XOR<PayrollEntryUpdateWithoutPeriodInput, PayrollEntryUncheckedUpdateWithoutPeriodInput>
    create: XOR<PayrollEntryCreateWithoutPeriodInput, PayrollEntryUncheckedCreateWithoutPeriodInput>
  }

  export type PayrollEntryUpdateWithWhereUniqueWithoutPeriodInput = {
    where: PayrollEntryWhereUniqueInput
    data: XOR<PayrollEntryUpdateWithoutPeriodInput, PayrollEntryUncheckedUpdateWithoutPeriodInput>
  }

  export type PayrollEntryUpdateManyWithWhereWithoutPeriodInput = {
    where: PayrollEntryScalarWhereInput
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyWithoutPeriodInput>
  }

  export type PayrollPeriodCreateWithoutEntriesInput = {
    id?: string
    month: string
    status?: $Enums.PayrollPeriodStatus
    generatedAt?: Date | string
  }

  export type PayrollPeriodUncheckedCreateWithoutEntriesInput = {
    id?: string
    month: string
    status?: $Enums.PayrollPeriodStatus
    generatedAt?: Date | string
  }

  export type PayrollPeriodCreateOrConnectWithoutEntriesInput = {
    where: PayrollPeriodWhereUniqueInput
    create: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
  }

  export type UserCreateWithoutPayrollEntriesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPayrollEntriesInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPayrollEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
  }

  export type PayrollPeriodUpsertWithoutEntriesInput = {
    update: XOR<PayrollPeriodUpdateWithoutEntriesInput, PayrollPeriodUncheckedUpdateWithoutEntriesInput>
    create: XOR<PayrollPeriodCreateWithoutEntriesInput, PayrollPeriodUncheckedCreateWithoutEntriesInput>
    where?: PayrollPeriodWhereInput
  }

  export type PayrollPeriodUpdateToOneWithWhereWithoutEntriesInput = {
    where?: PayrollPeriodWhereInput
    data: XOR<PayrollPeriodUpdateWithoutEntriesInput, PayrollPeriodUncheckedUpdateWithoutEntriesInput>
  }

  export type PayrollPeriodUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollPeriodUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: EnumPayrollPeriodStatusFieldUpdateOperationsInput | $Enums.PayrollPeriodStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPayrollEntriesInput = {
    update: XOR<UserUpdateWithoutPayrollEntriesInput, UserUncheckedUpdateWithoutPayrollEntriesInput>
    create: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPayrollEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPayrollEntriesInput, UserUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type UserUpdateWithoutPayrollEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutRemindersCreatedInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutRemindersCreatedInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutRemindersCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRemindersCreatedInput, UserUncheckedCreateWithoutRemindersCreatedInput>
  }

  export type UserUpsertWithoutRemindersCreatedInput = {
    update: XOR<UserUpdateWithoutRemindersCreatedInput, UserUncheckedUpdateWithoutRemindersCreatedInput>
    create: XOR<UserCreateWithoutRemindersCreatedInput, UserUncheckedCreateWithoutRemindersCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRemindersCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRemindersCreatedInput, UserUncheckedUpdateWithoutRemindersCreatedInput>
  }

  export type UserUpdateWithoutRemindersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutRemindersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kitchen?: KitchenCreateNestedOneWithoutUsersInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    kitchenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    createdLedgerEntries?: StockLedgerUncheckedCreateNestedManyWithoutCreatedByInput
    requestedTransfers?: TransferUncheckedCreateNestedManyWithoutRequestedByInput
    approvedTransfers?: TransferUncheckedCreateNestedManyWithoutApprovedByInput
    dispatchedTransfers?: TransferUncheckedCreateNestedManyWithoutDispatchedByInput
    receivedTransfers?: TransferUncheckedCreateNestedManyWithoutReceivedByInput
    attendanceEvents?: AttendanceEventUncheckedCreateNestedManyWithoutEmployeeInput
    shiftSummaries?: ShiftDaySummaryUncheckedCreateNestedManyWithoutEmployeeInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    remindersCreated?: ReminderUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneWithoutUsersNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyKitchenInput = {
    id?: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenStockCreateManyKitchenInput = {
    itemId: string
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
  }

  export type StockLedgerCreateManyKitchenInput = {
    id?: string
    itemId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type PurchaseOrderCreateManyKitchenInput = {
    id?: string
    supplierId?: string | null
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyFromKitchenInput = {
    id?: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type TransferCreateManyToKitchenInput = {
    id?: string
    fromKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type AttendanceEventCreateManyKitchenInput = {
    id?: string
    employeeUserId: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type ShiftDaySummaryCreateManyKitchenInput = {
    id?: string
    employeeUserId: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    createdLedgerEntries?: StockLedgerUncheckedUpdateManyWithoutCreatedByNestedInput
    requestedTransfers?: TransferUncheckedUpdateManyWithoutRequestedByNestedInput
    approvedTransfers?: TransferUncheckedUpdateManyWithoutApprovedByNestedInput
    dispatchedTransfers?: TransferUncheckedUpdateManyWithoutDispatchedByNestedInput
    receivedTransfers?: TransferUncheckedUpdateManyWithoutReceivedByNestedInput
    attendanceEvents?: AttendanceEventUncheckedUpdateManyWithoutEmployeeNestedInput
    shiftSummaries?: ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    remindersCreated?: ReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenStockUpdateWithoutKitchenInput = {
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutStocksNestedInput
  }

  export type KitchenStockUncheckedUpdateWithoutKitchenInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenStockUncheckedUpdateManyWithoutKitchenInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutLedgerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedLedgerEntriesNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutPurchaseOrdersNestedInput
    lines?: PurchaseLineUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutFromKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toKitchen?: KitchenUpdateOneRequiredWithoutTransfersToNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
    requestedBy?: UserUpdateOneWithoutRequestedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
    dispatchedBy?: UserUpdateOneWithoutDispatchedTransfersNestedInput
    receivedBy?: UserUpdateOneWithoutReceivedTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutFromKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutFromKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutToKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromKitchen?: KitchenUpdateOneRequiredWithoutTransfersFromNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
    requestedBy?: UserUpdateOneWithoutRequestedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
    dispatchedBy?: UserUpdateOneWithoutDispatchedTransfersNestedInput
    receivedBy?: UserUpdateOneWithoutReceivedTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutToKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutToKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUncheckedUpdateManyWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftDaySummaryUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutShiftSummariesNestedInput
  }

  export type ShiftDaySummaryUncheckedUpdateWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftDaySummaryUncheckedUpdateManyWithoutKitchenInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerCreateManyCreatedByInput = {
    id?: string
    kitchenId: string
    itemId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
  }

  export type TransferCreateManyRequestedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type TransferCreateManyApprovedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    dispatchedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type TransferCreateManyDispatchedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    receivedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type TransferCreateManyReceivedByInput = {
    id?: string
    fromKitchenId: string
    toKitchenId: string
    status?: $Enums.TransferStatus
    requestedByUserId?: string | null
    approvedByUserId?: string | null
    dispatchedByUserId?: string | null
    requestedAt?: Date | string
    approvedAt?: Date | string | null
    dispatchedAt?: Date | string | null
    receivedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type AttendanceEventCreateManyEmployeeInput = {
    id?: string
    kitchenId: string
    type: $Enums.AttendanceType
    method?: $Enums.AttendanceMethod
    lat?: number | null
    lng?: number | null
    distanceMeters?: number | null
    createdAt?: Date | string
  }

  export type ShiftDaySummaryCreateManyEmployeeInput = {
    id?: string
    kitchenId: string
    date: Date | string
    minutesWorked?: number
    minutesLate?: number
    overtimeMinutes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateManyEmployeeInput = {
    id?: string
    periodId: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderCreateManyCreatedByInput = {
    id?: string
    type: $Enums.ReminderType
    dueAt: Date | string
    status?: $Enums.ReminderStatus
    payload: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    doneAt?: Date | string | null
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    meta: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StockLedgerUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutLedgerNestedInput
    item?: ItemUpdateOneRequiredWithoutLedgerNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromKitchen?: KitchenUpdateOneRequiredWithoutTransfersFromNestedInput
    toKitchen?: KitchenUpdateOneRequiredWithoutTransfersToNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
    dispatchedBy?: UserUpdateOneWithoutDispatchedTransfersNestedInput
    receivedBy?: UserUpdateOneWithoutReceivedTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromKitchen?: KitchenUpdateOneRequiredWithoutTransfersFromNestedInput
    toKitchen?: KitchenUpdateOneRequiredWithoutTransfersToNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
    requestedBy?: UserUpdateOneWithoutRequestedTransfersNestedInput
    dispatchedBy?: UserUpdateOneWithoutDispatchedTransfersNestedInput
    receivedBy?: UserUpdateOneWithoutReceivedTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutDispatchedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromKitchen?: KitchenUpdateOneRequiredWithoutTransfersFromNestedInput
    toKitchen?: KitchenUpdateOneRequiredWithoutTransfersToNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
    requestedBy?: UserUpdateOneWithoutRequestedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
    receivedBy?: UserUpdateOneWithoutReceivedTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutDispatchedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutDispatchedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromKitchen?: KitchenUpdateOneRequiredWithoutTransfersFromNestedInput
    toKitchen?: KitchenUpdateOneRequiredWithoutTransfersToNestedInput
    lines?: TransferLineUpdateManyWithoutTransferNestedInput
    requestedBy?: UserUpdateOneWithoutRequestedTransfersNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedTransfersNestedInput
    dispatchedBy?: UserUpdateOneWithoutDispatchedTransfersNestedInput
  }

  export type TransferUncheckedUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lines?: TransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromKitchenId?: StringFieldUpdateOperationsInput | string
    toKitchenId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceEventUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutAttendanceEventsNestedInput
  }

  export type AttendanceEventUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceEventUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttendanceTypeFieldUpdateOperationsInput | $Enums.AttendanceType
    method?: EnumAttendanceMethodFieldUpdateOperationsInput | $Enums.AttendanceMethod
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    distanceMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftDaySummaryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutShiftSummariesNestedInput
  }

  export type ShiftDaySummaryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftDaySummaryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minutesWorked?: IntFieldUpdateOperationsInput | number
    minutesLate?: IntFieldUpdateOperationsInput | number
    overtimeMinutes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PayrollPeriodUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type PayrollEntryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReminderUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReminderUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReminderStatusFieldUpdateOperationsInput | $Enums.ReminderStatus
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: string
    kitchenId: string
    status?: string
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutPurchasesNestedInput
    lines?: PurchaseLineUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenStockCreateManyItemInput = {
    kitchenId: string
    onHandQty?: number
    avgCost?: number
    updatedAt?: Date | string
  }

  export type StockLedgerCreateManyItemInput = {
    id?: string
    kitchenId: string
    type: $Enums.StockLedgerType
    qtyDelta: number
    unitCost?: number | null
    refType?: string | null
    refId?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type PurchaseLineCreateManyItemInput = {
    id?: string
    purchaseOrderId: string
    qty: number
    unitCost: number
  }

  export type TransferLineCreateManyItemInput = {
    id?: string
    transferId: string
    qty: number
  }

  export type KitchenStockUpdateWithoutItemInput = {
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutStocksNestedInput
  }

  export type KitchenStockUncheckedUpdateWithoutItemInput = {
    kitchenId?: StringFieldUpdateOperationsInput | string
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenStockUncheckedUpdateManyWithoutItemInput = {
    kitchenId?: StringFieldUpdateOperationsInput | string
    onHandQty?: FloatFieldUpdateOperationsInput | number
    avgCost?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kitchen?: KitchenUpdateOneRequiredWithoutLedgerNestedInput
    createdBy?: UserUpdateOneWithoutCreatedLedgerEntriesNestedInput
  }

  export type StockLedgerUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLedgerUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockLedgerTypeFieldUpdateOperationsInput | $Enums.StockLedgerType
    qtyDelta?: FloatFieldUpdateOperationsInput | number
    unitCost?: NullableFloatFieldUpdateOperationsInput | number | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type PurchaseLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    transfer?: TransferUpdateOneRequiredWithoutLinesNestedInput
  }

  export type TransferLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseLineCreateManyPurchaseOrderInput = {
    id?: string
    itemId: string
    qty: number
    unitCost: number
  }

  export type PurchaseLineUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutPurchaseLinesNestedInput
  }

  export type PurchaseLineUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
  }

  export type PurchaseLineUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferLineCreateManyTransferInput = {
    id?: string
    itemId: string
    qty: number
  }

  export type TransferLineUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutTransferLinesNestedInput
  }

  export type TransferLineUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferLineUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
  }

  export type PayrollEntryCreateManyPeriodInput = {
    id?: string
    employeeUserId: string
    computedSalary: number
    overtimePay?: number
    deductions?: number
    netPay: number
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutPayrollEntriesNestedInput
  }

  export type PayrollEntryUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeUserId?: StringFieldUpdateOperationsInput | string
    computedSalary?: IntFieldUpdateOperationsInput | number
    overtimePay?: IntFieldUpdateOperationsInput | number
    deductions?: IntFieldUpdateOperationsInput | number
    netPay?: IntFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}